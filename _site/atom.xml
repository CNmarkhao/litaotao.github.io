<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Taotao's Zone</title>
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css" type="text/css" />
  <link rel="stylesheet" href="/css/default.css" type="text/css" />
  <link rel="stylesheet" href="/css/desktop.css" type="text/css" />
  <link rel="stylesheet" href="/css/mobile.css" type="text/css" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
  <script src="/js/jquery-1.11.0.min.js" type="text/javascript"></script>
  <script src="/js/jquery-migrate-1.2.1.js" type="text/javascript"></script>
  <script src="/js/jquery.transit.min.js" type="text/javascript"></script>
  <script src="/js/common.js" type="text/javascript"></script>
</head>
<body>
  <?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

   <title>Taotao's Zone</title>
   <link href="http://litaotao.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://litaotao.github.io" rel="alternate" type="text/html" />
   <updated>2014-11-16T22:16:55+08:00</updated>
   <id>http://litaotao.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>SVN 中的branches, tags和trunk</title>
     <link href="/svn-branch-trunk-tags"/>
     <updated>2014-11-14T00:00:00+08:00</updated>
     <id>/svn-branch-trunk-tags</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 直接上正文&lt;/h2&gt;

&lt;p&gt;　　正文就是，关于这点，&lt;a href=&quot;http://stackoverflow.com/questions/16142/what-do-branch-tag-and-trunk-mean-in-subversion-repositories&quot;&gt;SO&lt;/a&gt;已经有多答案了，下面我引用一下投票最多的答案。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Trunk&lt;/strong&gt;：would be the main body of development, originating from the start of the project until the present.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Branch&lt;/strong&gt;： will be a copy of code derived from a certain point in the trunk that is used for applying major changes to the code while preserving the integrity of the code in the trunk. If the major changes work according to plan, they are usually merged back into the trunk.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tag&lt;/strong&gt;： will be a point in time on the trunk or a branch that you wish to preserve. The two main reasons for preservation would be that either this is a major release of the software, whether alpha, beta, RC or RTM, or this is the most stable point of the software before major revisions on the trunk were applied.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. 我是怎么理解的&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Trunk&lt;/strong&gt;: 你的现女友，你会付出很多东西在她身上，期待美好的结果，但时不时也会吵吵闹闹，出现一些意外情况；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Branches&lt;/strong&gt;：你的前女友们，按时间排序，她们都有很多相似的东西，那就是隐藏在你最深处的东西，你的Kernel，可以说是你的爱情观、人生观、事业观等等啦；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tags&lt;/strong&gt;：让你记忆尤深的前女友们，她们可不像你这样善变，分手后依然爱你，甚至当你有一天被现女友携款潜逃将你抛弃后，你还能回去找她们，kiss她们的香唇。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. 一些资源&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://tortoisesvn.net/docs/release/TortoiseSVN_zh_CN/index.html&quot;&gt;TortoiseSVN 1.8 中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-zh-cn.html&quot;&gt;图解git命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>一个完整的 OTP 应用</title>
     <link href="/an-integrated-otp-application"/>
     <updated>2014-11-10T00:00:00+08:00</updated>
     <id>/an-integrated-otp-application</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;　　在实践 &lt;em&gt;Erlang and OTP in Action&lt;/em&gt; 的第六章的时候，确实遇到了不少问题，后来慢慢多看了几遍书，多阅读了几次源码，特别是阅读了 application 的源码后，才慢慢理解了这章所讲的这个应用。这个总结不会很长，原本就想简单记在书上的，但想到以后也许会有一些更新，还有一些流程图的绘制需要经过多次修改，就还是放到github上来了，说实话，真挺感谢github的，让我学习和管理代码如此方便。&lt;/p&gt;

&lt;h2&gt;2. 程序运行流程&lt;/h2&gt;

&lt;p&gt;　　下图是整个simple_cache应用运行的流程，我们先上图，然后在后面再说说重要的地方。
&lt;img src=&quot;../../images/simple_cache.jpg&quot; alt=&quot;simple_cache运行流程图&quot; /&gt;
　　
　　下面我们再说明一下各个模块各自的职责：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sc_app: 应用行为模式的实现模块&lt;/li&gt;
&lt;li&gt;simple_cache: 用户API，应用的外部接口&lt;/li&gt;
&lt;li&gt;sc_store: 用于封装键和pid之间映射关系的模块&lt;/li&gt;
&lt;li&gt;sc_element: 缓存数据存储进程&lt;/li&gt;
&lt;li&gt;sc_sup: 根监督者实现模块&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　其中sc_app并没有出现在流程图中，因为流程图是展示应用已经被启动后的运行流程，而sc_app是用于启动应用的，这点会单独在下一节讨论。现在先focus在应用成功启动后的运行流程。下面我们分别以insert，lookup，delete过程单独看一下流程。&lt;/p&gt;

&lt;h3&gt;2.1 insert流程&lt;/h3&gt;

&lt;p&gt;　　假设需要缓存的键为 K，值为 V。用户在API接口调用 &lt;code&gt;simple_cache:insert(K, V)&lt;/code&gt;；simple_cache先调用sc_store:lookup(K) 检查这个键是否已经缓存，若缓存则更新键值为V，否则新建一个缓存进程。因为我们是第一次insert，所以会调用sc_element来新建一个进程，并将值 V 放到这个新建进程的状态里，这个状态被定义为一个记录&lt;code&gt;-record(state, {value, lease_time, start_time}).&lt;/code&gt;；即sc_element新建的进程状态state中的value字段存储的就是我们需要缓存的键值 v。sc_element新建的进程PID会被返回，且返回后会被组合成(K, PID), 然后调用sc_store:insert(K, PID)来存储键K和进程的PID。(K, PID) 是存储到ets表里的。
　　从上面可以看到，其实使用进程做了一次中转类似的操作。我们原本要缓存一对键值k－v，现在是将k和进程pid单一映射，存储在ets表中，然后将值v存储到进程到状态state里。这样，当要拿到一个缓存的键值k－v时，先到ets表中查找k对应到进程pid，然后根据再读取这个进程到状态state即可。这个过程可以参考下图：
&lt;img src=&quot;../../images/key-value-map.jpg&quot; alt=&quot;key-value-mapping&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;2.2 lookup流程&lt;/h3&gt;

&lt;p&gt;　　其实lookup流程上面也提到了，即先根据k查找对应到pid，然后在以模块到方式调用sc_element来查找pid对应到进程到状态。这里可能大家很容易混淆标注1中的sc_element和标注2中supervisor监督的一系列sc_element自进程。其实一开始我也很纳闷，supervisor下有这么多sc_element自进程，可当调用sc_element来查找进程pid当状态时，是调用哪个自进程呢？这里其实是一个比较容易犯的低级错误，当调用sc_element来读取进程pid的状态时，是将sc_element当作一个模块来调用，和supervisor监督下的sc_element自进程毛线关系都没有，根本就不是一个概念呀。&lt;/p&gt;

&lt;h3&gt;2.3 delete流程&lt;/h3&gt;

&lt;p&gt;　　至于delete流程，则非常简单了，调用流程如下：simple_cache:delete/1 -&gt; sc_store:lookup/1 -&gt; sc_element:delete/1 -&gt; gen_server:cast/2 -&gt; handle_cast/2.&lt;/p&gt;

&lt;h2&gt;3. OTP 应用的标准组织结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;doc  用于存放文档。如果文档时用EDoc生成，请将overview.edoc文件放在此处，其余的文件将会自动生成；&lt;/li&gt;
&lt;li&gt;ebin  用于存放编译后的代码(.beam文件)，包含应用元数据的.app文件也应放在此处；&lt;/li&gt;
&lt;li&gt;include  用于存放公共头文件。所有作为公共API的一部分的.hrl文件都应该放在这个目录中。仅用于你自己的代码之中且不打算公开的私有.hrl文件则应该与其它源码文件一起放；&lt;/li&gt;
&lt;li&gt;priv  用于存放各种需要随应用一起发布的其他内容。定位priv目录的方法很简单：调用code:priv_dir(&lt;application-name&gt;)，便会以字符串形式得到priv目录完整路径；&lt;/li&gt;
&lt;li&gt;src  存放应用源代码；&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;4. 应用元数据描述文件说明&lt;/h2&gt;

&lt;p&gt;　　&lt;a href=&quot;http://www.erlang.org/doc/man/app.html&quot;&gt;官方关于应用元数据描述文件的文档&lt;/a&gt;
　　我们的应用元数据如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{application, simple_cache,
    [{description, &quot;A simple caching system&quot;},
     {vsn, &quot;0.1.0&quot;},
     {modules, [sc_app,
                sc_sup]},
     {registered, [sc_sup]},
     {applications, [kernel, sasl, stdlib]},
     {mod, {sc_app, []}}}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　应用元数据文件里其实是定义了一个Erlang项式，这里真想吐槽一下，感觉这样写好麻烦，Python 里的配置文件多方面啊，简单易用。而Erlang应用元数据里的这个Erlang项式，是一个三元组{application, ApplicationName, ApplicationConfigureList}. application表示用application来启动，ApplicationName代表这个应用的名字，应该和应用元数据文件的文件名是一样的，ApplicationConfigureList是应用描述应用配置的信息，是一个列表类型。下面我们看看这个配置列表里的一些信息说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;description：应用描述；&lt;/li&gt;
&lt;li&gt;vsn：应用版本，推荐&amp;lt;主版本号&gt;.&amp;lt;次版本号&gt;.&amp;lt;修正版本号&gt;的格式；&lt;/li&gt;
&lt;li&gt;modules：应用中的模块列表，erlang的systools会用这个列表中的模块来制作启动脚本和应用程序包；&lt;/li&gt;
&lt;li&gt;registered：需要在系统中注册的模块名字，常用于系统服务等场合，erlang的systools会检查这个列表里的模块是否有命名冲突；&lt;/li&gt;
&lt;li&gt;application：必须在应用启动前先行启动的所有应用。主动应用要求自己所依赖的所有应用在自己的生命周期开始之前先行启动并就绪，这个列表中的各个应用的顺序无关紧要；&lt;/li&gt;
&lt;li&gt;mod：告知OTP系统应该如何启动应用，该参数的值是一个元组，其内容为一个模块名和一些可选的启动参数；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　还有其他很多东西，今天就先不讲了，过几天再补上。&lt;/p&gt;

&lt;h2&gt;5. 感想&lt;/h2&gt;

&lt;p&gt;　　理解这个OTP应用的关键是监督树的建立和sc_element作为模块来调用的方式。最近看了一些公司在实践erlang后又转向其他语言来实施项目的文章分享，心里确实对Erlang对前途不是很明确，但凡事都得多面对待，不能别人说不行你也说不行，不能过去说不行现在，将来也说不行。&lt;br/&gt;
　　下面附上最近了解的小米和Facebook在Erlang的实践中的一些探索，仅供参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/news/2014/11/xiaomi-1111-pushservice&quot;&gt;1. 小米推送服务从Erlang转到java&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;开发语言从Erlang 转为Java。 小米原来的消息系统是使用Erlang开发的，所以推送系统的第一版也是基于Erlang；但是Erlang的社区不够活跃，开发人员很难找，学习曲线陡，支持工具和类库少，所以后来开发团队选择了使用Java重新开发；迁移到Java后，对开发人员的要求降低，各种工具和类库较多，大大提高了开发效率。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://www.quora.com/Why-was-Erlang-chosen-for-use-in-Facebook-chat&quot;&gt;2. 介绍FB一开始选用Erlang来开发聊天服务的原因&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.quora.com/When-did-Facebook-switch-away-from-using-Erlang-for-Facebook-Chat&quot;&gt;3. 介绍FB聊天服务从Erlang转向C++的原因&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-1. 50 Tips and Tricks for MongoDB Developers</title>
     <link href="/50-tips-and-tricks-for-mongodb-developer"/>
     <updated>2014-11-09T00:00:00+08:00</updated>
     <id>/50-tips-and-tricks-for-mongodb-developer</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;　　book 开头的文章都是记录我个人的读书记录的，里面分情况会记录下面这些东西：目录，读书感想，技术分享和推荐等。如果只是写下目录，那大多是留给自己以后看的。我不会把书长篇大论地翻译成中文，只会写下能对我个人以后真正有用的东西。
　　这是一本讲mongodb实践的经验书籍，就66页，除去前面目录什么的，也就50来页，对我个人还是挺有用的，所以我写下其目录，供以后复习时用。没必要写什么读书笔记，毕竟大脑才是最好用的u盘。&lt;/p&gt;

&lt;h2&gt;目录&lt;/h2&gt;

&lt;blockquote&gt;&lt;ol&gt;
&lt;li&gt;Duplicate data for speed, reference data for integrity&lt;/li&gt;
&lt;li&gt;Normalize if you need to future-proof data&lt;/li&gt;
&lt;li&gt;Try to fetech data in a single query&lt;/li&gt;
&lt;li&gt;Embed dependent fields&lt;/li&gt;
&lt;li&gt;Embed &quot;point-in-time&quot; data&lt;/li&gt;
&lt;li&gt;Do not embed fields that have unbound growth&lt;/li&gt;
&lt;li&gt;Pre-populate anything you can&lt;/li&gt;
&lt;li&gt;Preallocate space, whenever possible&lt;/li&gt;
&lt;li&gt;Store embedded information in arrays for anonymous access&lt;/li&gt;
&lt;li&gt;Desigin documents to be self-sufficient&lt;/li&gt;
&lt;li&gt;Prefer $-operators to JavaScript&lt;/li&gt;
&lt;li&gt;Compute aggregations as you go&lt;/li&gt;
&lt;li&gt;Write code to handle data integrity issues&lt;/li&gt;
&lt;li&gt;Use the correct types&lt;/li&gt;
&lt;li&gt;Override _id when you have your own simple, unique id&lt;/li&gt;
&lt;li&gt;Avoid using a document for _id&lt;/li&gt;
&lt;li&gt;Do not use database references&lt;/li&gt;
&lt;li&gt;Don&#39;t use GridFS for small binary data&lt;/li&gt;
&lt;li&gt;Handle &quot;seamless&quot; failover&lt;/li&gt;
&lt;li&gt;Handle replica set failure and failover&lt;/li&gt;
&lt;li&gt;Minimize disk access&lt;/li&gt;
&lt;li&gt;Use indexes to do more with less memory&lt;/li&gt;
&lt;li&gt;Don&#39;t always use an index&lt;/li&gt;
&lt;li&gt;Create indexes that cover your queries&lt;/li&gt;
&lt;li&gt;Use compound indexes to make multiple queries fast&lt;/li&gt;
&lt;li&gt;Create hierarchical documents for faster scans&lt;/li&gt;
&lt;li&gt;AND-queries should match as little as possible as fast as possible&lt;/li&gt;
&lt;li&gt;OR-queries should match as much as possible as soon as possible&lt;/li&gt;
&lt;li&gt;Write to the journal for single server, replicas for multiserver&lt;/li&gt;
&lt;li&gt;Always use replication, journaling, or both&lt;/li&gt;
&lt;li&gt;Do not depend on repair to recover data&lt;/li&gt;
&lt;li&gt;Understand getlasterror&lt;/li&gt;
&lt;li&gt;Always use safe writes in development&lt;/li&gt;
&lt;li&gt;Use w with replication&lt;/li&gt;
&lt;li&gt;Always use wtimeout with w&lt;/li&gt;
&lt;li&gt;Don&#39;s use fsync on every write&lt;/li&gt;
&lt;li&gt;Start up normally after a crash&lt;/li&gt;
&lt;li&gt;Take instant-in-time backups of durable servers&lt;/li&gt;
&lt;li&gt;Manually clean up your chunks collections&lt;/li&gt;
&lt;li&gt;Compact database with repair&lt;/li&gt;
&lt;li&gt;Don&#39;t change the number of votes for members of a replic set&lt;/li&gt;
&lt;li&gt;Replica sets can be reconfigured without a master up&lt;/li&gt;
&lt;li&gt;--shardsvr and --configsvr aren&#39;t required&lt;/li&gt;
&lt;li&gt;Only use --notablescan in development&lt;/li&gt;
&lt;li&gt;Learn some JavaScript&lt;/li&gt;
&lt;li&gt;Manage all of your servers and databases from one shell&lt;/li&gt;
&lt;li&gt;Get &quot;help&quot; for any function&lt;/li&gt;
&lt;li&gt;Create startup files&lt;/li&gt;
&lt;li&gt;Add your own functions&lt;/li&gt;
&lt;li&gt;Use a single connection to read your own writes&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2&gt;推荐资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.51cto.com/zt/107&quot;&gt;中文翻译&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>解读 Erlang lists 源码</title>
     <link href="/erlang-lists-source-code"/>
     <updated>2014-10-31T00:00:00+08:00</updated>
     <id>/erlang-lists-source-code</id>
     <content type="html">&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;　　lists官方文档在此&lt;a href=&quot;http://erlang.org/doc/man/lists.html&quot;&gt;http://erlang.org/doc/man/lists.html&lt;/a&gt;，不知因为什么原因，官方文档中函数顺序和lists.erl源码里的顺序完全不一样。我是按照源码里的顺序来写的，目的是为了熟悉一下Erlang的编程风格和巩固基础语法。也不会所有函数都提到，挑下面一些来学习学习。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;1.  属性说明&lt;/strong&gt;  &lt;br/&gt;
&lt;strong&gt;2.  keyfind/3&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;3.  suffix/2&lt;/strong&gt;   &lt;br/&gt;
&lt;strong&gt;4.  seq/2, seq/3&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;5.  sort/1&lt;/strong&gt;
&lt;strong&gt;6.  merge/1&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;7.  concat/1&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;8.  flatten/1, flatten/2&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;10. filter/2, map/2, filtermap/2&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;11. foldl/3, foldr/3&lt;/strong&gt; &lt;br/&gt;
&lt;strong&gt;12. keydelete/3&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;13. keymap/3&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 属性说明&lt;/h2&gt;

&lt;p&gt;　　源文件里注明了 &lt;code&gt;-compile({no_auto_import, [max/2]}).&lt;/code&gt;，这是一个预定义的模块属性【预定义的模块属性有以下四种：&lt;code&gt;module，import，export，compile，vsn&lt;/code&gt;】。其中&lt;code&gt;-compile(Options)&lt;/code&gt;是将Options添加到编译器选项表中，Options可以是单个原子，也可以是一个列表。这里的&lt;code&gt;no_auto_import&lt;/code&gt;是说函数max/2不要自动从erlang模块里导出了，这是为了解决内置函数冲突。没听明白吧，ok，下面详细讲讲这个。至于模块属性，详见《Erlang程序设计》第二版，8.4节；有关compile选项，请移步&lt;a href=&quot;http://erlang.org/doc/man/compile.html&quot;&gt;http://erlang.org/doc/man/compile.html&lt;/a&gt;。&lt;br/&gt;
　　首先，什么叫自动导出：easy，自动导出就是你不加模块前缀就可以运行的函数。平常使用模块函数不都是模块名:函数名的吗。比如说我们要使用erlang模块里的max函数，一般都是erlang:max这样使用。so，顾名思义，如果max函数在erlang里是自动导出的，那我猜想我们可以直接在console里运行max函数了，而且注意，在console里不加模块名直接运行的max函数一定是定义在erlang这个模块里面的。猜想一下，如果含有其他模块【假定为erl】也定义了一个max函数，并且也自动导出了，那当你直接运行max函数时，erlang虚拟机是该运行erl里的max呢还是erlang里的max呢。&lt;br/&gt;
　　好的，简单测试下，直接看代码得了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop/erlcode# erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; erlang:max(1,2).
2
2&amp;gt; max(1,2).
2
3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　现在，这个问题解决了，那我们来看看，为什么在lists模块里要阻止max/2自动导入呢。just think it，就和我上面说的一样，防止自动导出的核心是什么？不就是为了防止函数冲突吗？so，我猜想我们lists.erl模块里也有一个max/2函数，而且这个max/2函数的实现必须是和erlang模块里的实现是不同的。CTRL+F查找，果然不出所料：　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%% max(L) -&amp;gt; returns the maximum element of the list L

-spec max(List) -&amp;gt; Max when
      List :: [T,...],
      Max :: T,
      T :: term().

max([H|T]) -&amp;gt; max(T, H).

max([H|T], Max) when H &amp;gt; Max -&amp;gt; max(T, H);
max([_|T], Max)              -&amp;gt; max(T, Max);
max([],    Max)              -&amp;gt; Max.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　好了，到这里关于模块预定义属性就差不多了，以后遇到了再慢慢补上。&lt;/p&gt;

&lt;h2&gt;2. keyfind/3&lt;/h2&gt;

&lt;p&gt; 　　lists里的&lt;code&gt;keyfind/3, keymember/3, keysearch/3, member/2, reverse/2&lt;/code&gt;都是通过内置函数实现的，源码都在erl_bif_types.erl这个文件里面。在keyfind/3的定义中，看到了pos_integer()这样一个变量类型，看来基础还是不行啊，没办法，大家有空都来这里补补基础吧。&lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;7 Types and Function Specifications&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3. suffix/2&lt;/h2&gt;

&lt;p&gt;　　之所以要介绍suffix，是想借suffix来简单介绍一下Erlang里的布尔表达式和所谓的短路布尔表达式。函数定义和实现如下，检查Suffix是否是List的后缀。实现就用了两行，真是精湛啊，突然发现其实很多操作不用循环也能很清楚的表达了。&lt;br/&gt;
　　这里的 andalso 叫做短路布尔表达式，其含义是指 &lt;code&gt;Expr1 andalso Expr2&lt;/code&gt; 这样一个表达式只有在Expr1为真的情况下才会执行Expr2。同样可以理解一下orelse这个短路布尔表达式。而普通的布尔表达式和其他语言里一样的，not, and, or, xor。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;%% suffix(Suffix, List) -&amp;gt; (true | false)

-spec suffix(List1, List2) -&amp;gt; boolean() when
      List1 :: [T],
      List2 :: [T],
      T :: term().

suffix(Suffix, List) -&amp;gt;
    Delta = length(List) - length(Suffix),
    Delta &amp;gt;= 0 andalso nthtail(Delta, List) =:= Suffix.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. seq/2&lt;/h2&gt;

&lt;p&gt;　　seq/2是一个高级接口，调用了一个三参数的接口&lt;code&gt;seq_loop(N, X, L)&lt;/code&gt;，如下，其中N=Last-First+1，是需要生成的长度，X=Last，是最后一个元素的值，L是一个空列表[]，将结果保存到第三个参数L中，最后再返回它。而生成这个列表的方法确实很高效，要么一次生成4个数，要么一次生成2个数，要么生成一个数或者直接返回结果。而实际应用中，大多数情况应该都是一次生成4个数，然后可能会调用1到2次一次生成2个数，最后要么直接返回结果，要么就再生成1个数后再返回结果。极为高效！我又想起了Python里相似的range函数，过两天看看Python里是怎么实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec seq(From, To) -&amp;gt; Seq when
      From :: integer(),
      To :: integer(),
      Seq :: [integer()].

seq(First, Last)
    when is_integer(First), is_integer(Last), First-1 =&amp;lt; Last -&amp;gt;
    seq_loop(Last-First+1, Last, []).

seq_loop(N, X, L) when N &amp;gt;= 4 -&amp;gt;
     seq_loop(N-4, X-4, [X-3,X-2,X-1,X|L]);
seq_loop(N, X, L) when N &amp;gt;= 2 -&amp;gt;
     seq_loop(N-2, X-2, [X-1,X|L]);
seq_loop(1, X, L) -&amp;gt;
     [X|L];
seq_loop(0, _, L) -&amp;gt;
     L.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. sort/1&lt;/h2&gt;

&lt;p&gt;　　Link:&lt;/p&gt;

&lt;h2&gt;6. merge/1&lt;/h2&gt;

&lt;p&gt;　　Link:&lt;/p&gt;

&lt;h2&gt;7. concat/1&lt;/h2&gt;

&lt;p&gt;　　concat函数本身的意图是把参数组合成一个项式，特别需要注意的是，当这个项式是可打印的时候，就打印其字符串形式的结果，当该项式是不可打印的时候，就以把它组合成一个list形式。我们先看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;root@kali:~/Desktop/erlcode/lists# erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; lists:concat([1,2,3]).
&quot;123&quot;
2&amp;gt; lists:concat([1,2,3,a,b,c]).
&quot;123abc&quot;
3&amp;gt; lists:concat([1,2,3,[a,b,c]]).
[49,50,51,a,b,c]
4&amp;gt; lists:concat([1,2,3,[1,2,3]]).
[49,50,51,1,2,3]
5&amp;gt; lists:concat([1,2,3,a,b,c,[1,2,3]]).
[49,50,51,97,98,99,1,2,3]
6&amp;gt; lists:concat([1,2,3,a,b,c,[1,2,[a,b,c],3]]).
[49,50,51,97,98,99,1,2,[a,b,c],3]
7&amp;gt; lists:concat([1,2,3,a,b,c,[1,2,[a,b,c],3],d,e,f]).
[49,50,51,97,98,99,1,2,[a,b,c],3,100,101,102]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　从例子1、2可以看出，若参数是一个无嵌套的term组成的list，则会返回由这些term组成的一个字符串；若参数是含有嵌套的list，则会把最外层term打印成其在ASCII中的下标，而嵌套的会保持原形。我想这个函数一般都会用在无嵌套的情况吧。下面是源码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%% concat(L) concatenate the list representation of the elements
%%  in L - the elements in L can be atoms, numbers of strings.
%%  Returns a list of characters.

-spec concat(Things) -&amp;gt; string() when
      Things :: [Thing],
      Thing :: atom() | integer() | float() | string().

concat(List) -&amp;gt;
    flatmap(fun thing_to_list/1, List).

thing_to_list(X) when is_integer(X) -&amp;gt; integer_to_list(X);
thing_to_list(X) when is_float(X)   -&amp;gt; float_to_list(X);
thing_to_list(X) when is_atom(X)    -&amp;gt; atom_to_list(X);
thing_to_list(X) when is_list(X)    -&amp;gt; X.       %Assumed to be a string

-spec flatmap(Fun, List1) -&amp;gt; List2 when
      Fun :: fun((A) -&amp;gt; [B]),
      List1 :: [A],
      List2 :: [B],
      A :: term(),
      B :: term().

flatmap(F, [Hd|Tail]) -&amp;gt;
    F(Hd) ++ flatmap(F, Tail);
flatmap(F, []) when is_function(F, 1) -&amp;gt; [].
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;8. flatten/1, flatten/2&lt;/h2&gt;

&lt;p&gt;　　flatten/1 和 flatten/2 都是把一个有嵌套的list返回成一个无嵌套的list的函数，其中flatten/2允许在flatten/1的结果后再append一个list，而且不管这个list的形式。其实一会儿可以在源码里看见，flatten/1和flatten/2的唯一区别是flatten/1相当于flatten/2的第二个参数是一个空list。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;-spec flatten(DeepList) -&amp;gt; List when
      DeepList :: [term() | DeepList],
      List :: [term()].

flatten(List) when is_list(List) -&amp;gt;
    do_flatten(List, []).

-spec flatten(DeepList, Tail) -&amp;gt; List when
      DeepList :: [term() | DeepList],
      Tail :: [term()],
      List :: [term()].

flatten(List, Tail) when is_list(List), is_list(Tail) -&amp;gt;
    do_flatten(List, Tail).

do_flatten([H|T], Tail) when is_list(H) -&amp;gt;
    do_flatten(H, do_flatten(T, Tail));
do_flatten([H|T], Tail) -&amp;gt;
    [H|do_flatten(T, Tail)];
do_flatten([], Tail) -&amp;gt;
    Tail.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;10. filter/2, map/2, filtermap/2&lt;/h2&gt;

&lt;p&gt;　　先看看函数参数，filter函数是对List1里的每个term都应用一次Pred函数，然后将能使Pred函数返回true的元素按序构成一个新的列表返回。map函数是对List1里对每个term都应用一次Fun函数，然后将Fun函数在每个元素上都返回值按顺序构造成返回值。顾名思义，filtermap函数就是这两个函数的结合，即先filter，再做map操作。下面是源码，有时候发现，如果看document看烦了，可以选择性地看看源码，也许比看document管用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec map(Fun, List1) -&amp;gt; List2 when
      Fun :: fun((A) -&amp;gt; B),
      List1 :: [A],
      List2 :: [B],
      A :: term(),
      B :: term().

map(F, [H|T]) -&amp;gt;
    [F(H)|map(F, T)];
map(F, []) when is_function(F, 1) -&amp;gt; [].

-spec filter(Pred, List1) -&amp;gt; List2 when
      Pred :: fun((Elem :: T) -&amp;gt; boolean()),
      List1 :: [T],
      List2 :: [T],
      T :: term().

filter(Pred, List) when is_function(Pred, 1) -&amp;gt;
    [ E || E &amp;lt;- List, Pred(E) ].   

-spec filtermap(Fun, List1) -&amp;gt; List2 when
      Fun :: fun((Elem) -&amp;gt; boolean() | {&#39;true&#39;, Value}),
      List1 :: [Elem],
      List2 :: [Elem | Value],
      Elem :: term(),
      Value :: term().

filtermap(F, [Hd|Tail]) -&amp;gt;
    case F(Hd) of
  true -&amp;gt;
      [Hd|filtermap(F, Tail)];
  {true,Val} -&amp;gt;
      [Val|filtermap(F, Tail)];
  false -&amp;gt;
      filtermap(F, Tail)
    end;
filtermap(F, []) when is_function(F, 1) -&amp;gt; [].
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;11. foldl/3, foldr/3&lt;/h2&gt;

&lt;h2&gt;12. keydelete/3&lt;/h2&gt;

&lt;h2&gt;13. keymap/3&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>深度分析 Erlang Application 行为</title>
     <link href="/deep-into-erlang-application"/>
     <updated>2014-10-21T00:00:00+08:00</updated>
     <id>/deep-into-erlang-application</id>
     <content type="html">&lt;h2&gt;1. 从我在Erlang and OTP in Action中第六章中的错误说起&lt;/h2&gt;

&lt;p&gt;　　前两天看EOIA这本书，觉得终于可以用Erlang来搞点东西玩了，于是决定按照书中流程来实践一下所谓的缓存系统。
谨慎起见，我还是半抄半写把simple_cache的源码写好了，当前目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chenshan@mac007 6-EOIA$tree
.
├── ebin
│   ├── prim_consult.beam
│   ├── sc_app.beam
│   ├── sc_element.beam
│   ├── sc_store.beam
│   ├── sc_sup.beam
│   ├── simple_cache.app
│   └── simple_cache.beam
└── src
    ├── prim_consult.beam
    ├── prim_consult.erl
    ├── sc_app.erl
    ├── sc_element.erl
    ├── sc_store.erl
    ├── sc_sup.erl
    └── simple_cache.erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;小提示：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1、要把src目录下的erl源文件编译，并把编译后的beam文件放到ebin下有一个快捷的方法，在当前目录下执行：erlc -o ebin/ src/*.erl；&lt;br/&gt;
2、上面出现的prim_consult.erl和prim_consult.beam不用管，后面会提到的，这是我阅读application源码时提取出来的；&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　然后进入ebin目录，打开erlang执行环境，用application:start(simple_cache).启动我们的缓存系统，opps，这个时候就出错了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chenshan@mac007 6-EOIA$cd ebin/
chenshan@mac007 ebin$erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; application:start(simple_cache).  
{error,
    {bad_return,
        {
        {sc_app,start,[normal,[]]},
         {&#39;EXIT&#39;,
             {undef,
                 [{sr_store,init,[],[]},
                  {sc_app,start,2,[{file,&quot;../src/sc_app.erl&quot;},{line,6}]},
                  {application_master,start_supervisor,3,
                      [{file,&quot;application_master.erl&quot;},{line,326}]},
                  {application_master,start_the_app,5,
                      [{file,&quot;application_master.erl&quot;},{line,308}]},
                  {application_master,start_it_new,7,
                      [{file,&quot;application_master.erl&quot;},{line,294}]}]}}}}}

=INFO REPORT==== 22-Oct-2014::23:47:18 ===
    application: simple_cache
    exited: {bad_return,
                {
                {sc_app,start,[normal,[]]},
                 {&#39;EXIT&#39;,
                     {undef,
                         [{sr_store,init,[],[]},
                          {sc_app,start,2,
                              [{file,&quot;../src/sc_app.erl&quot;},{line,6}]},
                          {application_master,start_supervisor,3,
                              [{file,&quot;application_master.erl&quot;},{line,326}]},
                          {application_master,start_the_app,5,
                              [{file,&quot;application_master.erl&quot;},{line,308}]},
                          {application_master,start_it_new,7,
                              [{file,&quot;application_master.erl&quot;},
                               {line,294}]}]}}}}
    type: temporary
2&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 看看application行为在启动一个otp应用的简单流程&lt;/h2&gt;

&lt;p&gt;　　首先，在erlang环境下执行code:which(application)查看application编译后的文件路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Eshell V6.1  (abort with ^G)
1&amp;gt; code:which(application).
&quot;/usr/local/lib/erlang/lib/kernel-3.0.1/ebin/application.beam&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后，找到application的源文件，熟悉OTP项目目录结构的同志应该很清楚这里应该怎么做了吧，回顾一下OTP项目目录结构：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;doc  用于存放文档。如果文档时用EDoc生成，请将overview.edoc文件放在此处，其余的文件将会自动生成；&lt;/li&gt;
&lt;li&gt;ebin  用于存放编译后的代码(.beam文件)，包含应用元数据的.app文件也应放在此处；&lt;/li&gt;
&lt;li&gt;include  用于存放公共头文件。所有作为公共API的一部分的.hrl文件都应该放在这个目录中。仅用于你自己的代码之中且不打算公开的私有.hrl文件则应该与其它源码文件一起放；&lt;/li&gt;
&lt;li&gt;priv  用于存放各种需要随应用一起发布的其他内容。定位priv目录的方法很简单：调用code:priv_dir(&lt;application-name&gt;)，便会以字符串形式得到priv目录完整路径；&lt;/li&gt;
&lt;li&gt;src  存放应用源代码；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　所以简单就能找到application的源文件了，在/usr/local/lib/erlang/lib/kernel-3.0.1/src/下面，这个目录里面还有其他源文件，安全、简单的方法是拷贝到临时目录里来看，看下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop/erl/6-EOIA/ebin# mkdir ~/Desktop/temp
root@kali:~/Desktop/erl/6-EOIA/ebin# cp /usr/local/lib/erlang/lib/kernel-3.0.1/src/application*.erl ~/Desktop/ temp/
root@kali:~/Desktop/erl/6-EOIA/ebin# ls ~/Desktop/te
temp/ test/
root@kali:~/Desktop/erl/6-EOIA/ebin# ls ~/Desktop/temp/
application_controller.erl  application.erl  application_master.erl  application_starter.erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　Ok, 一切就绪，开干了！先在application.erl里找到start这个函数，如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec start(Application) -&amp;gt; &#39;ok&#39; | {&#39;error&#39;, Reason} when
      Application :: atom(),
      Reason :: term().

start(Application) -&amp;gt;
    start(Application, temporary).

-spec start(Application, Type) -&amp;gt; &#39;ok&#39; | {&#39;error&#39;, Reason} when
      Application :: atom(),
      Type :: restart_type(),
      Reason :: term().

start(Application, RestartType) -&amp;gt;
    case load(Application) of
  ok -&amp;gt;
      Name = get_appl_name(Application),
      application_controller:start_application(Name, RestartType);
  {error, {already_loaded, Name}} -&amp;gt;
      application_controller:start_application(Name, RestartType);
  Error -&amp;gt;
      Error
    end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　可以发现，start已经是一个很高层的封装了，源代码注释里也说了，application.erl只是对application_master.erl和application_controller.erl的一个封装。这里我们是调用了start/1，即以temporary为重启方式来启动我们的simple_cache。start过程从宏观上分为两大步：load和start。其中首先load，然后start，load的结果有三种：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;ok：加入start流程；&lt;/li&gt;
&lt;li&gt;{error, {already_loaded, Name}}：失败，原因是这个应用已经load过了，可以直接加入start流程；&lt;/li&gt;
&lt;li&gt;Error：错误，且错误原因不详，需要看console里的输出分析；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　Ok, 思路清晰了，我们就split it into two seperate but sequential procedures，一步一步来，争取最后不靠调试就解决我们上面遇到的问题吧， here we go！&lt;/p&gt;

&lt;h2&gt;3. load应用的过程分析&lt;/h2&gt;

&lt;p&gt;　　根据application.erl 里第97行知道，load过程是调用application_controller.erl里的函数的，所以这里我们就先去分析application_controller.erl里的load调用了。先上一张图来简单看看load的整个过程。
&lt;img src=&quot;../../images/erlang-application-load.jpg&quot; alt=&quot;load 流程图分析&quot; /&gt;
　　上面的图可能画得稍显复杂，没办法，刚开始看源码，还是仔细一点好。仔细了解后，我发现load过程其中重点就只有下面四条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查这个应用是否已经load过；&lt;/li&gt;
&lt;li&gt;解析应用描述文件appname.app里的内容；&lt;/li&gt;
&lt;li&gt;根据应用描述文件的描述，把应用的一些原子信息存到一张本地的ets表中；&lt;/li&gt;
&lt;li&gt;给应用的PID发送一条&lt;code&gt;{ac_load_application_req, AppName}&lt;/code&gt;的消息；&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.1 load过程中容易发生错误的地方&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;do_load_application 过程, 解析应用描述文件appname.app出错，相关源码如下。make_appl是一个解析appname.app文件的封装。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;do_load_application(Application, S) -&amp;gt;
    case get_loaded(Application) of
        {true, _} -&amp;gt;
            throw({error, {already_loaded, Application}});
        false -&amp;gt;
            case make_appl(Application) of
                {ok, Appl} -&amp;gt; load(S, Appl);
                Error -&amp;gt; Error
            end
    end.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在cntrl(A, S, {ac_load_application_req, A})时发生错误，相关源码如下。但这里既是出错的话，返回的信息也是容易辨别的，即&lt;code&gt;{reply, ok, NewS}&lt;/code&gt;，和上面我的那个出错不一样。看来程序在load的过程中没有出错，好吧，那我们就来看看在start的过程中出上面错了。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;handle_call({load_application, Application}, From, S) -&amp;gt;
    case catch do_load_application(Application, S) of
        {ok, NewS} -&amp;gt;
            AppName = get_appl_name(Application),
            case cntrl(AppName, S, {ac_load_application_req, AppName}) of
                true -&amp;gt;
                    {noreply, S#state{loading = [{AppName, From} |
                                                 S#state.loading]}};
                false -&amp;gt;
                    {reply, ok, NewS}
            end;
        {error, _} = Error -&amp;gt;
            {reply, Error, S};
        {&#39;EXIT&#39;, R} -&amp;gt;
            {reply, {error, R}, S}
    end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　PS: 因为这篇博文应该是26号发布的，到现在还么有通过分析源码的方式来找bug，所以为了让本文早点面世，我提前从出错信息里找错误了。事实证明，远远没有我想象的这样复杂，关键是这句&lt;code&gt;[{file,&quot;../src/sc_app.erl&quot;},{line,6}]},&lt;/code&gt;， 我在sc_app.erl的第六行写错了一个字母，so...，不过后续我还会继续分析start过程，看看程序是怎么down的，也来看看怎么解读这个错误。&lt;/p&gt;

&lt;h2&gt;4. start应用的过程分析&lt;/h2&gt;
</content>
   </entry>
   

</feed>


</body>
</html>
