<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

   <title>Taotao's Zone</title>
   <link href="http://litaotao.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://litaotao.github.io" rel="alternate" type="text/html" />
   <updated>2014-11-07T16:22:52+08:00</updated>
   <id>http://litaotao.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>解读 Erlang lists 源码</title>
     <link href="/erlang-lists-source-code"/>
     <updated>2014-10-31T00:00:00+08:00</updated>
     <id>/erlang-lists-source-code</id>
     <content type="html">&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;　　lists官方文档在此&lt;a href=&quot;http://erlang.org/doc/man/lists.html&quot;&gt;http://erlang.org/doc/man/lists.html&lt;/a&gt;，不知因为什么原因，官方文档中函数顺序和lists.erl源码里的顺序完全不一样。我是按照源码里的顺序来写的，目的是为了熟悉一下Erlang的编程风格和巩固基础语法。也不会所有函数都提到，挑下面一些来学习学习。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;1.  属性说明&lt;/strong&gt;  &lt;br/&gt;
&lt;strong&gt;2.  keyfind/3&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;3.  suffix/2&lt;/strong&gt;   &lt;br/&gt;
&lt;strong&gt;4.  seq/2, seq/3&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;5.  sort/1&lt;/strong&gt;
&lt;strong&gt;6.  merge/1&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;7.  concat/1&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;8.  flatten/1, flatten/2&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;9.  all/2, any/2&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;10. filtermap/2&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;11. foldl/3, foldr/3&lt;/strong&gt; &lt;br/&gt;
&lt;strong&gt;12. keydelete/3&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;13. keymap/3&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 属性说明&lt;/h2&gt;

&lt;p&gt;　　源文件里注明了 &lt;code&gt;-compile({no_auto_import, [max/2]}).&lt;/code&gt;，这是一个预定义的模块属性【预定义的模块属性有以下四种：&lt;code&gt;module，import，export，compile，vsn&lt;/code&gt;】。其中&lt;code&gt;-compile(Options)&lt;/code&gt;是将Options添加到编译器选项表中，Options可以是单个原子，也可以是一个列表。这里的&lt;code&gt;no_auto_import&lt;/code&gt;是说函数max/2不要自动从erlang模块里导出了，这是为了解决内置函数冲突。没听明白吧，ok，下面详细讲讲这个。至于模块属性，详见《Erlang程序设计》第二版，8.4节；有关compile选项，请移步&lt;a href=&quot;http://erlang.org/doc/man/compile.html&quot;&gt;http://erlang.org/doc/man/compile.html&lt;/a&gt;。&lt;br/&gt;
　　首先，什么叫自动导出：easy，自动导出就是你不加模块前缀就可以运行的函数。平常使用模块函数不都是模块名:函数名的吗。比如说我们要使用erlang模块里的max函数，一般都是erlang:max这样使用。so，顾名思义，如果max函数在erlang里是自动导出的，那我猜想我们可以直接在console里运行max函数了，而且注意，在console里不加模块名直接运行的max函数一定是定义在erlang这个模块里面的。猜想一下，如果含有其他模块【假定为erl】也定义了一个max函数，并且也自动导出了，那当你直接运行max函数时，erlang虚拟机是该运行erl里的max呢还是erlang里的max呢。&lt;br/&gt;
　　好的，简单测试下，直接看代码得了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop/erlcode# erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; erlang:max(1,2).
2
2&amp;gt; max(1,2).
2
3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　现在，这个问题解决了，那我们来看看，为什么在lists模块里要阻止max/2自动导入呢。just think it，就和我上面说的一样，防止自动导出的核心是什么？不就是为了防止函数冲突吗？so，我猜想我们lists.erl模块里也有一个max/2函数，而且这个max/2函数的实现必须是和erlang模块里的实现是不同的。CTRL+F查找，果然不出所料：　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%% max(L) -&amp;gt; returns the maximum element of the list L

-spec max(List) -&amp;gt; Max when
      List :: [T,...],
      Max :: T,
      T :: term().

max([H|T]) -&amp;gt; max(T, H).

max([H|T], Max) when H &amp;gt; Max -&amp;gt; max(T, H);
max([_|T], Max)              -&amp;gt; max(T, Max);
max([],    Max)              -&amp;gt; Max.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　好了，到这里关于模块预定义属性就差不多了，以后遇到了再慢慢补上。&lt;/p&gt;

&lt;h2&gt;2. keyfind/3&lt;/h2&gt;

&lt;p&gt; 　　lists里的&lt;code&gt;keyfind/3, keymember/3, keysearch/3, member/2, reverse/2&lt;/code&gt;都是通过内置函数实现的，源码都在erl_bif_types.erl这个文件里面。在keyfind/3的定义中，看到了pos_integer()这样一个变量类型，看来基础还是不行啊，没办法，大家有空都来这里补补基础吧。&lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;7 Types and Function Specifications&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3. suffix/2&lt;/h2&gt;

&lt;p&gt;　　之所以要介绍suffix，是想借suffix来简单介绍一下Erlang里的布尔表达式和所谓的短路布尔表达式。函数定义和实现如下，检查Suffix是否是List的后缀。实现就用了两行，真是精湛啊，突然发现其实很多操作不用循环也能很清楚的表达了。&lt;br/&gt;
　　这里的 andalso 叫做短路布尔表达式，其含义是指 &lt;code&gt;Expr1 andalso Expr2&lt;/code&gt; 这样一个表达式只有在Expr1为真的情况下才会执行Expr2。同样可以理解一下orelse这个短路布尔表达式。而普通的布尔表达式和其他语言里一样的，not, and, or, xor。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;%% suffix(Suffix, List) -&amp;gt; (true | false)

-spec suffix(List1, List2) -&amp;gt; boolean() when
      List1 :: [T],
      List2 :: [T],
      T :: term().

suffix(Suffix, List) -&amp;gt;
    Delta = length(List) - length(Suffix),
    Delta &amp;gt;= 0 andalso nthtail(Delta, List) =:= Suffix.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. seq/2&lt;/h2&gt;

&lt;p&gt;　　seq/2是一个高级接口，调用了一个三参数的接口&lt;code&gt;seq_loop(N, X, L)&lt;/code&gt;，如下，其中N=Last-First+1，是需要生成的长度，X=Last，是最后一个元素的值，L是一个空列表[]，将结果保存到第三个参数L中，最后再返回它。而生成这个列表的方法确实很高效，要么一次生成4个数，要么一次生成2个数，要么生成一个数或者直接返回结果。而实际应用中，大多数情况应该都是一次生成4个数，然后可能会调用1到2次一次生成2个数，最后要么直接返回结果，要么就再生成1个数后再返回结果。极为高效！我又想起了Python里相似的range函数，过两天看看Python里是怎么实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec seq(From, To) -&amp;gt; Seq when
      From :: integer(),
      To :: integer(),
      Seq :: [integer()].

seq(First, Last)
    when is_integer(First), is_integer(Last), First-1 =&amp;lt; Last -&amp;gt;
    seq_loop(Last-First+1, Last, []).

seq_loop(N, X, L) when N &amp;gt;= 4 -&amp;gt;
     seq_loop(N-4, X-4, [X-3,X-2,X-1,X|L]);
seq_loop(N, X, L) when N &amp;gt;= 2 -&amp;gt;
     seq_loop(N-2, X-2, [X-1,X|L]);
seq_loop(1, X, L) -&amp;gt;
     [X|L];
seq_loop(0, _, L) -&amp;gt;
     L.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. sort/1&lt;/h2&gt;

&lt;p&gt;　　Link:&lt;/p&gt;

&lt;h2&gt;6. merge/1&lt;/h2&gt;

&lt;p&gt;　　Link:&lt;/p&gt;

&lt;h2&gt;7. concat/1&lt;/h2&gt;

&lt;p&gt;　　concat函数本身的意图是把参数组合成一个项式，特别需要注意的是，当这个项式是可打印的时候，就打印其字符串形式的结果，当该项式是不可打印的时候，就以把它组合成一个list形式。我们先看下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;root@kali:~/Desktop/erlcode/lists# erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; lists:concat([1,2,3]).
&quot;123&quot;
2&amp;gt; lists:concat([1,2,3,a,b,c]).
&quot;123abc&quot;
3&amp;gt; lists:concat([1,2,3,[a,b,c]]).
[49,50,51,a,b,c]
4&amp;gt; lists:concat([1,2,3,[1,2,3]]).
[49,50,51,1,2,3]
5&amp;gt; lists:concat([1,2,3,a,b,c,[1,2,3]]).
[49,50,51,97,98,99,1,2,3]
6&amp;gt; lists:concat([1,2,3,a,b,c,[1,2,[a,b,c],3]]).
[49,50,51,97,98,99,1,2,[a,b,c],3]
7&amp;gt; lists:concat([1,2,3,a,b,c,[1,2,[a,b,c],3],d,e,f]).
[49,50,51,97,98,99,1,2,[a,b,c],3,100,101,102]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　从例子1、2可以看出，若参数是一个无嵌套的term组成的list，则会返回由这些term组成的一个字符串；若参数是含有嵌套的list，则会把最外层term打印成其在ASCII中的下标，而嵌套的会保持原形。我想这个函数一般都会用在无嵌套的情况吧。下面是源码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%% concat(L) concatenate the list representation of the elements
%%  in L - the elements in L can be atoms, numbers of strings.
%%  Returns a list of characters.

-spec concat(Things) -&amp;gt; string() when
      Things :: [Thing],
      Thing :: atom() | integer() | float() | string().

concat(List) -&amp;gt;
    flatmap(fun thing_to_list/1, List).

thing_to_list(X) when is_integer(X) -&amp;gt; integer_to_list(X);
thing_to_list(X) when is_float(X)   -&amp;gt; float_to_list(X);
thing_to_list(X) when is_atom(X)    -&amp;gt; atom_to_list(X);
thing_to_list(X) when is_list(X)    -&amp;gt; X.       %Assumed to be a string

-spec flatmap(Fun, List1) -&amp;gt; List2 when
      Fun :: fun((A) -&amp;gt; [B]),
      List1 :: [A],
      List2 :: [B],
      A :: term(),
      B :: term().

flatmap(F, [Hd|Tail]) -&amp;gt;
    F(Hd) ++ flatmap(F, Tail);
flatmap(F, []) when is_function(F, 1) -&amp;gt; [].
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;8. flatten/1, flatten/2&lt;/h2&gt;

&lt;p&gt;　　flatten/1 和 flatten/2 都是把一个有嵌套的list返回成一个无嵌套的list的函数，其中flatten/2允许在flatten/1的结果后再append一个list，而且不管这个list的形式。其实一会儿可以在源码里看见，flatten/1和flatten/2的唯一区别是flatten/1相当于flatten/2的第二个参数是一个空list。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;-spec flatten(DeepList) -&amp;gt; List when
      DeepList :: [term() | DeepList],
      List :: [term()].

flatten(List) when is_list(List) -&amp;gt;
    do_flatten(List, []).

-spec flatten(DeepList, Tail) -&amp;gt; List when
      DeepList :: [term() | DeepList],
      Tail :: [term()],
      List :: [term()].

flatten(List, Tail) when is_list(List), is_list(Tail) -&amp;gt;
    do_flatten(List, Tail).

do_flatten([H|T], Tail) when is_list(H) -&amp;gt;
    do_flatten(H, do_flatten(T, Tail));
do_flatten([H|T], Tail) -&amp;gt;
    [H|do_flatten(T, Tail)];
do_flatten([], Tail) -&amp;gt;
    Tail.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;9. all/2, any/2&lt;/h2&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2&gt;10. filtermap/2&lt;/h2&gt;

&lt;h2&gt;11. foldl/3, foldr/3&lt;/h2&gt;

&lt;h2&gt;12. keydelete/3&lt;/h2&gt;

&lt;h2&gt;13. keymap/3&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>深度分析 Erlang Application 行为</title>
     <link href="/deep-into-erlang-application"/>
     <updated>2014-10-21T00:00:00+08:00</updated>
     <id>/deep-into-erlang-application</id>
     <content type="html">&lt;h2&gt;1. 从我在Erlang and OTP in Action中第六章中的错误说起&lt;/h2&gt;

&lt;p&gt;　　前两天看EOIA这本书，觉得终于可以用Erlang来搞点东西玩了，于是决定按照书中流程来实践一下所谓的缓存系统。
谨慎起见，我还是半抄半写把simple_cache的源码写好了，当前目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chenshan@mac007 6-EOIA$tree
.
├── ebin
│   ├── prim_consult.beam
│   ├── sc_app.beam
│   ├── sc_element.beam
│   ├── sc_store.beam
│   ├── sc_sup.beam
│   ├── simple_cache.app
│   └── simple_cache.beam
└── src
    ├── prim_consult.beam
    ├── prim_consult.erl
    ├── sc_app.erl
    ├── sc_element.erl
    ├── sc_store.erl
    ├── sc_sup.erl
    └── simple_cache.erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;小提示：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1、要把src目录下的erl源文件编译，并把编译后的beam文件放到ebin下有一个快捷的方法，在当前目录下执行：erlc -o ebin/ src/*.erl；&lt;br/&gt;
2、上面出现的prim_consult.erl和prim_consult.beam不用管，后面会提到的，这是我阅读application源码时提取出来的；&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　然后进入ebin目录，打开erlang执行环境，用application:start(simple_cache).启动我们的缓存系统，opps，这个时候就出错了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chenshan@mac007 6-EOIA$cd ebin/
chenshan@mac007 ebin$erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; application:start(simple_cache).  
{error,
    {bad_return,
        {
        {sc_app,start,[normal,[]]},
         {&#39;EXIT&#39;,
             {undef,
                 [{sr_store,init,[],[]},
                  {sc_app,start,2,[{file,&quot;../src/sc_app.erl&quot;},{line,6}]},
                  {application_master,start_supervisor,3,
                      [{file,&quot;application_master.erl&quot;},{line,326}]},
                  {application_master,start_the_app,5,
                      [{file,&quot;application_master.erl&quot;},{line,308}]},
                  {application_master,start_it_new,7,
                      [{file,&quot;application_master.erl&quot;},{line,294}]}]}}}}}

=INFO REPORT==== 22-Oct-2014::23:47:18 ===
    application: simple_cache
    exited: {bad_return,
                {
                {sc_app,start,[normal,[]]},
                 {&#39;EXIT&#39;,
                     {undef,
                         [{sr_store,init,[],[]},
                          {sc_app,start,2,
                              [{file,&quot;../src/sc_app.erl&quot;},{line,6}]},
                          {application_master,start_supervisor,3,
                              [{file,&quot;application_master.erl&quot;},{line,326}]},
                          {application_master,start_the_app,5,
                              [{file,&quot;application_master.erl&quot;},{line,308}]},
                          {application_master,start_it_new,7,
                              [{file,&quot;application_master.erl&quot;},
                               {line,294}]}]}}}}
    type: temporary
2&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 看看application行为在启动一个otp应用的简单流程&lt;/h2&gt;

&lt;p&gt;　　首先，在erlang环境下执行code:which(application)查看application编译后的文件路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Eshell V6.1  (abort with ^G)
1&amp;gt; code:which(application).
&quot;/usr/local/lib/erlang/lib/kernel-3.0.1/ebin/application.beam&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后，找到application的源文件，熟悉OTP项目目录结构的同志应该很清楚这里应该怎么做了吧，回顾一下OTP项目目录结构：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;doc  存放文档；&lt;/li&gt;
&lt;li&gt;ebin  存放编译后的代码以及应用包含应用原子数据的app文件；&lt;/li&gt;
&lt;li&gt;include  存放公共头文件；&lt;/li&gt;
&lt;li&gt;priv  存放各种需要随应用一起发布的其他内容，如模板文件，共享文件对象以及DLL等；&lt;/li&gt;
&lt;li&gt;src  存放应用源代码；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　所以简单就能找到application的源文件了，在/usr/local/lib/erlang/lib/kernel-3.0.1/src/下面，这个目录里面还有其他源文件，安全、简单的方法是拷贝到临时目录里来看，看下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop/erl/6-EOIA/ebin# mkdir ~/Desktop/temp
root@kali:~/Desktop/erl/6-EOIA/ebin# cp /usr/local/lib/erlang/lib/kernel-3.0.1/src/application*.erl ~/Desktop/ temp/
root@kali:~/Desktop/erl/6-EOIA/ebin# ls ~/Desktop/te
temp/ test/
root@kali:~/Desktop/erl/6-EOIA/ebin# ls ~/Desktop/temp/
application_controller.erl  application.erl  application_master.erl  application_starter.erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　Ok, 一切就绪，开干了！先在application.erl里找到start这个函数，如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec start(Application) -&amp;gt; &#39;ok&#39; | {&#39;error&#39;, Reason} when
      Application :: atom(),
      Reason :: term().

start(Application) -&amp;gt;
    start(Application, temporary).

-spec start(Application, Type) -&amp;gt; &#39;ok&#39; | {&#39;error&#39;, Reason} when
      Application :: atom(),
      Type :: restart_type(),
      Reason :: term().

start(Application, RestartType) -&amp;gt;
    case load(Application) of
  ok -&amp;gt;
      Name = get_appl_name(Application),
      application_controller:start_application(Name, RestartType);
  {error, {already_loaded, Name}} -&amp;gt;
      application_controller:start_application(Name, RestartType);
  Error -&amp;gt;
      Error
    end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　可以发现，start已经是一个很高层的封装了，源代码注释里也说了，application.erl只是对application_master.erl和application_controller.erl的一个封装。这里我们是调用了start/1，即以temporary为重启方式来启动我们的simple_cache。start过程从宏观上分为两大步：load和start。其中首先load，然后start，load的结果有三种：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;ok：加入start流程；&lt;/li&gt;
&lt;li&gt;{error, {already_loaded, Name}}：失败，原因是这个应用已经load过了，可以直接加入start流程；&lt;/li&gt;
&lt;li&gt;Error：错误，且错误原因不详，需要看console里的输出分析；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　Ok, 思路清晰了，我们就split it into two seperate but sequential procedures，一步一步来，争取最后不靠调试就解决我们上面遇到的问题吧， here we go！&lt;/p&gt;

&lt;h2&gt;3. load应用的过程分析&lt;/h2&gt;

&lt;p&gt;　　根据application.erl 里第97行知道，load过程是调用application_controller.erl里的函数的，所以这里我们就先去分析application_controller.erl里的load调用了。先上一张图来简单看看load的整个过程。
&lt;img src=&quot;../../images/erlang-application-load.jpg&quot; alt=&quot;load 流程图分析&quot; /&gt;
　　上面的图可能画得稍显复杂，没办法，刚开始看源码，还是仔细一点好。仔细了解后，我发现load过程其中重点就只有下面四条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查这个应用是否已经load过；&lt;/li&gt;
&lt;li&gt;解析应用描述文件appname.app里的内容；&lt;/li&gt;
&lt;li&gt;根据应用描述文件的描述，把应用的一些原子信息存到一张本地的ets表中；&lt;/li&gt;
&lt;li&gt;给应用的PID发送一条&lt;code&gt;{ac_load_application_req, AppName}&lt;/code&gt;的消息；&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.1 load过程中容易发生错误的地方&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;do_load_application 过程, 解析应用描述文件appname.app出错，相关源码如下。make_appl是一个解析appname.app文件的封装。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;do_load_application(Application, S) -&amp;gt;
    case get_loaded(Application) of
        {true, _} -&amp;gt;
            throw({error, {already_loaded, Application}});
        false -&amp;gt;
            case make_appl(Application) of
                {ok, Appl} -&amp;gt; load(S, Appl);
                Error -&amp;gt; Error
            end
    end.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在cntrl(A, S, {ac_load_application_req, A})时发生错误，相关源码如下。但这里既是出错的话，返回的信息也是容易辨别的，即&lt;code&gt;{reply, ok, NewS}&lt;/code&gt;，和上面我的那个出错不一样。看来程序在load的过程中没有出错，好吧，那我们就来看看在start的过程中出上面错了。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;handle_call({load_application, Application}, From, S) -&amp;gt;
    case catch do_load_application(Application, S) of
        {ok, NewS} -&amp;gt;
            AppName = get_appl_name(Application),
            case cntrl(AppName, S, {ac_load_application_req, AppName}) of
                true -&amp;gt;
                    {noreply, S#state{loading = [{AppName, From} |
                                                 S#state.loading]}};
                false -&amp;gt;
                    {reply, ok, NewS}
            end;
        {error, _} = Error -&amp;gt;
            {reply, Error, S};
        {&#39;EXIT&#39;, R} -&amp;gt;
            {reply, {error, R}, S}
    end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　PS: 因为这篇博文应该是26号发布的，到现在还么有通过分析源码的方式来找bug，所以为了让本文早点面世，我提前从出错信息里找错误了。事实证明，远远没有我想象的这样复杂，关键是这句&lt;code&gt;[{file,&quot;../src/sc_app.erl&quot;},{line,6}]},&lt;/code&gt;， 我在sc_app.erl的第六行写错了一个字母，so...，不过后续我还会继续分析start过程，看看程序是怎么down的，也来看看怎么解读这个错误。&lt;/p&gt;

&lt;h2&gt;4. start应用的过程分析&lt;/h2&gt;
</content>
   </entry>
   

</feed>
