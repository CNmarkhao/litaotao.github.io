<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

   <title>Taotao's Zone</title>
   <link href="http://litaotao.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://litaotao.github.io" rel="alternate" type="text/html" />
   <updated>2014-11-01T19:12:55+08:00</updated>
   <id>http://litaotao.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>我的后台 API 设计经验</title>
     <link href="/backend-API-design"/>
     <updated>2014-11-01T00:00:00+08:00</updated>
     <id>/backend-API-design</id>
     <content type="html">&lt;h2&gt;1. 从一次活动说起&lt;/h2&gt;

&lt;h2&gt;2. Restful API&lt;/h2&gt;

&lt;h2&gt;3. 学习一些web攻击的手段和防御方法&lt;/h2&gt;

&lt;h3&gt;3.1 DDOS&lt;/h3&gt;

&lt;h3&gt;3.2 XSS&lt;/h3&gt;

&lt;h3&gt;3.3 SQL注入&lt;/h3&gt;

&lt;h2&gt;4. 我的个人总结&lt;/h2&gt;

&lt;h2&gt;5. 一些参考资源&lt;/h2&gt;

&lt;blockquote&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/column/details/mobilebackend.html&quot;&gt;app后端技术架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;以下是我搜集的在INFOQ上有关restful的好资料&lt;br/&gt;
　　2.1 &lt;a href=&quot;http://www.infoq.com/cn/minibooks/restful-web-services-cookbook-cn&quot;&gt;RESTful Web Services Cookbook中文版&lt;/a&gt;
　　　　&lt;a href=&quot;&quot;&gt;本书在我的github上的地址&lt;/a&gt;
　　　　&lt;a href=&quot;&quot;&gt;我的读书笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/4787.html&quot;&gt;HTTP幂等性概念和应用&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</content>
   </entry>
   
   <entry>
     <title>Architectural Styles and the Design of Network-based Software Architectures</title>
     <link href="/restful-api-design"/>
     <updated>2014-10-30T00:00:00+08:00</updated>
     <id>/restful-api-design</id>
     <content type="html">
</content>
   </entry>
   
   <entry>
     <title>Python 错误家园</title>
     <link href="/python-error-zone"/>
     <updated>2014-10-30T00:00:00+08:00</updated>
     <id>/python-error-zone</id>
     <content type="html">
</content>
   </entry>
   
   <entry>
     <title>深度分析 Erlang Application 行为</title>
     <link href="/deep-into-erlang-application"/>
     <updated>2014-10-21T00:00:00+08:00</updated>
     <id>/deep-into-erlang-application</id>
     <content type="html">&lt;h2&gt;1. 从我在Erlang and OTP in Action中第六章中的错误说起&lt;/h2&gt;

&lt;p&gt;　　前两天看EOIA这本书，觉得终于可以用Erlang来搞点东西玩了，于是决定按照书中流程来实践一下所谓的缓存系统。
谨慎起见，我还是半抄半写把simple_cache的源码写好了，当前目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chenshan@mac007 6-EOIA$tree
.
├── ebin
│   ├── prim_consult.beam
│   ├── sc_app.beam
│   ├── sc_element.beam
│   ├── sc_store.beam
│   ├── sc_sup.beam
│   ├── simple_cache.app
│   └── simple_cache.beam
└── src
    ├── prim_consult.beam
    ├── prim_consult.erl
    ├── sc_app.erl
    ├── sc_element.erl
    ├── sc_store.erl
    ├── sc_sup.erl
    └── simple_cache.erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;小提示：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1、要把src目录下的erl源文件编译，并把编译后的beam文件放到ebin下有一个快捷的方法，在当前目录下执行：erlc -o ebin/ src/*.erl；&lt;br/&gt;
2、上面出现的prim_consult.erl和prim_consult.beam不用管，后面会提到的，这是我阅读application源码时提取出来的；&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　然后进入ebin目录，打开erlang执行环境，用application:start(simple_cache).启动我们的缓存系统，opps，这个时候就出错了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chenshan@mac007 6-EOIA$cd ebin/
chenshan@mac007 ebin$erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; application:start(simple_cache).  
{error,
    {bad_return,
        {
        {sc_app,start,[normal,[]]},
         {&#39;EXIT&#39;,
             {undef,
                 [{sr_store,init,[],[]},
                  {sc_app,start,2,[{file,&quot;../src/sc_app.erl&quot;},{line,6}]},
                  {application_master,start_supervisor,3,
                      [{file,&quot;application_master.erl&quot;},{line,326}]},
                  {application_master,start_the_app,5,
                      [{file,&quot;application_master.erl&quot;},{line,308}]},
                  {application_master,start_it_new,7,
                      [{file,&quot;application_master.erl&quot;},{line,294}]}]}}}}}

=INFO REPORT==== 22-Oct-2014::23:47:18 ===
    application: simple_cache
    exited: {bad_return,
                {
                {sc_app,start,[normal,[]]},
                 {&#39;EXIT&#39;,
                     {undef,
                         [{sr_store,init,[],[]},
                          {sc_app,start,2,
                              [{file,&quot;../src/sc_app.erl&quot;},{line,6}]},
                          {application_master,start_supervisor,3,
                              [{file,&quot;application_master.erl&quot;},{line,326}]},
                          {application_master,start_the_app,5,
                              [{file,&quot;application_master.erl&quot;},{line,308}]},
                          {application_master,start_it_new,7,
                              [{file,&quot;application_master.erl&quot;},
                               {line,294}]}]}}}}
    type: temporary
2&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 看看application行为在启动一个otp应用的简单流程&lt;/h2&gt;

&lt;p&gt;　　首先，在erlang环境下执行code:which(application)查看application编译后的文件路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Eshell V6.1  (abort with ^G)
1&amp;gt; code:which(application).
&quot;/usr/local/lib/erlang/lib/kernel-3.0.1/ebin/application.beam&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后，找到application的源文件，熟悉OTP项目目录结构的同志应该很清楚这里应该怎么做了吧，回顾一下OTP项目目录结构：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;doc  存放文档；&lt;/li&gt;
&lt;li&gt;ebin  存放编译后的代码以及应用包含应用原子数据的app文件；&lt;/li&gt;
&lt;li&gt;include  存放公共头文件；&lt;/li&gt;
&lt;li&gt;priv  存放各种需要随应用一起发布的其他内容，如模板文件，共享文件对象以及DLL等；&lt;/li&gt;
&lt;li&gt;src  存放应用源代码；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　所以简单就能找到application的源文件了，在/usr/local/lib/erlang/lib/kernel-3.0.1/src/下面，这个目录里面还有其他源文件，安全、简单的方法是拷贝到临时目录里来看，看下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop/erl/6-EOIA/ebin# mkdir ~/Desktop/temp
root@kali:~/Desktop/erl/6-EOIA/ebin# cp /usr/local/lib/erlang/lib/kernel-3.0.1/src/application*.erl ~/Desktop/ temp/
root@kali:~/Desktop/erl/6-EOIA/ebin# ls ~/Desktop/te
temp/ test/
root@kali:~/Desktop/erl/6-EOIA/ebin# ls ~/Desktop/temp/
application_controller.erl  application.erl  application_master.erl  application_starter.erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　Ok, 一切就绪，开干了！先在application.erl里找到start这个函数，如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec start(Application) -&amp;gt; &#39;ok&#39; | {&#39;error&#39;, Reason} when
      Application :: atom(),
      Reason :: term().

start(Application) -&amp;gt;
    start(Application, temporary).

-spec start(Application, Type) -&amp;gt; &#39;ok&#39; | {&#39;error&#39;, Reason} when
      Application :: atom(),
      Type :: restart_type(),
      Reason :: term().

start(Application, RestartType) -&amp;gt;
    case load(Application) of
  ok -&amp;gt;
      Name = get_appl_name(Application),
      application_controller:start_application(Name, RestartType);
  {error, {already_loaded, Name}} -&amp;gt;
      application_controller:start_application(Name, RestartType);
  Error -&amp;gt;
      Error
    end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　可以发现，start已经是一个很高层的封装了，源代码注释里也说了，application.erl只是对application_master.erl和application_controller.erl的一个封装。这里我们是调用了start/1，即以temporary为重启方式来启动我们的simple_cache。start过程从宏观上分为两大步：load和start。其中首先load，然后start，load的结果有三种：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;ok：加入start流程；&lt;/li&gt;
&lt;li&gt;{error, {already_loaded, Name}}：失败，原因是这个应用已经load过了，可以直接加入start流程；&lt;/li&gt;
&lt;li&gt;Error：错误，且错误原因不详，需要看console里的输出分析；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　Ok, 思路清晰了，我们就split it into two seperate but sequential procedures，一步一步来，争取最后不靠调试就解决我们上面遇到的问题吧， here we go！&lt;/p&gt;

&lt;h2&gt;3. load应用的过程分析&lt;/h2&gt;

&lt;p&gt;　　根据application.erl 里第97行知道，load过程是调用application_controller.erl里的函数的，所以这里我们就先去分析application_controller.erl里的load调用了。先上一张图来简单看看load的整个过程。
&lt;img src=&quot;../../images/erlang-application-load.jpg&quot; alt=&quot;load 流程图分析&quot; /&gt;
　　上面的图可能画得稍显复杂，没办法，刚开始看源码，还是仔细一点好。仔细了解后，我发现load过程其中重点就只有下面四条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查这个应用是否已经load过；&lt;/li&gt;
&lt;li&gt;解析应用描述文件appname.app里的内容；&lt;/li&gt;
&lt;li&gt;根据应用描述文件的描述，把应用的一些原子信息存到一张本地的ets表中；&lt;/li&gt;
&lt;li&gt;给应用的PID发送一条&lt;code&gt;{ac_load_application_req, AppName}&lt;/code&gt;的消息；&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.1 load过程中容易发生错误的地方&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;do_load_application 过程, 解析应用描述文件appname.app出错，相关源码如下。make_appl是一个解析appname.app文件的封装。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;do_load_application(Application, S) -&amp;gt;
    case get_loaded(Application) of
        {true, _} -&amp;gt;
            throw({error, {already_loaded, Application}});
        false -&amp;gt;
            case make_appl(Application) of
                {ok, Appl} -&amp;gt; load(S, Appl);
                Error -&amp;gt; Error
            end
    end.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在cntrl(A, S, {ac_load_application_req, A})时发生错误，相关源码如下。但这里既是出错的话，返回的信息也是容易辨别的，即&lt;code&gt;{reply, ok, NewS}&lt;/code&gt;，和上面我的那个出错不一样。看来程序在load的过程中没有出错，好吧，那我们就来看看在start的过程中出上面错了。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;handle_call({load_application, Application}, From, S) -&amp;gt;
    case catch do_load_application(Application, S) of
        {ok, NewS} -&amp;gt;
            AppName = get_appl_name(Application),
            case cntrl(AppName, S, {ac_load_application_req, AppName}) of
                true -&amp;gt;
                    {noreply, S#state{loading = [{AppName, From} |
                                                 S#state.loading]}};
                false -&amp;gt;
                    {reply, ok, NewS}
            end;
        {error, _} = Error -&amp;gt;
            {reply, Error, S};
        {&#39;EXIT&#39;, R} -&amp;gt;
            {reply, {error, R}, S}
    end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　PS: 因为这篇博文应该是26号发布的，到现在还么有通过分析源码的方式来找bug，所以为了让本文早点面世，我提前从出错信息里找错误了。事实证明，远远没有我想象的这样复杂，关键是这句&lt;code&gt;[{file,&quot;../src/sc_app.erl&quot;},{line,6}]},&lt;/code&gt;， 我在sc_app.erl的第六行写错了一个字母，so...，不过后续我还会继续分析start过程，看看程序是怎么down的，也来看看怎么解读这个错误。&lt;/p&gt;

&lt;h2&gt;4. start应用的过程分析&lt;/h2&gt;
</content>
   </entry>
   

</feed>
