<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Taotao's Zone</title>
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css" type="text/css" />
  <link rel="stylesheet" href="/css/default.css" type="text/css" />
  <link rel="stylesheet" href="/css/desktop.css" type="text/css" />
  <link rel="stylesheet" href="/css/mobile.css" type="text/css" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
  <script src="/js/jquery-1.11.0.min.js" type="text/javascript"></script>
  <script src="/js/jquery-migrate-1.2.1.js" type="text/javascript"></script>
  <script src="/js/jquery.transit.min.js" type="text/javascript"></script>
  <script src="/js/common.js" type="text/javascript"></script>
</head>
<body>
  <?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

   <title>Taotao's Zone</title>
   <link href="http://litaotao.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://litaotao.github.io" rel="alternate" type="text/html" />
   <updated>2015-08-24T00:10:52+08:00</updated>
   <id>http://litaotao.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>如何处理用户手机注册时收不到验证码的问题</title>
     <link href="/verified-code-register-failed"/>
     <updated>2015-07-16T00:00:00+08:00</updated>
     <id>/verified-code-register-failed</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;　　本文提到的所有案例【实际上就两个案例】，都是自己亲身经历过的，但为了安全友好起见，文中出现的一些数字都是假设的，如果有截图，都会把一些不便透露的信息隐藏的，我想只要能说明问题就行了。&lt;/p&gt;

&lt;h2&gt;2. 一次新增用户骤减的经历&lt;/h2&gt;

&lt;p&gt;　　那是之前做的一个项目【假设名字叫 Girl】，这个项目对外简单来说有两个访问等级【匿名和登陆】，然后如果需要登陆的话，需要经过一个统一的用户管理系统【假设名字叫 Boy】，boy ，girl 和 第三者【也就是用户 users】之间的关系可以用下面这张图一探一二。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/girl-boy-and-user.jpg&quot; alt=&quot;girl-boy-and-user.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　然后我们定义一下新增用户，所谓新增用户，就是：那些对这个 girl 因为 permission limited 而不满的人，他们愿意通过 boy 注册或登陆之后，全方位地拥有 girl。&lt;/p&gt;

&lt;p&gt;　　事件发生的时间我们假设在 1月1号 - 1月12号 这段时间，在1月9号之前的一段时间，我们发现 girl 项目每天的新增用户都稳定在 100 - 150 之间，然后1月10号，11号是周末，大家12号周一来上班，第一时间当然是看这个周末又新增了多少用户了，我勒个去，一看，才新增了20个不到，oh ~~ my ~~~ go~~~~d, what happened ?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/oh-my-god.gif&quot; alt=&quot;oh-my-god.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　好吧，蛋定后，我们就开始找原因了，新增用户数据不可能一下子就跳崖了啊~&lt;/p&gt;

&lt;p&gt;“此处省略各种场景~~~”&lt;/p&gt;

&lt;p&gt;　　最后原因定位了，是boy出问题了，关键时候掉链了。因为用户来注册的时候，很多都是通过手机注册的，手机注册需要输入那蛋疼的验证码，然后问题就出来了，11号，12号两天验证码发送出现了问题，选择用手机注册的新用户没法收到验证码，自然也就没法 wholly own that girl 了。当然最后修正好这个问题后，每日新增用户又稳定在 100 - 150 了。&lt;/p&gt;

&lt;h2&gt;3. 最近的一次经历&lt;/h2&gt;

&lt;p&gt;　　前几天一个师兄和我联系，他们做了一个创业公司。既然是师兄，当然要支持了，于是我就准备注册一下，但是同样的问题也发生了，同样也是收不到验证码，而且他们目前只支持手机注册，出现这个问题，比上面那个例子更严重，因为在问题解决之前，都不会有一个新增用户了。而且，聊下来，似乎都是我第一个发现这个问题的，不知道是不是他们后台没有做新增用户这块儿的监控。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/register-photo-2.jpg.jpg&quot; alt=&quot;register-photo-2.jpg.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;4. 同一个坑，为毛还要掉两次&lt;/h2&gt;

&lt;p&gt;　　就在这周，第一个例子中的那个问题再次出现了。还是同样项目，还是同样的人员，还是同样的问题。&lt;/p&gt;

&lt;p&gt;　　看到这个问题，我的第一反应是，怎么之前出现过的问题现在依然还在。为什么同一个坑，还要掉进去两次呢？我们就先不深究到底是不是用户那边出问题了。我的态度是：即使产品这边发送手机验证码的module是work的，而是用户手机端本身有问题，收不到短信验证码，那我们也要尝试替用户解决这个问题。下面我将分析一下，就算接触不了用户的手机，怎么最大限度地替用户解决问题。【 其实图片中已经说到了我的解决方案，但是为了说得更清晰，我在下面一节仔细讲讲】&lt;/p&gt;

&lt;h2&gt;5. 怎么避免掉进同一个坑&lt;/h2&gt;

&lt;p&gt;　　事实上，上面关于 girl 和 boy 项目的那张图有一个重要的遗漏，更完整的应该是下面这样子的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/girl-boy-and-user-1.jpg&quot; alt=&quot;girl-boy-and-user-1.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　我想这下子有经验的人应该一眼就能看出来，这个结构有一个很大的、并且也是很常见的问题了，就是传说中的单点故障。因为后面的很多菇凉【就是代号如 girl 的那些产品】，要想全部拥有它们，所有用户就都得先通过 boy 的这门关卡。如果说，哪天 boy 不高兴了，或者和 boy 相关的下游模块抽风了，那所有用户就都只能干瞪眼了。&lt;/p&gt;

&lt;p&gt;　　怎么避免掉进同一个坑，这个问题很宽泛了，都是要具体场景，具体需求实际分析了。今天我想记录一下，我对手机注册这个坑的一个解决办法。我先把案例一中的注册页面贴到下面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/register-photos-1.jpg&quot; alt=&quot;register-photos-1.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　首先，注册的时候要提供至少两种注册方式：手机和邮箱，现在很多网站除了这两种方式，还有微信、qq登陆这种方式。比如说，上面提到的师兄的创业项目，在注册时只支持手机注册，他们在这个方面第一要改进的就应该是提供第二种注册方法。这是简单的第一步粒度很粗的解决方案。&lt;/p&gt;

&lt;p&gt;　　两种注册方式真的就没有问题了吗？现在我们来看看案例一中的注册界面，如果这个时候，什么信息都填完整了，就等验证码的时候出问题了，那怎么办？首先，这个网站确实提供了邮箱注册方式，但尼玛这“邮箱注册”四个字也太小了吧，而且在图片里看起来还算容易找到，但是在整个网页里看，因为干扰元素太多，“邮箱注册”这四个字得花个吃奶的劲儿才能找到啊。也不知道是哪门子的交互设计砖家这样设计的，好了，言归正传。如果用户收不到手机验证码，那能有幸发现 “邮箱注册” 这四个小字的用户就很幸运了，可以转为邮箱注册。更值得幸运的是，这个网站，无论是手机注册还是邮箱注册，需要用户填写的信息都很少，即使手机注册失败，转到邮箱注册时，也不会再次花费用户的时间。&lt;/p&gt;

&lt;p&gt;　　但是，很多情况下，用户注册时需要填写不少的信息，什么生日，性别，地址，验证问题等等，如果用户花了极大的耐心终于填完这些信息，然后突然发现尼玛验证码收不到了，而转为邮箱注册的话这些信息又得重新再写，这给用户留下的心理阴影，那得多大啊，反正我已经受伤很多次了。所以，即使在提供两种注册方式的情况下，在很多时候，还是会有细节上、体验上的问题。&lt;/p&gt;

&lt;p&gt;　　Details make perfect。有了两种注册方式，再把细节处理好，我觉得那就足够好了。假设说，用户是以手机注册的，这个时候填完了很多附加信息，突然发现验证码收不到，有两种非常 nice 的解决方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提示，一定要提示用户可以转为邮箱注册，并且告诉用户，即使转为邮箱注册，之前填过的信息都不会丢失；&lt;/li&gt;
&lt;li&gt;因为手机验证码都有一个时间限制，大多都是30-60秒，那前端完全可以监控，看倒计时完成之前，用户是否有在验证码输入框中输入数据，如果说，一个验证码的有效时间是60秒，但直到50秒时用户还没有在验证码输入框中输入数据，那么前端就可以提示用户，也许手机验证码会延迟很久【一定要用“延迟”，把责任推到运营商】，然后弹出一个邮箱输入框，告知用户，可以输入邮箱，通过邮箱来接收验证码即可。&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>我常用的 sublime 快捷键</title>
     <link href="/sublime-key-shortcut"/>
     <updated>2015-06-26T00:00:00+08:00</updated>
     <id>/sublime-key-shortcut</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;　　之所以要整理一下我常用的 sublime 快捷键，是源于一个 blog &lt;a href=&quot;http://tech.glowing.com/cn/advices-to-junior-developers/&quot;&gt;如何提升你的能力？给年轻程序员的几条建议&lt;/a&gt;。这个作者 &lt;a href=&quot;https://github.com/yejianye&quot;&gt;Ryan&lt;/a&gt; 是我的新boss，在当时第一次面试结束的时候，我问了他一个问题，像我这样子刚工作不久，基础不好的新人，应该怎么来提升自己。当时他简单的说了一下，内容和博文里面的差不多，没想到不到一个星期在公司的微信公众号上就出现了这样一篇文章。虽然不确定是不是因为我的那个问题而写的，但确实很感动。我想，在个人成长的过程中，如果有人能拉一把，那感觉就跟买股票时，有人突然给了一个内幕消息似的。无论如何，都要谢谢 Ryan，也要感谢他的这篇文章。&lt;/p&gt;

&lt;p&gt;　　我用sublime很久了，一些快捷用法也挺熟悉，不过似乎还没怎么整理过。估计以后都要和sublime同甘共苦了，还是很有必要好好总结一下的，所以就有了这篇博客。&lt;/p&gt;

&lt;p&gt;　　需要注意的是，sublime的快捷键在 OSX 下和 Windows 下是不一样的，这里我就以 OSX 为标准吧。完整的快捷键可以在 sublime -&gt; Preferences -&gt; King Bindings [Default, User] 这里查看和更改设置。&lt;/p&gt;

&lt;p&gt;　　先说明一下，如果快捷键不work的话，一般是因为和系统或其他快捷键有冲突，可以在 preference -&gt; key binding 里更改一下。&lt;/p&gt;

&lt;h2&gt;1. 功能查找：ctrl + p&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;直接输入，可以快速查找文件&lt;/li&gt;
&lt;li&gt;输入@+函数名，查找函数，这个功能还有快捷键：ctrl + r，已经直接在查找栏里不全了一个 @ 了。&lt;/li&gt;
&lt;li&gt;输入#+文本，文件内文本匹配&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. 多选：ctrl + d&lt;/h2&gt;

&lt;p&gt;把光标放在一个单词上，按下ctrl + D,将选择这个单词。一直按住ctrl且按D多次，将选择当前选中项的下一个匹配项。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/ctrld.gif&quot; alt=&quot;ctrld.gif&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;3. 打开关闭边栏： ctrl + k, ctrl + b&lt;/h2&gt;

&lt;p&gt;这个功能个人觉得很实用，特别是有一个竖屏的时候，在竖屏上写代码时，ctrl + k, ctrl + b 把侧边栏关闭，那感觉叫一个酸爽啊，哈哈。&lt;/p&gt;

&lt;h2&gt;4. 文本查找：ctrl + f, ctrl + shift + f&lt;/h2&gt;

&lt;p&gt;ctrl + f：当前文件内查找
ctrl + shift + f：在当前打开的folder中的所有文件内查找，还可以有替代功能【在windows下，sumblime 2，好像用搜狗輸入法的中文時，不能使用这个功能，需要切换成美式键盘才可以使用这个功能】&lt;/p&gt;

&lt;h2&gt;5. 命令模式：ctrl + shift + p&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;minimap：隐藏或显示右侧的小地图&lt;/li&gt;
&lt;li&gt;set syntax：设置当前文本语法&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;6. 快速跳到某一行：ctrl + g&lt;/h2&gt;

&lt;h2&gt;7. 完整拷贝，避免格式错乱：ctrl + shift + v&lt;/h2&gt;

&lt;p&gt;我们发现，在从别的文件中拷贝一段代码过来的时候，多半只是第一行缩进，后面都乱了，这时可以使用Ctrl + Shift + V进行粘贴，可以在粘贴的过程中保持缩进，这时格式都是正确的。&lt;/p&gt;

&lt;h2&gt;8. 重新打开关闭的标签：command + shift + t&lt;/h2&gt;

&lt;p&gt;在Chrome里面，如果你不小心关闭了某个标签页并想恢复它，你可以按下Shift + Ctrl + T重新打开它。
在ST3中也一样，如果你不小心关闭了某个文件，可以按下Shift + command + T快速恢复。连续重复该按键，ST将会按照关闭的先后顺序重新打开标签页。&lt;/p&gt;

&lt;h2&gt;9. 左右标签切换：command + shift + {, }&lt;/h2&gt;

&lt;p&gt;command + shift + {, 转向当前标签的左面一个标签，反之。&lt;/p&gt;

&lt;h2&gt;10. 删除整行：ctrl + shift + k / ctrl + x&lt;/h2&gt;

&lt;p&gt;同样的，在windows下，如果使用搜狗输入法的话，这样也会不能用，应该是被搜狗本身的快捷键覆盖了，需要切换到美式键盘才行。&lt;/p&gt;

&lt;h2&gt;11. 强力分屏，宽屏的福音：command + alt + 数字键&lt;/h2&gt;

&lt;p&gt;同样也是我经常使用的一个快捷键，因为有3个屏幕，一个笔记本，一个23的宽屏，一个19的竖屏。在竖屏上写代码时基本都是 ctrl + k, ctrl + b 关闭左侧边栏，在宽屏上写代码时常常会用 command + alt + 2 切换成2屏，刷起来感觉刁刁的，爽爽的。&lt;/p&gt;

&lt;h2&gt;12. 关闭当前文件：ctrl + w&lt;/h2&gt;

&lt;h2&gt;13. 选择行：ctrl + l&lt;/h2&gt;

&lt;p&gt;选择某行，重复可以依次增加选择下一行。&lt;/p&gt;

&lt;h2&gt;14. 全屏：ctrl + command + f&lt;/h2&gt;

&lt;h2&gt;15. 切换标签：command + 数字&lt;/h2&gt;

&lt;p&gt;切换到第N个文件。&lt;/p&gt;

&lt;h2&gt;16. 快速查找下一个、上一个&lt;/h2&gt;

&lt;p&gt;选中单词，command + g，快速选中下一个，command + shift + g，快速选中上一个。&lt;/p&gt;

&lt;h2&gt;17. 缩进中tab转为space&lt;/h2&gt;

&lt;p&gt;command + , 打开用户设置，设置 &quot;translateTabsToSpaces&quot; 为 &quot;ture&quot;，然后保存一下就ok了。&lt;/p&gt;

&lt;p&gt;顺便了解一下sublime加载配置文件的顺序：&lt;/p&gt;

&lt;p&gt;Packages/Default/Preferences.sublime-settings
Packages/Default/Preferences (&lt;platform&gt;).sublime-settings
Packages/User/Preferences.sublime-settings
Packages/&lt;syntax&gt;/&lt;syntax&gt;.sublime-settings
Packages/User/&lt;syntax&gt;.sublime-settings&lt;/p&gt;

&lt;p&gt;更多的配置详情可以查询这两个链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.sublimetext.com/docs/2/indentation.html&quot;&gt;config sublime 1&lt;/a&gt;
&lt;a href=&quot;http://www.sublimetext.com/docs/indentation&quot;&gt;config sublime 2&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;18. 安装插件&lt;/h2&gt;

&lt;p&gt;按Ctrl+`调出console，如果这个快捷键不管用，肯定是有其他工具占用了这个快捷键。如果成功调出console，粘贴下面的代码，安装package control组件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2,os;pf=&#39;Package Control.sublime-package&#39;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http://sublime.wbond.net/&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功后重启sublime，command + shift + p调出命令面版，输入install，应该能找到install package的选项。&lt;/p&gt;

&lt;h2&gt;19. 大小写互换&lt;/h2&gt;

&lt;p&gt;command + kl：将选中的单词转换为小写
command + ku：将选中的单词转换为大写&lt;/p&gt;

&lt;h2&gt;20. 折叠函数&lt;/h2&gt;

&lt;p&gt;command + k + 1: 折叠所有函数  &lt;br/&gt;
command + k + j: 展开所有函数&lt;/p&gt;

&lt;p&gt;如果不work，查看： edit -&gt; code foldingcd &#39;dkaf&#39;&lt;/p&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-01-26-sublime-key-shortcut.md.jpg&quot; alt=&quot;2015-01-26-sublime-key-shortcut.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>伴我一路走来的那些bug们，你们好</title>
     <link href="/bugs-in-my-life"/>
     <updated>2015-06-15T00:00:00+08:00</updated>
     <id>/bugs-in-my-life</id>
     <content type="html">&lt;h2&gt;1. failed to write data to stream&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;环境：ipython, OSX&lt;/li&gt;
&lt;li&gt;操作：在ipython里import 一个pure module&lt;/li&gt;
&lt;li&gt;问题： Python - ERROR - failed to write data to stream: &lt;open file &#39;&lt;stdout&gt;&#39;, mode &#39;w&#39; at 0x104c8f150&gt;&lt;/li&gt;
&lt;li&gt;办法：export PYTHONIOENCODING=UTF-8 will solve it.&lt;/li&gt;
&lt;li&gt;相关：&lt;a href=&quot;http://stackoverflow.com/questions/28115375/python-error-failed-to-write-data-to-stream-open-file-stdout-mode-w&quot;&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. Git: fatal: Pathspec is in submodule&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;环境：OSX, Git&lt;/li&gt;
&lt;li&gt;操作：git add *&lt;/li&gt;
&lt;li&gt;问题：有一个github repo [暂且叫father]，其中这个repo里有子module [暂且叫 child]，且这个child也是作为一个独立的github repo存在，我更改了child下的一些文件，然后在father下执行git add，准备在father下直接commit和push，执行git add 的时候出错，提示 &lt;code&gt;Pathspec is in submodule&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;办法：现在child下add，commit和push，然后再到father下add，commit和push；&lt;/li&gt;
&lt;li&gt;相关：最好的方式是：在child下git branch 一个新的分支，然后在这个分支上修改，然后add，commit，push；修改好child后，再到father下新建一个分支，执行add，commit，push。最后，要merge的时候，也是先merge掉child，然后再merge掉father。因为child作为一个独立的repo，所有的更改都要在child这个独立repo下面做更改，由于项目需要，child作为father的一个子module，不能直接在father里更改child然后再add，commit，push。因为father里的child，只是链接到了child这个独立repo。或者说，father里的child只是独立的child的一个只读镜像。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. DB: (2013, &#39;Lost connection to MySQL server during query&#39;), python decorator, gevent, greenlet, function life cycle&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;环境：OSX, Python 2.7, Gevent, MySQL&lt;/li&gt;
&lt;li&gt;操作：对每一个用户异步地向数据库写一条数据［实际上的逻辑要稍微复杂一点］，为了方便理解，我们现在构造这样一个场景。用户在网页上参赛高考，全是选择题，当用户选中答案并且准备开始下一题时，后台需要把用户的答案写到数据库里面。但是因为考生太多了，假设有1000万呢，一张2个小时的考卷有150到选择题，并且假设一个考生平均每道题会更改答案0.2次，那么我们先算算这个请求压力是多少：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;(total request times)/(total time in seconds) = 
10^8 * 150 * (1 + 0.2) / 2 / 60 / 60 = 
180 * 10^8 / 7200 = 
0.025 * 10^8 = 
2.5 * 10^6 = 25 万次请求／每秒
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见其实请求也不是特别大，但是这只是平均请求，天才知道峰值多少呢？其次，zf总不会也要模仿12306那样，请个大公司来做吧。于是，zf里的一个工程师决定，应该把写数据库这个操作异步执行，这样考生在网页上点了下一题之后，虽然立即跳转到下一题，但并不表示考生上一题的答案已经写入数据库了。&lt;/p&gt;

&lt;p&gt;ok了，场景大概就是这样了。 详情见代码片段 ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Test(object):
    @get_dbc
    def assign_user_to_exp(self, dbc, user_id, cell_id):
            self.g_pool.spawn(
                self.async_assign_user_to_exp,
                dbc,
                user_id,
                cell_id,
            )
            return

    def async_assign_user_to_exp(self, dbc, user_id, cell_id):
        return dbc.execute(&#39;&#39;&#39; there is a sql sentence that refering user_id and cell_id, just leave details here &#39;&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;问题：现在的问题是，每次执行 Test().assign_user_to_exp() 时，都会发生错误：(2013, &#39;Lost connection to MySQL server during query&#39;)。&lt;/li&gt;
&lt;li&gt;办法：装饰器get_dbc换个位置， 如下：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;class Test(object):
    def assign_user_to_exp(self, user_id, cell_id):
            self.g_pool.spawn(
                self.async_assign_user_to_exp,
                user_id,
                cell_id,
            )
            return

    @get_dbc
    def async_assign_user_to_exp(self, dbc, user_id, cell_id):
        return dbc.execute(&#39;&#39;&#39; there is a sql sentence that refering user_id and cell_id, just leave details here &#39;&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;相关：bug的原因是在执行 Test().assign_user_to_exp() 的时候，都先会通过装饰器 get_dbc 去取一个 db 的connection/cursor，然后作为参数传给 async_assign_user_to_exp 函数。可是这里有个问题，gevent 创建了一个greenlet后，也就是 Test().assign_user_to_exp() 的真实作用，这个时候 dbc 已经被释放了，然后过一会儿在greenlet里真正执行数据库操作时，即函数 async_assign_user_to_exp 开始执行时，才发现尼玛穿进来的 dbc 数据库连接已经被释放掉了，所以就会报一个 Lost connection to MySQL server during query 。真是很微妙的，很细节的问题。这个问题我和一个同事研究了好些时间都没有找到问题，后来 cto 过来一看，秒秒钟就解决来。突然间想起李开复的一句话 : 要想做技术型管理者，首先要在技术能力上让手下佩服。不说鸟，继续学习去～&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;4. fluentd 启动报错： unexpected error error_class=RuntimeError error=#&amp;lt;RuntimeError: can&#39;t call S3 API. Please check your aws_key_id / aws_sec_key or s3_region configuration. error = #&amp;lt;AWS::S3::Errors::RequestTimeTooSkewed: The difference between the request time and the current time is too large.&gt;&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;环境：OSX, Python 2.7, fluentd&lt;/li&gt;
&lt;li&gt;操作：启动fluentd 服务的时候出错，错误信息说明连不上aws s3，配置文件如下：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;lt;match *.group_ab_testing&amp;gt;
  type s3
  aws_key_id ***
  aws_sec_key ***
  s3_bucket dev-test-bucket-name
  path storage_path/
  time_slice_format %Y/%m/%d/dev/%H
  buffer_path /mnt/td-agent/temp_file
  buffer_chunk_limit 10m
  utc
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题表现得像是这个aws_key_id和aws_sec_key访问不到，或者访问s3超时，已经排除aws_key_id和aws_sec_key无效的可能性。fluentd配置文件也没有错，于是安装 &lt;code&gt;sudo pip install awscli&lt;/code&gt; awsci 客户端来调试，调试过程如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aaron@dev-aaron:/etc/td-agent$aws configure
AWS Access Key ID [None]: AKIAIZFF6PMYSYCU2Z7Q
AWS Secret Access Key [None]: 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
Default region name [None]:
Default output format [None]:
aaron@dev-aaron:/etc/td-agent$aws s3 ls

A client error (RequestTimeTooSkewed) occurred when calling the ListBuckets operation: The difference between the request time and the current time is too large.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看来问题依然存在，请求伟大的 google，感谢有人已经在伟大的 stackoverflow 上问过类似的问题了：
&lt;a href=&quot;http://stackoverflow.com/questions/25964491/aws-s3-upload-fails-requesttimetooskewed&quot;&gt;aws-s3-upload-fails-requesttimetooskewed&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;高人说也许是本地时间和s3上点时间不一致的导致的，果然本地时间比s3时间晚了十几分钟：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aaron@dev-aaron:/etc/td-agent$curl http://s3.amazonaws.com -v
* About to connect() to s3.amazonaws.com port 80 (#0)
*   Trying 54.231.14.248... connected
&amp;gt; GET / HTTP/1.1
&amp;gt; User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3
&amp;gt; Host: s3.amazonaws.com
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 307 Temporary Redirect
&amp;lt; x-amz-id-2: iR7WZjF4wccLoZCfGJeZ5SHM8AQP9SK3oCTNwsBwkW60u02JFI2OqTakcjsLYMv1TnsTZFXHkmc=
&amp;lt; x-amz-request-id: 90748BF8849F53E7
&amp;lt; Date: Tue, 04 Aug 2015 04:41:44 GMT
&amp;lt; Location: http://aws.amazon.com/s3/
&amp;lt; Content-Length: 0
&amp;lt; Server: AmazonS3
&amp;lt;
* Connection #0 to host s3.amazonaws.com left intact
* Closing connection #0
aaron@dev-aaron:/etc/td-agent$date -u
Tue Aug  4 04:23:27 UTC 2015
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;办法：重启机器或者同步utc时间即可；&lt;/li&gt;
&lt;li&gt;相关：fluentd 的配置文件的所有者和所在组都需要为td-agent这个进程；否则启动时候也会报错的；&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;5. sublime 配置文件&lt;/h2&gt;

&lt;h2&gt;6. 一次 A/B testing 中遇到的错误&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;场景

&lt;ul&gt;
&lt;li&gt;操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>一次微信升级引发的思考</title>
     <link href="/thinking-of-wechat-design"/>
     <updated>2015-06-08T00:00:00+08:00</updated>
     <id>/thinking-of-wechat-design</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 先看看升级前[6.1]和升级后[6.2]的区别&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;升级前：6.1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/wechat1.jpg&quot; alt=&quot;6.1.1&quot; /&gt;
&lt;img src=&quot;../../images/wechat2.jpg&quot; alt=&quot;6.1.2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;升级后： 6.2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/wechat3.jpg&quot; alt=&quot;6.2.1&quot; /&gt;
&lt;img src=&quot;../../images/wechat4.jpg&quot; alt=&quot;6.2.2&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;2. 我对这次升级的第一印象&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/awesome.jpg&quot; alt=&quot;awesome&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　微信这次升级应该有不少改善的地方，我就 &quot;钱包&quot; 这个比较让我满意的功能点来谈谈我的感想。当时我打开钱包这个功能的时候，第一反应是 “wow，实在太赞了，终于把 “零钱” 这个按钮放出来了“。先说说我为什么喜欢零钱这个按钮，因为红包，常常抢红包，没几天我就会很好奇地去看看自己现在抢红包抢了多少钱，于是乎每次都要操作好几次：我 -&gt; 钱包 -&gt; 钱包 -&gt; 零钱。而现在我只需要操作两次：我 -&gt; 钱包 就可以看见我的零钱有多少了。一下子节省了两步，可能你会觉得这没什么稀奇的。可是我想说，对我这种经常使用这个功能来说的人，两步已经足够让我们惊喜了。&lt;/p&gt;

&lt;p&gt;　　好了，相信不少人看到我上面的说法，大都想说，众口难调，也许这个功能的升级只是让少部分我这种类型的用户满意而已，也许很多不想把 “零钱” 这个功能暴露出来的用户会吐槽这个改善点。yes，我相信是会有吐槽的用户。但是，我相信每一次升级，都肯定是经过深思熟虑的，肯定是经过验证的。这里就引出了一个很有趣的问题，在没有升级这个功能之前，微信产品组是基于什么来决定要改善这样一个功能的，是经过什么东西来验证这个功能的升级是有必要的？这个问题，也是我通过微信这次升级获得的思考和感悟----如何决定一个功能是否要改善？如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？&lt;/p&gt;

&lt;p&gt;　　好的，让我们先把问题强调一下，因为最后还要梳理方案呢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 1. 如何决定一个功能是否需要改善？&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;&lt;em&gt;问题 2. 如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;3. 如何决定一个功能是否需要改善&lt;/h2&gt;

&lt;p&gt;　　其实，在感谢这次升级之余，我想过一个问题：我假设有很多用户向我一样，也很喜欢 ”零钱“ 这个功能的改善。但我确实很好奇，微信是怎么决定来要改善 ”零钱“ 这个功能的？作为一个做技术出生的，我从技术角度想了想，发现这个问题其实做起来，那是easy enough的，而且是完全可以量化的。&lt;/p&gt;

&lt;p&gt;　　在&lt;a href=&quot;http://book.douban.com/subject/25942507/&quot;&gt;《参与感》&lt;/a&gt; 这本书中提到小米最初是如何呵护前几百个粉丝的，如何通过与粉丝的互动来改善小米的功能的。我想，一个反馈很好的功能升级，必然是在某种程度上与用户有所互动后的决定，或者说是在与用户 ”沟通” 后的决议。当然微信用户这么大，不可能向小米当初初创的时候一样，维护一个用户bbs来讨论用户的观点。必须要用一种更精准，更可以量化，可以解释，而且成本低廉的方法来做到与用户在功能点上的 “沟通”。&lt;/p&gt;

&lt;p&gt;　　好了，说了这么多废话，铺垫都全打好了，下面我就直接来说说在我看来，微信是怎么做到与用户 ”沟通“，微信是怎么决定要升级 ”零钱“ 这个功能的吧？&lt;/p&gt;

&lt;p&gt;　　其实，all roads lead to Rome，“沟通”的初衷是为了知道用户的想法，but我们应该要知道，用户的表达自己的想法，很多时候并不是通过语言来表达呢【甚至很多人根本没法用语言表达，特别是我这种光长得帅但表达能力处于世界级 low 20%的人】，用户还有很多其他的方法来表达自己的想法，其中最真实，最可信，最可量化的就是用户的action，actions speak louder than words。所以，我们要想知道用户的想法，其实完全可以通过另一条道路，即去探索用户的action，而且这种方法对所有用户都适用，男女老少通吃啊。&lt;/p&gt;

&lt;p&gt;　　so，现在又来一个问题了，这里的用户的action，具体指的是什么呢？下面给大家一张图，只要做过SEO的，相信看见这张图就完全明白我接下来要说的了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 3. 用户的action，具体指的是什么&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/google_hot_2.jpg&quot; alt=&quot;google_hot_v2.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上面是一张google点击的热点图，颜色越深代表越受到用户的关注。&lt;/p&gt;

&lt;p&gt;　　google的这个热点分析做得比较复杂，我们就不深入了。接着说我对“用户的action”这个问题的看法。其实最简单，也是最可信的action就是用户的点击了。每一个click，都可以看作用户对每一个功能的关注度，只要时间长，用户样本多，那么这个数据就是可信的。通过用户的点击数据，针对于用户来说，我们可以知道用户最常用的是哪些功能；针对于产品来说，我们可以知道一个产品的新功能点在发布后一段时间内的点击率的变化过程和趋势。&lt;/p&gt;

&lt;p&gt;　　好了，其实上面我堆砌了几打的措辞，就是为了突出上面这段话，就是为了引出我认为本文的核心词---用户的点击数据。&lt;/p&gt;

&lt;p&gt;　　下面，我想梳理一下我的思路，以对上面提出的三个问题作答的形式来表明我的观点。&lt;/p&gt;

&lt;h2&gt;4. The kernel behind my mind&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 3. 用户的action，具体指的是什么&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用户的action，简单的是指用户的点击数据；复杂的是指用户在每一个功能页面的停留时间。
至于怎么处理分析这些数据，方法就太多了。   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 2. 如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可以根据用户对APP上每一个功能点的点击数据来做统计分析。功能点的划分可以有不同的维度，
比如说微信6.1的钱包是可以是一个功能点，钱包里的零钱也可以作为一个功能点。也就是说，
我们可以以不同的维度和粒度来区分功能点，对每一个功能点来做用户点击数据的统计分析。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 1. 如何决定一个功能是否需要改善？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;有了上面的各个功能点的统计数据，我想大概就能决定一个功能点是否有必要更改了。
当然，这只是其中一个因素，一个功能点的改善肯定不仅仅靠数据来决定的，
也要看这个逻辑是否合理。比如说微信6.1的钱包，我要想看我自己的零钱的话，
步骤是： 我 -&amp;gt; 钱包 -&amp;gt; 钱包 -&amp;gt; 零钱，我会觉得很奇怪，为什么会有两个“钱包”的功能，
这在功能点上不是重复了吗？
如果说升级成6.2的钱包的花，操作步骤是：我 -&amp;gt; 钱包，
第一，去重了“钱包”这个重复的功能点，
第二，不用点击零钱即可预先知道自己的零钱余额有多少。
当然，这个细节还有很多可以提的，大家可以自行发挥想象和交流。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. 如何做到真正的参与感&lt;/h2&gt;

&lt;p&gt;　　所有的产品，都是服务于用户。熟话说得好，不以恋爱为目的的约会都是瞎折腾，不以用户为女神的产品都是瞎糊弄。既然产品的核心是用户，那我们关于产品所做的一切设计，优化甚至是改变都应该在改动之前与用户有过沟通，要确保用户对我们所做的改动有所认同。&lt;/p&gt;

&lt;p&gt;　　我很赞成小米初期的那种做法，维护一个简单的bbs，每天和粉丝们互动，收集需求，整理需求，规划产品，step by step地做到今天这个样子，值得借鉴和思考，但不可照搬。其一，因为人家的那种粉丝和其他很多产品的粉丝都不一样，人家的那种粉丝还有另外一个称呼 ”发烧友“，这些粉丝是有足够的耐心和愿意花足够的时间来反馈产品的优缺点和各自需求的。其二，当一个产品的用户数大了后，维护这个bbs将会话费大量人力物力，性价比太低。&lt;/p&gt;

&lt;p&gt;　　既然如此，既要和用户沟通，又要保证沟通成本，采用上面说的技术方案岂不是一个很不错的方法。而且上面说的技术方案，实现起来足够简单，而且可量化，可解释，甚至可跟踪。&lt;/p&gt;

&lt;h2&gt;6. 最后，我想说&lt;/h2&gt;

&lt;p&gt;　　最后，我想说，以上所有，都只是自己对微信这次升级中，钱包功能的一个简单看法。小生是后端工程师一枚，不是的产品经理，只是简单的出于对这次升级的感谢，以及对产品的一点技术方面的简单思考而写的这篇文章。bug肯定很多，不过我享受调bug这个过程啊，哈哈。&lt;/p&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-06-08-thinking-of-wechat-design.md.jpg&quot; alt=&quot;2015-06-08-thinking-of-wechat-design.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Python 并发编程之一：Gevent</title>
     <link href="/python-gevent"/>
     <updated>2015-05-28T00:00:00+08:00</updated>
     <id>/python-gevent</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 什么是Gevent&lt;/h2&gt;

&lt;p&gt;gevent是一个基于libev的python并发框架,以微线程greenlet为核心，使用了epoll事件监听机制以及诸多其他优化而变得高效.而且其中有个monkey类, 将现有基于Python线程直接转化为greenlet(类似于打patch).&lt;/p&gt;

&lt;p&gt;greenlet 包是 Stackless 的副产品，其将微线程称为 “tasklet” 。tasklet运行在伪并发中，使用channel进行同步数据交换。&lt;/p&gt;

&lt;p&gt;一个”greenlet”，是一个更加原始的微线程的概念，但是没有调度，或者叫做协程。这在你需要控制你的代码时很有用。你可以自己构造微线程的 调度器；也可以使用”greenlet”实现高级的控制流。例如可以重新创建构造器；不同于Python的构造器，我们的构造器可以嵌套的调用函数，而被嵌套的函数也可以 yield 一个值。(另外，你并不需要一个”yield”关键字，参考例子)。&lt;/p&gt;

&lt;h2&gt;2. 什么是 Coroutine&lt;/h2&gt;

&lt;p&gt;要理解Gevent，明白Gevent的执行机制，需要了解另外一个概念：Coroutine，中文叫做协程。第一次看见这个名词，确实很奇怪，进程、线程都了解了，突然冒出个协程，还真有点反应不过来。&lt;/p&gt;

&lt;p&gt;按照 &lt;a href=&quot;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&quot;&gt;进程、线程和协程的理解&lt;/a&gt; 的说法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的说法不是很好理解，后来发现这篇文章 &lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt;, 里面对协程的解释是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用简单的一句话来说Coroutine，就是可以暂时中断，之后再继续执行的程序，
我们来看一个例子，事实上Python就有最基础的Coroutine，也就是generator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，通过上面两篇文章，理解协程已经对比协程、进程、线程的概念就清晰很多了：&lt;/p&gt;

&lt;p&gt;协程就是一种特殊的并发机制，其调度[就是指什么时候调用什么函数]完全由程序员指定，比如说这篇文章里的例子：  &lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf8 -*-
def foo():
    for i in range(10):
        # 丢资料并且把主控权交给呼叫者
        yield i
        print u&#39;foo: 主控又回到我手上了，打我阿笨蛋&#39;

bar = foo()
# 执行coroutine
print bar.next()
print u&#39;main: 现在主控权在我们手上，做点杂事&#39;
print &#39;main:hello baby!&#39;
# 回到刚才foo这个coroutine中断的地方继续执行
print bar.next()
print bar.next()


###结果：

0
main: 现在主控权在我们手上，做点杂事
main:hello baby!
foo: 主控又回到我手上了，打我阿笨蛋
1
foo: 主控又回到我手上了，打我阿笨蛋
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. Gevent适用场景&lt;/h2&gt;

&lt;p&gt;说到Gevent的适用场景，不得不先理解Gevent的优缺点。按照上面我们的说法，还有那两篇文章的理解，Gevent是通过协程的机制来实现并行，即其并行机制并没有利用到多核CPU的优势，所以很明显了，Gevent的优缺如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多进程能够利用多核优势，但是进程间通信比较麻烦，另外，进程数目的增加会使性能下降，进程切换的成本较高。程序流程复杂度相对I/O多路复用要低。&lt;/li&gt;
&lt;li&gt;I/O多路复用是在一个进程内部处理多个逻辑流程，不用进行进程切换，性能较高，另外流程间共享信息简单。但是无法利用多核优势，另外，程序流程被事件处理切割成一个个小块，程序比较复杂，难于理解。&lt;/li&gt;
&lt;li&gt;线程运行在一个进程内部，由操作系统调度，切换成本较低，另外，他们共享进程的虚拟地址空间，线程间共享信息简单。但是线程安全问题导致线程学习曲线陡峭，而且易出错。&lt;/li&gt;
&lt;li&gt;协程有编程语言提供，由程序员控制进行切换，所以没有线程安全问题，可以用来处理状态机，并发请求等。但是无法利用多核优势。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以，协程的适用场景，应该是一些I/O密集型的并行程序，而对应的计算密集型，应当采用传统的多线程、多进程方案。&lt;/p&gt;

&lt;h2&gt;4. Gevent编程模式和思维方法&lt;/h2&gt;

&lt;p&gt;我想从两个例子来介绍Gevent的编程模式，第一个比较简单，可以直接去看这篇文章里的开篇例子，&lt;a href=&quot;http://xlambda.com/gevent-tutorial/#&quot;&gt;gevent程序员指南&lt;/a&gt;。不过这个例子只是简单的解释gevent的执行流程和编程模式，离现实应用还有一定的距离。当看完这篇文章后，可以参考Firefox的一个实例就行了，&lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;总结一下，按照我个人的理解，要想用好gevent，需要先思考下面几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你的应用是否需要考虑Gevent；&lt;/li&gt;
&lt;li&gt;如何把你的大任务slice成小任务，这些任务之间是否独立；&lt;/li&gt;
&lt;li&gt;如果收集，处理小任务执行的结果；&lt;/li&gt;
&lt;li&gt;理解如何真正利用gevent来实现并行，很多情况下，如果是网络I/O，需要打patch的；比说 &lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;这里接上一点，打patch要小心，比如说打了socket的patch，要先知道会不会影响到本应用中其他用了socket的服务，因为打patch是直接替换了当前运行时环境里的socket，所以在当前运行时环境里使用socket的服务都会受影响；&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;5. Gevent In Action&lt;/h2&gt;

&lt;p&gt;因为Gevent多用于I/O密集型并发程序，而网络请求又是很常见的一种I/O请求，所以在大规模网络并发请求的时候，可以使用Gevent。相信python程序员都应该用过 requests 这个包吧，都应该知道 requests 的作者，kennethreitz，一个货真价实的 python界的大牛。他在写了 requests 的同时，还写了一个包：&lt;a href=&quot;https://github.com/kennethreitz/grequests&quot;&gt;grequest ： gevent + requests &lt;/a&gt;，把requests用gevent包了一下，实现异步的网络请求，下次大家要是有网络方面的并发请求，需要用到gevent的话，就不用重复造轮子了，直接用 &lt;a href=&quot;https://github.com/kennethreitz/grequests&quot;&gt;grequests&lt;/a&gt; 就好了。&lt;/p&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&quot;&gt;进程、线程和协程的理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://xlambda.com/gevent-tutorial/#&quot;&gt;gevent程序员指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/77240/&quot;&gt;python greenlet背景介绍与实现机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.elias.cn/Python/PyConcurrency?from=Develop.PyConcurrency&quot;&gt;Python几种并发实现方案的性能比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-05-28-python-gevent.md.jpg&quot; alt=&quot;2015-05-28-python-gevent.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-4. Web 高性能开发参考资料</title>
     <link href="/web-high-performance"/>
     <updated>2015-05-02T00:00:00+08:00</updated>
     <id>/web-high-performance</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;0. 写在前面&lt;/h2&gt;

&lt;p&gt;　　工作一年多了，发现自己还是没什么长进。学技术这件事儿，还是得靠自己啊，所以我准备以专题的形式来提升自己的能力。这篇我总结了一些搜集的比较好的讲web高性能开发的文章和书籍，都是我自己看过的。以后再也不怕别人问到高性能web的经验和知识了，用老话说，就算没吃过猪肉也应该见过猪跑吧，咱就算没经历过高性能web开发实践，也至少了解一些这方面的知识吧。哈哈。&lt;/p&gt;

&lt;h2&gt;1. 模式相关&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2014/09/05/design-pattern-cheatsheet/&quot;&gt;设计模式概览图&lt;/a&gt;  &lt;br/&gt;
　　以图形的形式简单阐述了各种模式的概念，图画得不错，表述也清晰，可以有空翻开看看；
&lt;img src=&quot;../images/design_pattern.png&quot; alt=&quot;design_pattern.png&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/08/software-architecture-patterns/&quot;&gt;软件架构模式&lt;/a&gt; &lt;br/&gt;
　　是作者对这本书的&lt;a href=&quot;http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf&quot;&gt;Software Architecture Patterns&lt;/a&gt; 笔记和总结，写得很详细，可以时常参考，提升架构方面的基础和概念，同时，有时间也推荐读读原书，原书PDF链接在后面。 &lt;br/&gt;
　　这里面提的架构有：分层架构，事件驱动架构，微内核架构，微服务架构，基于空间的架构。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/10/microservice-architecture-a-quick-guide/&quot;&gt;微服务架构快速指南&lt;/a&gt; &lt;br/&gt;
　　不常听说为服务架构，简单的理解，就是介于monolithic和SOA模式之间的一个架构模式，比monolithic灵活，轻便，比SOA有更强的组织性。不必过于在乎三者之间的差别，根据实际情况选择合适自己项目的架构模式。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/24/microservice-design-patterns/&quot;&gt;微服务架构的设计模式&lt;/a&gt; &lt;br/&gt;
　　是&lt;strong&gt;微服务架构快速指南&lt;/strong&gt;的细节篇，里面介绍了一些常用的微服务架构的设计模式，在设计项目架构的时候，如果没有什么思路，这篇文章是很好的参考资料。简单的说，里面提到了常用的微服务设计模式：聚合器，代理，链式服务，分支，数据共享，异步消息。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.admin10000.com/document/5980.html&quot;&gt;大型网站系统架构的演化&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5981.html&quot;&gt;大型网站的灵魂——性能&lt;/a&gt;&lt;br/&gt;
　　非常好的介绍大型网站架构变化的文章，这个网站有一个专门讲大型网站性能的文章系列，都非常值得学习。我把这个系列也列在下面了，写得很细，算是最值得参考和学习的文章了。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5880.html&quot;&gt;关于大型网站技术演进的思考（一）--存储的瓶颈（1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5881.html&quot;&gt;关于大型网站技术演进的思考（二）--存储的瓶颈（2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5882.html&quot;&gt;关于大型网站技术演进的思考（三）--存储的瓶颈（3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5909.html&quot;&gt;关于大型网站技术演进的思考（四）--存储的瓶颈（4）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5910.html&quot;&gt;关于大型网站技术演进的思考（五）--存储的瓶颈（5）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5911.html&quot;&gt;关于大型网站技术演进的思考（六）--存储的瓶颈（6）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5951.html&quot;&gt;关于大型网站技术演进的思考（七）--存储的瓶颈（7）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5952.html&quot;&gt;关于大型网站技术演进的思考（八）--存储的瓶颈终篇（8）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5966.html&quot;&gt;关于大型网站技术演进的思考（九）--网站静态化处理--总述（1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5967.html&quot;&gt;关于大型网站技术演进的思考（十）--网站静态化处理—动静整合方案（2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5968.html&quot;&gt;关于大型网站技术演进的思考（十一）--网站静态化处理—动静分离策略（3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6020.html&quot;&gt;关于大型网站技术演进的思考（十二）--网站静态化处理—缓存（4）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6021.html&quot;&gt;关于大型网站技术演进的思考（十三）--网站静态化处理—CSI（5）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6022.html&quot;&gt;关于大型网站技术演进的思考（十四）--网站静态化处理—前后端分离—上（6）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6023.html&quot;&gt;关于大型网站技术演进的思考（十五）--网站静态化处理—前后端分离—中（7）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6024.html&quot;&gt;关于大型网站技术演进的思考（十六）--网站静态化处理—前后端分离—下（8）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6025.html&quot;&gt;关于大型网站技术演进的思考（十七）--网站静态化处理—满足静态化的前后端分离（9）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6026.html&quot;&gt;关于大型网站技术演进的思考（十八）--网站静态化处理—反向代理（10）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6027.html&quot;&gt;关于大型网站技术演进的思考（十九）--网站静态化处理—web前端优化—上（11）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6028.html&quot;&gt;关于大型网站技术演进的思考（二十）--网站静态化处理—web前端优化—中（12）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6029.html&quot;&gt;关于大型网站技术演进的思考（二十一）--网站静态化处理—web前端优化—下【终篇】（13）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. 高性能网站相关&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/20/how-to-build-a-scalable-website/&quot;&gt;如何构建高扩展性网站&lt;/a&gt; &lt;br/&gt;
　　是一本小册子&lt;a href=&quot;http://book.douban.com/subject/10756899/&quot;&gt;《高扩展性网站的50条原则》&lt;/a&gt;的读书笔记。这本书不错，值得一看，在设计、改进项目架构时都可以拿来翻翻，不错的小册子。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2014/09/26/best-free-website-speed-testing-tools/&quot;&gt;最佳免费的网站性能测试工具&lt;/a&gt; &lt;br/&gt;
　　这篇博文是我认为最有实际意义的一篇博文之一了，里面提到了12个免费的网站性能测试工具，比如大名鼎鼎的google pagespeed insights。我的建议是，在进行任何优化前，都先简单地用这些工具在线测试一下。不要盲目地进行后台的优化，更不要盲目的去设计一些高端的算法来做所谓的加速。比如说，一个请求后台返回的时间控制在100ms之内，但发起这个请求的js脚本被写在一个很大的js文件里面，导致下载这个js文件需要数百毫秒，那此时应该怎么优化呢？别跟我说你会让你的后台工程师去找一什么高大上的算法来解决这个问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.blogjava.net/BearRui/archive/2010/04/26/web_performance.html&quot;&gt;web高性能开发系列随笔&lt;/a&gt; &lt;br/&gt;
　　算是一篇比较简单，但是完善的web性能优化博客了，里面涉及到前后端的各种优化方法，虽然我只是后台开发，但看这种文章能够让开发人员从全局的视角去设计和优化你的web系统。就跟上一篇 &lt;a href=&quot;http://colobu.com/2014/09/26/best-free-website-speed-testing-tools/&quot;&gt;最佳免费的网站性能测试工具&lt;/a&gt; 文章一样，在优化前，先全局、完整地了解你的web系统，再来说具体怎么优化吧。如果你在优化前，不知道怎么对web系统“全局”地了解，这篇博客可以入门用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. 参考书籍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf&quot;&gt;Software Architecture Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/10756899/&quot;&gt;高扩展性网站的50条原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/3924175/&quot;&gt;构建高性能Web站点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-05-02-web-high-performance.md.jpg&quot; alt=&quot;2015-05-02-web-high-performance.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Python 技巧总结</title>
     <link href="/python-materials"/>
     <updated>2015-03-17T00:00:00+08:00</updated>
     <id>/python-materials</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 枚举 - enumerate 可以有参数哦&lt;/h2&gt;

&lt;p&gt;之前我们这样操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i = 0
for item in iterable:
    print i, item
    i += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们这样操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i, item in enumerate(iterable):
    print i, item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;enumerate函数还可以接收第二个参数。就像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(enumerate(&#39;abc&#39;)) 
[(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;)] 

&amp;gt;&amp;gt;&amp;gt; list(enumerate(&#39;abc&#39;, 1)) 
[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 字典/集合 解析&lt;/h2&gt;

&lt;p&gt;你也许知道如何进行列表解析，但是可能不知道字典/集合解析。它们简单易用且高效。就像下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my_dict = {i: i * i for i in xrange(100)} 
my_set = {i * 15 for i in xrange(100)}

# There is only a difference of &#39;:&#39; in both

# 两者的区别在于字典推导中有冒号
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 强制浮点除法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;from __future__ import division 
result = 1/2
# print(result)
# 0.5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 对Python表达式求值&lt;/h2&gt;

&lt;p&gt;我们都知道eval函数，但是我们知道literal_eval函数么？也许很多人都不知道吧。可以用这种操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ast 
my_list = ast.literal_eval(expr)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来代替以下这种操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expr = &quot;[1, 2, 3]&quot;
my_list = eval(expr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我相信对于大多数人来说这种形式是第一次看见，但是实际上这个在Python中已经存在很长时间了。&lt;/p&gt;

&lt;h2&gt;5. 字符串/数列 逆序&lt;/h2&gt;

&lt;p&gt;你可以用以下方法快速逆序排列数列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3,4]
&amp;gt;&amp;gt;&amp;gt; a[::-1]
[4, 3, 2, 1]
 
# This creates a new reversed list. 
# If you want to reverse a list in place you can do:
 
a.reverse()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这总方式也同样适用于字符串的逆序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; foo = &quot;yasoob&quot;
&amp;gt;&amp;gt;&amp;gt; foo[::-1]
&#39;boosay&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;6. 三元运算&lt;/h2&gt;

&lt;p&gt;三元运算是if-else 语句的快捷操作，也被称为条件运算。这里有几个例子可以供你参考，它们可以让你的代码更加紧凑，更加美观。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[on_true] if [expression] else [on_false]
x, y = 50, 25
small = x if x &amp;lt; y else y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;7. Python里面如何拷贝一个对象&lt;/h2&gt;

&lt;p&gt;标准库中的copy模块提供了两个方法来实现拷贝.一个方法是copy,它返回和参数包含内容一样的对象.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy
new_list = copy.copy(existing_list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些时候,你希望对象中的属性也被复制,可以使用deepcopy方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy
new_list_of_dicts = copy.deepcopy(existing_list_of_dicts)

copy(x)
Shallow copy operation on arbitrary Python objects.
 
deepcopy(x, memo=None, _nil=[])
Deep copy operation on arbitrary Python objects.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;8. python中如何判断对象相等&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;首先是C#中字符串的==和equal方法。

“==” :
对于内置值类型而言， == 判断两个内存值是否相等。
对于用户自定义的值类型而言(Struct)， == 需要重载，否则不能使用。
对于引用类型而言，默认是同一引用才返回true，但是系统重载了很多引用类型的 == （比如下文提到的string），所以c#中引用类型的比较并不建议使用 ==。

“equals” :
对于值类型而言， 内存相等才返回true。
对于引用类型而言，指向同一个引用才算相等。
但是比较特殊的是字符串String,是一个特殊的引用型类型，在C#语言中，重载了string的equals()方法，使string对象用起来就像是值类型一样。

python中的 ==

python中的对象包含三要素:id, type, value
id 用来标识唯一一个对象，type标识对象的类型，value用来设置对象的值。
is 判断是否是一个对象，使用id来判断的。
== 是判断a对象的值是否是b对象的值，默认调用它的__eq__方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;9. 命名技巧&lt;/h2&gt;

&lt;p&gt;今天阅读代码，发现一个不错的函数命名方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def request(_argv):  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是把所有的参数前面都加上_下划线，这样你在函数体中，一眼就可以看出那些是局部变量，那些是作为参数传入的，类似把全局变量前面加上g。&lt;/p&gt;

&lt;h2&gt;10. 开发者工具集锦&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;pydoc： 模块可以根据源代码中的docstrings为任何可导入模块生成格式良好的文档。&lt;/li&gt;
&lt;li&gt;doctest模块：该模块可以从源代码或独立文件的例子中抽取出测试用例。&lt;/li&gt;
&lt;li&gt;unittest模块：该模块是一个全功能的自动化测试框架，该框架提供了对测试准备(test fixtures), 预定义测试集(predefined test suite)以及测试发现(test discovery)的支持。&lt;/li&gt;
&lt;li&gt;trace：模块可以监控Python执行程序的方式，同时生成一个报表来显示程序的每一行执行的次数。这些信息可以用来发现未被自动化测试集所覆盖的程序执行路径，也可以用来研究程序调用图，进而发现模块之间的依赖关系。编写并执行测试可以发现绝大多数程序中的问题，Python使得debug工作变得更加简单，这是因为在大部分情况下，Python都能够将未被处理的错误打印到控制台中，我们称这些错误信息为traceback。如果程序不是在文本控制台中运行的，traceback也能够将错误信息输出到日志文件或是消息对话框中。当标准的traceback无法提供足够的信息时，可以使用cgitb 模块来查看各级栈和源代码上下文中的详细信息，比如局部变量。cgitb模块还能够将这些跟踪信息以HTML的形式输出，用来报告web应用中的错误。&lt;/li&gt;
&lt;li&gt;pdb：该模块可以显示出程序在错误产生时的执行路径，同时可以动态地调整对象和代码进行调试。&lt;/li&gt;
&lt;li&gt;profile, timeit: 开发者可以使用profile以及timit模块来测试程序的速度，找出程序中到底是哪里很慢，进而对这部分代码独立出来进行调优的工作。&lt;/li&gt;
&lt;li&gt;compileall: Python程序是通过解释器执行的，解释器的输入是原有程序的字节码编译版本。这个字节码编译版本可以在程序执行时动态地生成，也可以在程序打包的时候就生成。compileall模块可以处理程序打包的事宜，它暴露出了打包相关的接口，该接口能够被安装程序和打包工具用来生成包含模块字节码的文件。同时，在开发环境中，compileall模块也可以用来验证源文件是否包含了语法错误。&lt;/li&gt;
&lt;li&gt;YAPF：Google开源的Python代码格式化工具。&lt;/li&gt;
&lt;li&gt;iPDB: iPDB是一个极好的工具，我已经用它查出了很多匪夷所思的bug。pip install ipdb 安装该工具，然后在你的代码中import ipdb; ipdb.set_trace()，然后你会在你的程序运行时，获得一个很好的交互式提示。它每次执行程序的一行并且检查变量。&lt;/li&gt;
&lt;li&gt;pycallgraph: 在一些场合，我使用pycallgraph来追踪性能问题。它可以创建函数调用时间和次数的图表。&lt;/li&gt;
&lt;li&gt;objgraph: objgraph对于查找内存泄露非常有用。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;../images/pycallgraph.jpg&quot; alt=&quot;pycallgraph.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;11. Python代码微优化之加快查找&lt;/h2&gt;

&lt;p&gt;collections.OrderedDict类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
    if key not in self:
        root = self.__root
        last = root[0]
        last[1] = root[0] = self.__map[key] = [last, root, key]
    return dict_setitem(self, key, value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意最后一个参数：dict_setitem=dict.&lt;strong&gt;setitem&lt;/strong&gt;。如果你仔细想就会感觉有道理。将值关联到键上，你只需要给&lt;strong&gt;setitem&lt;/strong&gt;传递三个参数：要设置的键，与键关联的值，传递给内建dict类的&lt;strong&gt;setitem&lt;/strong&gt;类方法。等会，好吧，也许最后一个参数没什么意义。
最后一个参数其实是将一个函数绑定到局部作用域中的一个函数上。具体是通过将dict.&lt;strong&gt;setitem&lt;/strong&gt;赋值为参数的默认值。这里还有另一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def not_list_or_dict(value):
  return not (isinstance(value, dict) or isinstance(value, list))
 
def not_list_or_dict(value, _isinstance=isinstance, _dict=dict, _list=list):
  return not (_isinstance(value, _dict) or _isinstance(value, _list))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们做同样的事情，把本来将会在内建命名空间中的对象绑定到局部作用域中去。因此，python将会使用LOCAL_FAST而不是LOAD_GLOBAL（全局查找）。那么这到底有多快呢？我们做个简单的测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -m timeit -s &#39;def not_list_or_dict(value): return not (isinstance(value, dict) or isinstance(value, list))&#39; &#39;not_list_or_dict(50)&#39;
1000000 loops, best of 3: 0.48 usec per loop
$ python -m timeit -s &#39;def not_list_or_dict(value, _isinstance=isinstance, _dict=dict, _list=list): return not (_isinstance(value, _dict) or _isinstance(value, _list))&#39; &#39;not_list_or_dict(50)&#39;
1000000 loops, best of 3: 0.423 usec per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，大概有11.9%的提升 [2]。比我在文章开始处承诺的5%还多！&lt;/p&gt;

&lt;h2&gt;12. 包管理&lt;/h2&gt;

&lt;p&gt;Python世界最棒的地方之一，就是大量的第三方程序包。同样，管理这些包也非常容易。按照惯例，会在 requirements.txt 文件中列出项目所需要的包。每个包占一行，通常还包含版本号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pelican==3.3
Markdown
pelican-extended-sitemap==1.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;13. Python函数参数默认值的陷阱和原理深究&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Python 2.7.9 (default, Dec 19 2014, 06:05:48)
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.56)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; def generate_new_list_with(my_list=[], element=None):
...     my_list.append(element)
...     return my_list
...
&amp;gt;&amp;gt;&amp;gt; list_1 = generate_new_list_with(element=1)
&amp;gt;&amp;gt;&amp;gt; list_1
[1]
&amp;gt;&amp;gt;&amp;gt; list_2 = generate_new_list_with(element=2)
&amp;gt;&amp;gt;&amp;gt; list_2
[1, 2]
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见代码运行结果并不和我们预期的一样。list_2在函数的第二次调用时并没有得到一个新的list并填入2，而是在第一次调用结果的基础上append了一个2。为什么会发生这样在其他编程语言中简直就是设计bug一样的问题呢？ &lt;br/&gt;
可见如果参数默认值是在函数编译compile阶段就已经被确定。之后所有的函数调用时，如果参数不显示的给予赋值，那么所谓的参数默认值不过是一个指向那个在compile阶段就已经存在的对象的指针。如果调用函数时，没有显示指定传入参数值得话。那么所有这种情况下的该参数都会作为编译时创建的那个对象的一种别名存在。如果参数的默认值是一个不可变(Imuttable)数值，那么在函数体内如果修改了该参数，那么参数就会重新指向另一个新的不可变值。而如果参数默认值是和本文最开始的举例一样，是一个可变对象(Muttable)，那么情况就比较糟糕了。所有函数体内对于该参数的修改，实际上都是对compile阶段就已经确定的那个对象的修改。&lt;/p&gt;

&lt;h2&gt;14. 单下划线（_）&lt;/h2&gt;

&lt;p&gt;1、在解释器中：在这种情况下，“_”代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; _ Traceback (most recent call last): 
File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; 
NameError: name &#39;_&#39; is not defined 
&amp;gt;&amp;gt;&amp;gt; 42
&amp;gt;&amp;gt;&amp;gt; _ 
42
&amp;gt;&amp;gt;&amp;gt; &#39;alright!&#39; if _ else &#39;:(&#39;
&#39;alright!&#39;
&amp;gt;&amp;gt;&amp;gt; _ 
&#39;alright!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、作为一个名称：这与上面一点稍微有些联系，此时“&lt;em&gt;”作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。例如，下面的例子中，你可能对循环计数中的实际值并不感兴趣，此时就可以使用“&lt;/em&gt;”。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = 42
for _ in range(n): 
    do_something()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、国际化：也许你也曾看到”_“会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。例如，在Django文档“转换”章节中，你将能看到如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.utils.translation import ugettext as _ 
from django.http import HttpResponse 
def my_view(request): 
    output = _(&quot;Welcome to my site.&quot;) 
    return HttpResponse(output)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现，场景二和场景三中的使用方法可能会相互冲突，所以我们需要避免在使用“&lt;em&gt;”作为国际化查找转换功能的代码块中同时使用“&lt;/em&gt;”作为临时名称。&lt;/p&gt;

&lt;h2&gt;15. 名称前的单下划线（如：_shahriar）&lt;/h2&gt;

&lt;p&gt;程序员使用名称前的单下划线，用于指定该名称属性为“私有”。这有点类似于惯例，为了使其他人（或你自己）使用这些代码时将会知道以“_”开头的名称只供内部使用。正如Python文档中所述：&lt;/p&gt;

&lt;p&gt;以下划线 &lt;em&gt;_ 为前缀的名称（如&lt;/em&gt;pam）应该被视为API中非公开的部分（不管是函数、方法还是数据成员）。此时，应该将它们看作是一种实现细节，在修改它们时无需对外部通知。&lt;/p&gt;

&lt;p&gt;正如上面所说，这确实类似一种惯例，因为它对解释器来说确实有一定的意义，如果你写了代码 &lt;code&gt;from &amp;lt;模块/包名&amp;gt; import *&lt;/code&gt;，那么以 _ 开头的名称都不会被导入，除非模块或包中的 &lt;code&gt;__all__&lt;/code&gt; 列表显式地包含了它们。了解更多请查看 &lt;code&gt;Importing * in Python&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;16. 名称前的双下划线（如：__shahriar）&lt;/h2&gt;

&lt;p&gt;名称（具体为一个方法名）前双下划线 _ 的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，&lt;strong&gt;spam 这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被 正如所预料的，“_internal_use”并未改变，而“&lt;/strong&gt;method_name”却被变成了“_ClassName&lt;strong&gt;method_name”。此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法“&lt;/strong&gt;method_name”。spam 这种形式原文取代，在这里 classname 是去掉前导下划线的当前类名。例如下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class A(object): 
... def _internal_use(self): 
... pass
... def __method_name(self): 
... pass
... 
&amp;gt;&amp;gt;&amp;gt; dir(A()) 
[&#39;_A__method_name&#39;, ..., &#39;_internal_use&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如所预料的，“&lt;em&gt;internal_use”并未改变，而“__method_name”却被变成了“&lt;/em&gt;ClassName&lt;strong&gt;method_name”。此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法“&lt;/strong&gt;method_name”。&lt;/p&gt;

&lt;h2&gt;17. 名称前后的双下划线（如：&lt;strong&gt;init&lt;/strong&gt;）&lt;/h2&gt;

&lt;p&gt;这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写“&lt;strong&gt;init&lt;/strong&gt;”方法。&lt;/p&gt;

&lt;p&gt;虽然你也可以编写自己的特殊方法名，但不要这样做。&lt;/p&gt;

&lt;h2&gt;17. 隐藏特性 1，函数unpack&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;def foo(x, y):
    print x, y

alist = [1, 2]
adict = {&#39;x&#39;: 1, &#39;y&#39;: 2}

foo(*alist)  # 1, 2
foo(**adict)  # 1, 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;18. 隐藏特性 2， 链式比较操作符&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; 1 &amp;lt; x &amp;lt; 5
True
&amp;gt;&amp;gt;&amp;gt; 4 &amp;gt; x &amp;gt;=3
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;19. 隐藏特性 3，函数的默认参数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def foo(x=[]):
...     x.append(1)
...     print x
...
&amp;gt;&amp;gt;&amp;gt; foo()
[1]
&amp;gt;&amp;gt;&amp;gt; foo()
[1, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更安全的做法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def foo(x=None):
...     if x is None:
...         x = []
...     x.append(1)
...     print x
...
&amp;gt;&amp;gt;&amp;gt; foo()
[1]
&amp;gt;&amp;gt;&amp;gt; foo()
[1]
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;20. 隐藏特性 4，字典的get方法&lt;/h2&gt;

&lt;h2&gt;21. 隐藏特性 5，带关键字的格式化&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print &quot;Hello %(name)s !&quot; % {&#39;name&#39;: &#39;James&#39;}
Hello James !
&amp;gt;&amp;gt;&amp;gt; print &quot;I am years %(age)i years old&quot; % {&#39;age&#39;: 18}
I am years 18 years old
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新些的格式化:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print &quot;Hello {name} !&quot;.format(name=&quot;James&quot;)
Hello James !
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;22. 隐藏特性 6，切片操作的步长参数&lt;/h2&gt;

&lt;p&gt;可以用步长 -1 来反转链表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; a[::2]
[1, 3, 5]
&amp;gt;&amp;gt;&amp;gt; a[::-1]
[5, 4, 3, 2, 1]
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;23. 隐藏特性 7，嵌套列表推导式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[(i, j) for i in range(3) for j in range(i)]
[(1, 0), (2, 0), (2, 1)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列表推导构造permutation：&lt;br/&gt;
可以用 itertools.permutations 来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In[47]: a = &#39;abcd&#39;

In[48]: [i+j+k for i in a for j in a.replace(i,&#39;&#39;) for k in a.replace(i,&#39;&#39;).replace(j,&#39;&#39;)]
Out[48]: 
[&#39;abc&#39;,
 &#39;abd&#39;,
 &#39;acb&#39;,
 &#39;acd&#39;,
 &#39;adb&#39;,
 &#39;adc&#39;,
 &#39;bac&#39;,
 &#39;bad&#39;,
 &#39;bca&#39;,
 &#39;bcd&#39;,
 &#39;bda&#39;,
 &#39;bdc&#39;,
 &#39;cab&#39;,
 &#39;cad&#39;,
 &#39;cba&#39;,
 &#39;cbd&#39;,
 &#39;cda&#39;,
 &#39;cdb&#39;,
 &#39;dab&#39;,
 &#39;dac&#39;,
 &#39;dba&#39;,
 &#39;dbc&#39;,
 &#39;dca&#39;,
 &#39;dcb&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;24. 隐藏特性 8，print 重定向输出到文件&lt;/h2&gt;

&lt;p&gt;注意打开的模式: &quot;w+&quot; 而不能 &quot;w&quot; , 当然 &quot;a&quot; 是可以的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print &amp;gt;&amp;gt; open(&quot;somefile&quot;, &quot;w+&quot;), &quot;Hello World&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;25. 隐藏特性 9， Python3中的元组unpack&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a, b, *rest = range(10)
&amp;gt;&amp;gt;&amp;gt; a
0
&amp;gt;&amp;gt;&amp;gt; b
1
&amp;gt;&amp;gt;&amp;gt; rest
[2, 3, 4, 5, 6, 7, 8, 9]
&amp;gt;&amp;gt;&amp;gt;

&amp;gt;&amp;gt;&amp;gt; first, second, *rest, last = range(10)
&amp;gt;&amp;gt;&amp;gt; first
0
&amp;gt;&amp;gt;&amp;gt; second
1
&amp;gt;&amp;gt;&amp;gt; last
9
&amp;gt;&amp;gt;&amp;gt; rest
[2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;26. 隐藏特性 10，pow的第三个参数&lt;/h2&gt;

&lt;p&gt;其实第三个参数是来求模的: pow(x, y, z) == (x ** y) % z，注意，内置的 pow 和 math.pow 并不是一个函数，后者只接受2个参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; pow(4, 2, 2)
0
&amp;gt;&amp;gt;&amp;gt; pow(4, 2, 3)
1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;27. 隐藏特性 11，enumerate还有第二个参数¶&lt;/h2&gt;

&lt;p&gt;enumerate 很赞，可以给我们索引和序列值的对, 但是它还有第二个参数，这个参数用来: 指明索引的起始值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lst = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&amp;gt;&amp;gt;&amp;gt; list(enumerate(lst, 1))
[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;28. 隐藏特性 12，显式的声明一个集合&lt;/h2&gt;

&lt;p&gt;在Python 2.7 之后可以这么声明一个集合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; {1,2,3}
set([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;29. 隐藏特性 13，用切片来删除序列的某一段&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6, 7]
&amp;gt;&amp;gt;&amp;gt; a[1:4] = []
&amp;gt;&amp;gt;&amp;gt; a
[1, 5, 6, 7]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然用 del a[1:4] 也是可以的，去除偶数项(偶数索引的):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [0, 1, 2, 3, 4, 5, 6, 7]
&amp;gt;&amp;gt;&amp;gt; del a[::2]
&amp;gt;&amp;gt;&amp;gt; a
[1, 3, 5, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;30. 隐藏特性 14，isinstance可以接收一个元组&lt;/h2&gt;

&lt;p&gt;这个真的鲜为人知, 我们可以用 isinstance(x, (float, int)) 来判断 x 是不是数，也就是那个元组里面是 或 的关系，只要是其中一个的实例就返回 True。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(1, (float, int))
True
&amp;gt;&amp;gt;&amp;gt; isinstance(1.3, (float, int))
True
&amp;gt;&amp;gt;&amp;gt; isinstance(&quot;1.3&quot;, (float, int))
False
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;31. 让关键代码依赖于外部包&lt;/h2&gt;

&lt;p&gt;虽然Python让许多编程任务变得容易，但它可能并不总能为紧急的任务提供最佳性能。你可以为紧急的任务使用C、C++或机器语言编写的外部包，这样可以提高应用程序的性能。这些包都是不能跨平台的，这意味着你需要根据你正在使用的平台，寻找合适的包。简而言之，这个方案放弃了一些应用程序的可移植性，以换取只有在特定主机上直接编程才能获得的程序性能。这里有一些你应该考虑加入到你的“性能兵工厂”的包：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cython&lt;/li&gt;
&lt;li&gt;PyInlne&lt;/li&gt;
&lt;li&gt;PyPy&lt;/li&gt;
&lt;li&gt;Pyrex&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些包以不同的方式提高性能。例如，Pyrex能够扩展Python所能做的事情，例如使用C的数据类型来让内存任务更加有效或直接。PyInIne让你在Python应用程序中直接使用C代码。程序中的内联代码单独编译，但它在利用C语言所能提供的效率的同时，也让所有的代码都在同一个地方。&lt;/p&gt;

&lt;h2&gt;32. 排序时使用键（key）&lt;/h2&gt;

&lt;p&gt;有很多老的Python排序代码，它们在你创建一个自定义的排序时花费你的时间，但在运行时确实能加速执行排序过程。元素排序的最好方法是尽可能使用键（key）和默认的sort()排序方法。例如，考虑下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import operator
somelist = [(1, 5, 8), (6, 2, 4), (9, 7, 5)]
somelist.sort(key=operator.itemgetter(0))
somelist
#Output = [(1, 5, 8), (6, 2, 4), (9, 7, 5)]
somelist.sort(key=operator.itemgetter(1))
somelist
#Output = [(6, 2, 4), (1, 5, 8), (9, 7, 5)]
somelist.sort(key=operator.itemgetter(2))
somelist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个实例中，根据你选择的作为key参数部分的索引，数组进行了排序。类似于利用数字进行排序，这种方法同样适用于利用字符串排序。&lt;/p&gt;

&lt;h2&gt;33. 优化循环&lt;/h2&gt;

&lt;p&gt;每种编程语言都会强调需要优化循环。当使用Python的时候，你可以依靠大量的技巧使得循环运行得更快。然而，开发者经常漏掉的一个方法是：避免在一个循环中使用点操作。例如，考虑下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lowerlist = [&#39;this&#39;, &#39;is&#39;, &#39;lowercase&#39;]
upper = str.upper
upperlist = []
append = upperlist.append
for word in lowerlist:
    append(upper(word))
    print(upperlist)
    #Output = [&#39;THIS&#39;, &#39;IS&#39;, &#39;LOWERCASE&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一次你调用方法str.upper，Python都会求该方法的值。然而，如果你用一个变量代替求得的值，值就变成了已知的，Python就可以更快地执行任务。优化循环的关键，是要减少Python在循环内部执行的工作量，因为Python原生的解释器在那种情况下，真的会减缓执行的速度。&lt;/p&gt;

&lt;p&gt;（注意：优化循环的方法有很多，这只是其中的一个。例如，许多程序员都会说，列表推导是在循环中提高执行速度的最好方式。这里的关键是，优化循环是程序取得更高的执行速度的更好方式之一。）&lt;/p&gt;

&lt;h2&gt;34. 尝试多种编码方法&lt;/h2&gt;

&lt;p&gt;如果每次你创建一个应用程序都是用相同的编码方法，几乎肯定会导致一些你的应用程序比它能够达到的运行效率慢的情况。作为分析过程的一部分，你可以尝试一些实验。例如，在一个字典中管理一些元素，你可以采用安全的方法确定元素是否已经存在并更新，或者你可以直接添加元素，然后作为异常处理该元素不存在情况。考虑第一个编码的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = 16
myDict = {}
for i in range(0, n):
    char = &#39;abcd&#39;[i%4]
    if char not in myDict:
        myDict[char] = 0
        myDict[char] += 1
        print(myDict)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码通常会在myDict开始为空时运行得更快。然而，当mydict通常被数据填充（或者至少大部分被充填）时，另一种方法效果更好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = 16
myDict = {}
for i in range(0, n):
    char = &#39;abcd&#39;[i%4]
    try:
        myDict[char] += 1
    except KeyError:
        myDict[char] = 1
    print(myDict)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两种情况下具有相同的输出：{‘d’: 4, ‘c’: 4, ‘b’: 4, ‘a’: 4}。唯一的不同是这个输出是如何得到的。跳出固定的思维模式，创造新的编码技巧，能够帮助你利用你的应用程序获得更快的结果。&lt;/p&gt;

&lt;h2&gt;35. 使用列表推导式&lt;/h2&gt;

&lt;p&gt;一个列表推导式包含以下几个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个输入序列&lt;/li&gt;
&lt;li&gt;一个表示输入序列成员的变量&lt;/li&gt;
&lt;li&gt;一个可选的断言表达式&lt;/li&gt;
&lt;li&gt;一个将输入序列中满足断言表达式的成员变换成输出列表成员的输出表达式&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = []
 
for number in num:
    if number &amp;gt; 0:
        filtered_and_squared.append(number ** 2)
print filtered_and_squared
 
# [1, 16, 100, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果使用filter、lambda和map函数，则能够将代码大大简化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = map(lambda x: x ** 2, filter(lambda x: x &amp;gt; 0, num))
print filtered_and_squared
 
# [1, 16, 100, 4, 9]

## 更简化的一种写法    
num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = [ x**2 for x in num if x &amp;gt; 0]
print filtered_and_squared
 
# [1, 16, 100, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;../images/comprehension.jpg&quot; alt=&quot;comprehension.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;列表推导也可能会有一些负面效应，那就是整个列表必须一次性加载于内存之中，这对上面举的例子而言不是问题，甚至扩大若干倍之后也都不是问题。但是总会达到极限，内存总会被用完。&lt;/p&gt;

&lt;p&gt;针对上面的问题，生成器(Generator)能够很好的解决。生成器表达式不会一次将整个列表加载到内存之中，而是生成一个生成器对象(Generator objector)，所以一次只加载一个列表元素。&lt;/p&gt;

&lt;p&gt;生成器表达式同列表推导式有着几乎相同的语法结构，区别在于生成器表达式是被圆括号包围，而不是方括号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = ( x**2 for x in num if x &amp;gt; 0 )
print filtered_and_squared
 
# &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x00583E18&amp;gt;
 
for item in filtered_and_squared:
    print item
 
# 1, 16, 100 4,9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这比列表推导效率稍微提高一些，让我们再一次改造一下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;num = [1, 4, -5, 10, -7, 2, 3, -1]
 
def square_generator(optional_parameter):
    return (x ** 2 for x in num if x &amp;gt; optional_parameter)
 
print square_generator(0)
# &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x004E6418&amp;gt;
 
# Option I
for k in square_generator(0):
    print k
# 1, 16, 100, 4, 9
 
# Option II
g = list(square_generator(0))
print g
# [1, 16, 100, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除非特殊的原因，应该经常在代码中使用生成器表达式。但除非是面对非常大的列表，否则是不会看出明显区别的。
再来看一个通过两阶列表推导式遍历目录的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os
def tree(top):
    for path, names, fnames in os.walk(top):
        for fname in fnames:
            yield os.path.join(path, fname)
 
for name in tree(&#39;C:\Users\XXX\Downloads\Test&#39;):
    print name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;36. 装饰器(Decorators)&lt;/h2&gt;

&lt;p&gt;装饰器为我们提供了一个增加已有函数或类的功能的有效方法。听起来是不是很像Java中的面向切面编程(Aspect-Oriented Programming)概念？两者都很简单，并且装饰器有着更为强大的功能。举个例子，假定你希望在一个函数的入口和退出点做一些特别的操作(比如一些安全、追踪以及锁定等操作)就可以使用装饰器。&lt;/p&gt;

&lt;p&gt;装饰器是一个包装了另一个函数的特殊函数：主函数被调用，并且其返回值将会被传给装饰器，接下来装饰器将返回一个包装了主函数的替代函数，程序的其他部分看到的将是这个包装函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time
from functools import wraps
 
def timethis(func):
    &#39;&#39;&#39;
    Decorator that reports the execution time.
    &#39;&#39;&#39;
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end-start)
        return result
    return wrapper
 
@timethis
def countdown(n):
    while n &amp;gt; 0:
        n -= 1
 
countdown(100000)
 
# (&#39;countdown&#39;, 0.006999969482421875)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;37. 上下文管理库(ContextLib)&lt;/h2&gt;

&lt;p&gt;contextlib模块包含了与上下文管理器和with声明相关的工具。通常如果你想写一个上下文管理器，则你需要定义一个类包含&lt;strong&gt;enter&lt;/strong&gt;方法以及&lt;strong&gt;exit&lt;/strong&gt;方法，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time
class demo:
    def __init__(self, label):
        self.label = label
 
    def __enter__(self):
        self.start = time.time()
 
    def __exit__(self, exc_ty, exc_val, exc_tb):
        end = time.time()
        print(&#39;{}: {}&#39;.format(self.label, end - self.start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的例子在此：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time
 
class demo:
    def __init__(self, label):
        self.label = label
 
    def __enter__(self):
        self.start = time.time()
 
    def __exit__(self, exc_ty, exc_val, exc_tb):
        end = time.time()
        print(&#39;{}: {}&#39;.format(self.label, end - self.start))
 
with demo(&#39;counting&#39;):
    n = 10000000
    while n &amp;gt; 0:
        n -= 1
 
# counting: 1.36000013351
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上下文管理器被with声明所激活，这个API涉及到两个方法。
1. &lt;strong&gt;enter&lt;/strong&gt;方法，当执行流进入with代码块时，&lt;strong&gt;enter&lt;/strong&gt;方法将执行。并且它将返回一个可供上下文使用的对象。
2. 当执行流离开with代码块时，&lt;strong&gt;exit&lt;/strong&gt;方法被调用，它将清理被使用的资源。&lt;/p&gt;

&lt;p&gt;利用@contextmanager装饰器改写上面那个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from contextlib import contextmanager
import time
 
@contextmanager
def demo(label):
    start = time.time()
    try:
        yield
    finally:
        end = time.time()
        print(&#39;{}: {}&#39;.format(label, end - start))
 
with demo(&#39;counting&#39;):
    n = 10000000
    while n &amp;gt; 0:
        n -= 1
 
# counting: 1.32399988174
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看上面这个例子，函数中yield之前的所有代码都类似于上下文管理器中&lt;strong&gt;enter&lt;/strong&gt;方法的内容。而yield之后的所有代码都如&lt;strong&gt;exit&lt;/strong&gt;方法的内容。如果执行过程中发生了异常，则会在yield语句触发。&lt;/p&gt;

&lt;h2&gt;38. 描述器(Descriptors)&lt;/h2&gt;

&lt;p&gt;描述器决定了对象属性是如何被访问的。描述器的作用是定制当你想引用一个属性时所发生的操作。&lt;/p&gt;

&lt;p&gt;构建描述器的方法是至少定义以下三个方法中的一个。需要注意，下文中的instance是包含被访问属性的对象实例，而owner则是被描述器修辞的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;get&lt;/strong&gt;(self, instance, owner) – 这个方法是当属性被通过(value = obj.attr)的方式获取时调用，这个方法的返回值将被赋给请求此属性值的代码部分。
&lt;strong&gt;set&lt;/strong&gt;(self, instance, value) – 这个方法是当希望设置属性的值(obj.attr = ‘value’)时被调用，该方法不会返回任何值。
&lt;strong&gt;delete&lt;/strong&gt;(self, instance) – 当从一个对象中删除一个属性时(del obj.attr)，调用此方法。
译者注：对于instance和owner的理解，考虑以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Celsius(object):
    def __init__(self, value=0.0):
        self.value = float(value)
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        self.value = float(value)
 
class Temperature(object):
    celsius = Celsius()
 
temp=Temperature()
temp.celsius #calls Celsius.__get__
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;39. Zipping and unzipping lists and iterables&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&amp;gt;&amp;gt;&amp;gt; z = zip(a, b)
&amp;gt;&amp;gt;&amp;gt; z
[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]
&amp;gt;&amp;gt;&amp;gt; zip(*z)
[(1, 2, 3), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;40. Grouping adjacent list items using zip&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; # Using iterators
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*([iter(a)] * k))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]


&amp;gt;&amp;gt;&amp;gt; # Using slices
&amp;gt;&amp;gt;&amp;gt; from itertools import islice
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*(islice(a, i, None, k) for i in range(k)))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;41. Sliding windows (n-grams) using zip and iterators&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import islice
&amp;gt;&amp;gt;&amp;gt; def n_grams(a, n):
...     z = (islice(a, i, None) for i in range(n))
...     return zip(*z)
...
&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6]
&amp;gt;&amp;gt;&amp;gt; n_grams(a, 3)
[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; n_grams(a, 2)
[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; n_grams(a, 4)
[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;42. Inverting a dictionary using zip&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m.items()
[(&#39;a&#39;, 1), (&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]
&amp;gt;&amp;gt;&amp;gt; zip(m.values(), m.keys())
[(1, &#39;a&#39;), (3, &#39;c&#39;), (2, &#39;b&#39;), (4, &#39;d&#39;)]
&amp;gt;&amp;gt;&amp;gt; mi = dict(zip(m.values(), m.keys()))
&amp;gt;&amp;gt;&amp;gt; mi
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;43. Flattening lists&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [[1, 2], [3, 4], [5, 6]]
&amp;gt;&amp;gt;&amp;gt; list(itertools.chain.from_iterable(a))
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; sum(a, [])
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; [x for l in a for x in l]
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; [x for l1 in a for l2 in l1 for x in l2]
[1, 2, 3, 4, 5, 6, 7, 8]

&amp;gt;&amp;gt;&amp;gt; a = [1, 2, [3, 4], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]
&amp;gt;&amp;gt;&amp;gt; flatten(a)
[1, 2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;44. Dictionary comprehensions&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {x: x ** 2 for x in range(5)}
&amp;gt;&amp;gt;&amp;gt; m
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

&amp;gt;&amp;gt;&amp;gt; m = {x: &#39;A&#39; + str(x) for x in range(10)}
&amp;gt;&amp;gt;&amp;gt; m
{0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;45. 常犯错误，滥用表达式作为函数参数默认值&lt;/h2&gt;

&lt;p&gt;Python允许开发者指定一个默认值给函数参数，虽然这是该语言的一个特征，但当参数可变时，很容易导致混乱，例如，下面这段函数定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def foo(bar=[]):        # bar is optional and defaults to [] if not specified
...    bar.append(&quot;baz&quot;)    # but this line could be problematic, as we&#39;ll see...
...    return bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面这段代码里，一旦重复调用foo()函数（没有指定一个bar参数），那么将一直返回&#39;bar&#39;，因为没有指定参数，那么foo()每次被调用的时候，都会赋予[]。下面来看看，这样做的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;]
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;, &quot;baz&quot;]
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;, &quot;baz&quot;, &quot;baz&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def foo(bar=None):
...    if bar is None:      # or if not bar:
...        bar = []
...    bar.append(&quot;baz&quot;)
...    return bar
...
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;]
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;]
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;46. 误解Python规则范围&lt;/h2&gt;

&lt;p&gt;Python的作用域解析是基于LEGB规则，分别是Local、Enclosing、Global、Built-in。实际上，这种解析方法也有一些玄机，看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = 10
&amp;gt;&amp;gt;&amp;gt; def foo():
...     x += 1
...     print x
...
&amp;gt;&amp;gt;&amp;gt; foo()
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in foo
UnboundLocalError: local variable &#39;x&#39; referenced before assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;许多人会感动惊讶，当他们在工作的函数体里添加一个参数语句，会在先前工作的代码里报UnboundLocalError错误（ 点击这里查看更详细描述）。
在使用列表时，开发者是很容易犯这种错误的，看看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lst = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; def foo1():
...     lst.append(5)   # This works ok...
...
&amp;gt;&amp;gt;&amp;gt; foo1()
&amp;gt;&amp;gt;&amp;gt; lst
[1, 2, 3, 5]

&amp;gt;&amp;gt;&amp;gt; lst = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; def foo2():
...     lst += [5]      # ... but this bombs!
...
&amp;gt;&amp;gt;&amp;gt; foo2()
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in foo
UnboundLocalError: local variable &#39;lst&#39; referenced before assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么foo2失败而foo1运行正常？
答案与前面那个例子是一样的，但又有一些微妙之处。foo1没有赋值给lst，而foo2赋值了。lst += [5]实际上就是lst = lst + [5]，试图给lst赋值（因此，假设Python是在局部作用域里）。然而，我们正在寻找指定给lst的值是基于lst本身，其实尚未确定。&lt;/p&gt;

&lt;h2&gt;47. 修改遍历列表&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; odd = lambda x : bool(x % 2)
&amp;gt;&amp;gt;&amp;gt; numbers = [n for n in range(10)]
&amp;gt;&amp;gt;&amp;gt; for i in range(len(numbers)):
...     if odd(numbers[i]):
...         del numbers[i]  # BAD: Deleting item from a list while iterating over it
...
Traceback (most recent call last):
      File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在遍历的时候，对列表进行删除操作，这是很低级的错误。稍微有点经验的人都不会犯。
对上面的代码进行修改，正确地执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; odd = lambda x : bool(x % 2)
&amp;gt;&amp;gt;&amp;gt; numbers = [n for n in range(10)]
&amp;gt;&amp;gt;&amp;gt; numbers[:] = [n for n in numbers if not odd(n)]  # ahh, the beauty of it all
&amp;gt;&amp;gt;&amp;gt; numbers
[0, 2, 4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;48. 合理使用copy与deepcopy&lt;/h2&gt;

&lt;p&gt;对于dict和list等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用copy包里的copy和deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在ipython中运行）&lt;/p&gt;

&lt;p&gt;timeit后面的-n表示运行的次数，后两行对应的是两个timeit的输出，下同。由此可见后者慢一个数量级。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy
a = range(100000)
%timeit -n 10 copy.copy(a) # 运行10次 copy.copy(a)
%timeit -n 10 copy.deepcopy(a)
10 loops, best of 3: 1.55 ms per loop
10 loops, best of 3: 151 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;49. 合理使用生成器（generator）和yield&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%timeit -n 100 a = (i for i in range(100000))
%timeit -n 100 b = [i for i in range(100000)]
100 loops, best of 3: 1.54 ms per loop
100 loops, best of 3: 4.56 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用()得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如set(i for i in range(100000))会比set([i for i in range(100000)])快。&lt;/p&gt;

&lt;p&gt;但是对于需要循环遍历的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%timeit -n 10 for x in (i for i in range(100000)): pass
%timeit -n 10 for x in [i for i in range(100000)]: pass
10 loops, best of 3: 6.51 ms per loop
10 loops, best of 3: 5.54 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后者的效率反而更高，但是如果循环里有break,用generator的好处是显而易见的。yield也是用于创建generator：&lt;/p&gt;

&lt;h2&gt;50. 使用级联比较x &amp;lt; y &amp;lt; z&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;x, y, z = 1,2,3
%timeit -n 1000000 if x &amp;lt; y &amp;lt; z:pass
%timeit -n 1000000 if x &amp;lt; y and y &amp;lt; z:pass
1000000 loops, best of 3: 101 ns per loop
1000000 loops, best of 3: 121 ns per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x &amp;lt; y &amp;lt; z效率略高，而且可读性更好。&lt;/p&gt;

&lt;h2&gt;51. while 1 比 while True 更快&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;def while_1():
    n = 100000
    while 1:
        n -= 1
        if n &amp;lt;= 0: break
def while_true():
    n = 100000
    while True:
        n -= 1
        if n &amp;lt;= 0: break    

m, n = 1000000, 1000000 
%timeit -n 100 while_1()
%timeit -n 100 while_true()
100 loops, best of 3: 3.69 ms per loop
100 loops, best of 3: 5.61 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while 1 比 while true快很多，原因是在python2.x中，True是一个全局变量，而非关键字。&lt;/p&gt;

&lt;h2&gt;52. 使用**而不是pow&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%timeit -n 10000 c = pow(2,20)
%timeit -n 10000 c = 2**20
10000 loops, best of 3: 284 ns per loop
10000 loops, best of 3: 16.9 ns per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;53. 使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import cPickle
import pickle
a = range(10000)
%timeit -n 100 x = cPickle.dumps(a)
%timeit -n 100 x = pickle.dumps(a)
100 loops, best of 3: 1.58 ms per loop
100 loops, best of 3: 17 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由c实现的包，速度快10倍以上！&lt;/p&gt;

&lt;h2&gt;54. 使用最佳的反序列化方式&lt;/h2&gt;

&lt;p&gt;下面比较了eval, cPickle, json方式三种对相应字符串反序列化的效率，可见json比cPickle快近3倍，比eval快20多倍。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import json
import cPickle
a = range(10000)
s1 = str(a)
s2 = cPickle.dumps(a)
s3 = json.dumps(a)
%timeit -n 100 x = eval(s1)
%timeit -n 100 x = cPickle.loads(s2)
%timeit -n 100 x = json.loads(s3)
100 loops, best of 3: 16.8 ms per loop
100 loops, best of 3: 2.02 ms per loop
100 loops, best of 3: 798 µs per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;55. 怎么才算精通python&lt;/h2&gt;

&lt;p&gt;这个问题比较难回答，我是看 &lt;a href=&quot;http://www.zhihu.com/question/19794855&quot;&gt;怎么样才算是精通 Python&lt;/a&gt; 这个知乎问答，按照自己的看法整理了一些观点。不要问我是按什么标准整理的，我只能说，整理的这些点，第一，在我看来都说得不错；第二，我自己都会去按照这些点来看看自己离 “精通” python还有多远。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;熟悉语法以及原声数据结构&lt;/li&gt;
&lt;li&gt;熟悉基本实现中的性能特点，就是知道什么操作会慢&lt;/li&gt;
&lt;li&gt;会使用profile以及基于profile的性能分析工具&lt;/li&gt;
&lt;li&gt;会使用运行时编译和静态编译的工具。pypy，numba，cython，ctypes，original C/C++ extension&lt;/li&gt;
&lt;li&gt;熟悉你所在领域的拓展库，比如我，科学计算方面的库不要太多，numpy衍生出来的一大堆大堆&lt;/li&gt;
&lt;li&gt;了解基本的编译过程，基本的操作系统知识（只要你C、C++学的还行就可以了）&lt;/li&gt;
&lt;li&gt;要想精通python，写的代码首先得pythonic&lt;/li&gt;
&lt;li&gt;研读牛B的开源代码，在这过程中会遇到python的许多高阶用法&lt;/li&gt;
&lt;li&gt;理解装饰器，生成器，描述符，元类&lt;/li&gt;
&lt;li&gt;掌握list comprehension，&lt;/li&gt;
&lt;li&gt;多用内置函数：map，reduce，filter，iter，range，divmod，round，chr，enumerate，all，any，slice，zip+&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;56. python 猴子补丁相关&lt;/h2&gt;

&lt;p&gt;python里有一个很奇妙的monkey patch，中文叫做猴子补丁，是指的是在运行时动态替换某些已加载的模块的实现。第一次了解这个概念是在使用gevent的时候，需要把python自带的socket，os等相关模块的实现改变成异步形式，但同时不改动python的源代码。&lt;/p&gt;

&lt;h2&gt;57. 了解 functools.partial&lt;/h2&gt;

&lt;p&gt;先参考 &lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/9712125&quot;&gt;飘逸的python - 偏函数functools.partial&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81393/&quot;&gt;初学者必知的Python中优雅的用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81233/&quot;&gt;Python基础技术问题总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/58226/&quot;&gt;Python程序员必知必会的开发者工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81210/&quot;&gt;Python代码微优化之加快查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/79197/&quot;&gt;写给已有编程经验的 Python 初学者的总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81187/&quot;&gt;Python中导入模块或包语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cenalulu.github.io/python/default-mutable-arguments/&quot;&gt;Python函数参数默认值的陷阱和原理深究&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81132/&quot;&gt;关于Python日志系统的几点建议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81129/&quot;&gt;详解Python中的下划线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pyzh.readthedocs.org/en/latest/python-hidden-features.html&quot;&gt;9. (译)Python的隐藏特性(StackOverflow)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81035/&quot;&gt;提升 Python 程序性能的 6 个技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/80939/&quot;&gt;在Python中正确使用Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/61171/&quot;&gt;Python高级编程技巧 - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/65218/&quot;&gt;Python中的高级数据结构 - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html&quot;&gt;30 Python Language Features and Tricks You May Not Know About&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.csdn.net/article/2014-05-12/2819716-Top-10-Mistakes-that-Python-Programmers-Make&quot;&gt;Python开发者最常犯的10个错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.toptal.com/python#hiring-guide&quot;&gt;The Insider&#39;s Guide to Python Interviewing - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000000666603&quot;&gt;Python性能优化的20条建议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/51062/&quot;&gt;我常用的 Python 调试工具 - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/19794855&quot;&gt;怎么样才算是精通 Python - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jianfeihit.iteye.com/blog/1835272&quot;&gt;python内置函数大全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/40297775&quot;&gt;什么是猴子补丁(monkey patch)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5626193/what-is-monkey-patch&quot;&gt;What is monkey patch?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.tryolabs.com/2013/07/05/run-time-method-patching-python/&quot;&gt;RUN-TIME METHOD PATCHING IN PYTHON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/9712125&quot;&gt;飘逸的python - 偏函数functools.partial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jeffknupp.com/blog/2013/02/14/drastically-improve-your-python-understanding-pythons-execution-model/&quot;&gt;Drastically Improve Your Python: Understanding Python&#39;s Execution Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/39895871&quot;&gt;飘逸的python - descriptor(描述器)就是这么回事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pyzh.readthedocs.org/en/latest/Descriptor-HOW-TO-Guide.html&quot;&gt;Python描述器引导(翻译)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wklken.me/posts/2013/08/20/python-extra-itertools.html&quot;&gt;PYTHON-进阶-ITERTOOLS模块小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;参考网站&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://py.memect.com/&quot;&gt;python 日报&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/category/python/&quot;&gt;伯乐在线-python文章集锦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.freebuf.com/&quot;&gt;黑客与极客的python文章集锦&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-17-python-materials.md.jpg&quot; alt=&quot;2015-03-17-python-materials.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结之结构型模式</title>
     <link href="/design-pattern-structural-pattern"/>
     <updated>2015-03-13T00:00:00+08:00</updated>
     <id>/design-pattern-structural-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 适配器模式&lt;/h2&gt;

&lt;p&gt;　　在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类别自己的接口包裹在一个已存在的类中。&lt;/p&gt;

&lt;h3&gt;1.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2008/11/06/generic-adapter-class-in-python/&quot;&quot;&quot;

import os

class Dog(object):
    def __init__(self):
        self.name = &quot;Dog&quot;
    def bark(self):
        return &quot;woof!&quot;

class Cat(object):
    def __init__(self):
        self.name = &quot;Cat&quot;
    def meow(self):
        return &quot;meow!&quot;

class Human(object):
    def __init__(self):
        self.name = &quot;Human&quot;
    def speak(self):
        return &quot;&#39;hello&#39;&quot;


class Car(object):
    def __init__(self):
        self.name = &quot;Car&quot;
    def make_noise(self, octane_level):
        return &quot;vroom{0}&quot;.format(&quot;!&quot; * octane_level)


class Adapter(object):

    &quot;&quot;&quot;
    Adapts an object by replacing methods.
    Usage:
    dog = Dog
    dog = Adapter(dog, dict(make_noise=dog.bark))
    &amp;gt;&amp;gt;&amp;gt; objects = []
    &amp;gt;&amp;gt;&amp;gt; dog = Dog()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(dog, make_noise=dog.bark))
    &amp;gt;&amp;gt;&amp;gt; cat = Cat()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(cat, make_noise=cat.meow))
    &amp;gt;&amp;gt;&amp;gt; human = Human()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(human, make_noise=human.speak))
    &amp;gt;&amp;gt;&amp;gt; car = Car()
    &amp;gt;&amp;gt;&amp;gt; car_noise = lambda: car.make_noise(3)
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(car, make_noise=car_noise))
    &amp;gt;&amp;gt;&amp;gt; for obj in objects:
    ...     print(&#39;A {} goes {}&#39;.format(obj.name, obj.make_noise()))
    A Dog goes woof!
    A Cat goes meow!
    A Human goes &#39;hello&#39;
    A Car goes vroom!!!
    &quot;&quot;&quot;

    def __init__(self, obj, **adapted_methods):
        &quot;&quot;&quot;We set the adapted methods in the object&#39;s dict&quot;&quot;&quot;
        self.obj = obj
        self.__dict__.update(adapted_methods)

    def __getattr__(self, attr):
        &quot;&quot;&quot;All non-adapted calls are passed to the object&quot;&quot;&quot;
        return getattr(self.obj, attr)


def main():
    objects = []
    dog = Dog()
    objects.append(Adapter(dog, make_noise=dog.bark))
    cat = Cat()
    objects.append(Adapter(cat, make_noise=cat.meow))
    human = Human()
    objects.append(Adapter(human, make_noise=human.speak))
    car = Car()
    objects.append(Adapter(car, make_noise=lambda: car.make_noise(3)))

    for obj in objects:
        print(&quot;A {0} goes {1}&quot;.format(obj.name, obj.make_noise()))


if __name__ == &quot;__main__&quot;:
    main()

### OUTPUT ###
# A Dog goes woof!
# A Cat goes meow!
# A Human goes &#39;hello&#39;
# A Car goes vroom!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 桥接模式&lt;/h2&gt;

&lt;p&gt;　　桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。&lt;/p&gt;

&lt;h3&gt;2.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://en.wikibooks.org/wiki/Computer_Science_Design_Patterns/Bridge_Pattern#Python&quot;&quot;&quot;


# ConcreteImplementor 1/2
class DrawingAPI1(object):

    def draw_circle(self, x, y, radius):
        print(&#39;API1.circle at {}:{} radius {}&#39;.format(x, y, radius))


# ConcreteImplementor 2/2
class DrawingAPI2(object):

    def draw_circle(self, x, y, radius):
        print(&#39;API2.circle at {}:{} radius {}&#39;.format(x, y, radius))


# Refined Abstraction
class CircleShape(object):

    def __init__(self, x, y, radius, drawing_api):
        self._x = x
        self._y = y
        self._radius = radius
        self._drawing_api = drawing_api

    # low-level i.e. Implementation specific
    def draw(self):
        self._drawing_api.draw_circle(self._x, self._y, self._radius)

    # high-level i.e. Abstraction specific
    def scale(self, pct):
        self._radius *= pct


def main():
    shapes = (
        CircleShape(1, 2, 3, DrawingAPI1()),
        CircleShape(5, 7, 11, DrawingAPI2())
    )

    for shape in shapes:
        shape.scale(2.5)
        shape.draw()


if __name__ == &#39;__main__&#39;:
    main()

### OUTPUT ###
# API1.circle at 1:2 radius 7.5
# API2.circle at 5:7 radius 27.5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 组合模式&lt;/h2&gt;

&lt;p&gt;　　针对“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;

&lt;h3&gt;3.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;
A class which defines a composite object which can store
hieararchical dictionaries with names.
This class is same as a hiearchical dictionary, but it
provides methods to add/access/modify children by name,
like a Composite.
Created Anand B Pillai     &amp;lt;abpillai@gmail.com&amp;gt;
&quot;&quot;&quot;
__author__ = &quot;Anand B Pillai&quot;
__maintainer__ = &quot;Anand B Pillai&quot;
__version__ = &quot;0.2&quot;


def normalize(val):
    &quot;&quot;&quot; Normalize a string so that it can be used as an attribute
    to a Python object &quot;&quot;&quot;

    if val.find(&#39;-&#39;) != -1:
        val = val.replace(&#39;-&#39;, &#39;_&#39;)

    return val


def denormalize(val):
    &quot;&quot;&quot; De-normalize a string &quot;&quot;&quot;

    if val.find(&#39;_&#39;) != -1:
        val = val.replace(&#39;_&#39;, &#39;-&#39;)

    return val


class SpecialDict(dict):

    &quot;&quot;&quot; A dictionary type which allows direct attribute
    access to its keys &quot;&quot;&quot;

    def __getattr__(self, name):

        if name in self.__dict__:
            return self.__dict__[name]
        elif name in self:
            return self.get(name)
        else:
            # Check for denormalized name
            name = denormalize(name)
            if name in self:
                return self.get(name)
            else:
                raise AttributeError(&#39;no attribute named %s&#39; % name)

    def __setattr__(self, name, value):

        if name in self.__dict__:
            self.__dict__[name] = value
        elif name in self:
            self[name] = value
        else:
            # Check for denormalized name
            name2 = denormalize(name)
            if name2 in self:
                self[name2] = value
            else:
                # New attribute
                self[name] = value


class CompositeDict(SpecialDict):

    &quot;&quot;&quot; A class which works like a hierarchical dictionary.
    This class is based on the Composite design-pattern &quot;&quot;&quot;

    ID = 0

    def __init__(self, name=&#39;&#39;):

        if name:
            self._name = name
        else:
            self._name = &#39;&#39;.join((&#39;id#&#39;, str(self.__class__.ID)))
            self.__class__.ID += 1

        self._children = []
        # Link  back to father
        self._father = None
        self[self._name] = SpecialDict()

    def __getattr__(self, name):

        if name in self.__dict__:
            return self.__dict__[name]
        elif name in self:
            return self.get(name)
        else:
            # Check for denormalized name
            name = denormalize(name)
            if name in self:
                return self.get(name)
            else:
                # Look in children list
                child = self.findChild(name)
                if child:
                    return child
                else:
                    attr = getattr(self[self._name], name)
                    if attr:
                        return attr

                    raise AttributeError(&#39;no attribute named %s&#39; % name)

    def isRoot(self):
        &quot;&quot;&quot; Return whether I am a root component or not &quot;&quot;&quot;

        # If I don&#39;t have a parent, I am root
        return not self._father

    def isLeaf(self):
        &quot;&quot;&quot; Return whether I am a leaf component or not &quot;&quot;&quot;

        # I am a leaf if I have no children
        return not self._children

    def getName(self):
        &quot;&quot;&quot; Return the name of this ConfigInfo object &quot;&quot;&quot;

        return self._name

    def getIndex(self, child):
        &quot;&quot;&quot; Return the index of the child ConfigInfo object &#39;child&#39; &quot;&quot;&quot;

        if child in self._children:
            return self._children.index(child)
        else:
            return -1

    def getDict(self):
        &quot;&quot;&quot; Return the contained dictionary &quot;&quot;&quot;

        return self[self._name]

    def getProperty(self, child, key):
        &quot;&quot;&quot; Return the value for the property for child
        &#39;child&#39; with key &#39;key&#39; &quot;&quot;&quot;

        # First get the child&#39;s dictionary
        childDict = self.getInfoDict(child)
        if childDict:
            return childDict.get(key, None)

    def setProperty(self, child, key, value):
        &quot;&quot;&quot; Set the value for the property &#39;key&#39; for
        the child &#39;child&#39; to &#39;value&#39; &quot;&quot;&quot;

        # First get the child&#39;s dictionary
        childDict = self.getInfoDict(child)
        if childDict:
            childDict[key] = value

    def getChildren(self):
        &quot;&quot;&quot; Return the list of immediate children of this object &quot;&quot;&quot;

        return self._children

    def getAllChildren(self):
        &quot;&quot;&quot; Return the list of all children of this object &quot;&quot;&quot;

        l = []
        for child in self._children:
            l.append(child)
            l.extend(child.getAllChildren())

        return l

    def getChild(self, name):
        &quot;&quot;&quot; Return the immediate child object with the given name &quot;&quot;&quot;

        for child in self._children:
            if child.getName() == name:
                return child

    def findChild(self, name):
        &quot;&quot;&quot; Return the child with the given name from the tree &quot;&quot;&quot;

        # Note - this returns the first child of the given name
        # any other children with similar names down the tree
        # is not considered.

        for child in self.getAllChildren():
            if child.getName() == name:
                return child

    def findChildren(self, name):
        &quot;&quot;&quot; Return a list of children with the given name from the tree &quot;&quot;&quot;

        # Note: this returns a list of all the children of a given
        # name, irrespective of the depth of look-up.

        children = []

        for child in self.getAllChildren():
            if child.getName() == name:
                children.append(child)

        return children

    def getPropertyDict(self):
        &quot;&quot;&quot; Return the property dictionary &quot;&quot;&quot;

        d = self.getChild(&#39;__properties&#39;)
        if d:
            return d.getDict()
        else:
            return {}

    def getParent(self):
        &quot;&quot;&quot; Return the person who created me &quot;&quot;&quot;

        return self._father

    def __setChildDict(self, child):
        &quot;&quot;&quot; Private method to set the dictionary of the child
        object &#39;child&#39; in the internal dictionary &quot;&quot;&quot;

        d = self[self._name]
        d[child.getName()] = child.getDict()

    def setParent(self, father):
        &quot;&quot;&quot; Set the parent object of myself &quot;&quot;&quot;

        # This should be ideally called only once
        # by the father when creating the child :-)
        # though it is possible to change parenthood
        # when a new child is adopted in the place
        # of an existing one - in that case the existing
        # child is orphaned - see addChild and addChild2
        # methods !
        self._father = father

    def setName(self, name):
        &quot;&quot;&quot; Set the name of this ConfigInfo object to &#39;name&#39; &quot;&quot;&quot;

        self._name = name

    def setDict(self, d):
        &quot;&quot;&quot; Set the contained dictionary &quot;&quot;&quot;

        self[self._name] = d.copy()

    def setAttribute(self, name, value):
        &quot;&quot;&quot; Set a name value pair in the contained dictionary &quot;&quot;&quot;

        self[self._name][name] = value

    def getAttribute(self, name):
        &quot;&quot;&quot; Return value of an attribute from the contained dictionary &quot;&quot;&quot;

        return self[self._name][name]

    def addChild(self, name, force=False):
        &quot;&quot;&quot; Add a new child &#39;child&#39; with the name &#39;name&#39;.
        If the optional flag &#39;force&#39; is set to True, the
        child object is overwritten if it is already there.
        This function returns the child object, whether
        new or existing &quot;&quot;&quot;

        if type(name) != str:
            raise ValueError(&#39;Argument should be a string!&#39;)

        child = self.getChild(name)
        if child:
            # print(&#39;Child %s present!&#39; % name)
            # Replace it if force==True
            if force:
                index = self.getIndex(child)
                if index != -1:
                    child = self.__class__(name)
                    self._children[index] = child
                    child.setParent(self)

                    self.__setChildDict(child)
            return child
        else:
            child = self.__class__(name)
            child.setParent(self)

            self._children.append(child)
            self.__setChildDict(child)

            return child

    def addChild2(self, child):
        &quot;&quot;&quot; Add the child object &#39;child&#39;. If it is already present,
        it is overwritten by default &quot;&quot;&quot;

        currChild = self.getChild(child.getName())
        if currChild:
            index = self.getIndex(currChild)
            if index != -1:
                self._children[index] = child
                child.setParent(self)
                # Unset the existing child&#39;s parent
                currChild.setParent(None)
                del currChild

                self.__setChildDict(child)
        else:
            child.setParent(self)
            self._children.append(child)
            self.__setChildDict(child)


if __name__ == &quot;__main__&quot;:
    window = CompositeDict(&#39;Window&#39;)
    frame = window.addChild(&#39;Frame&#39;)
    tfield = frame.addChild(&#39;Text Field&#39;)
    tfield.setAttribute(&#39;size&#39;, &#39;20&#39;)

    btn = frame.addChild(&#39;Button1&#39;)
    btn.setAttribute(&#39;label&#39;, &#39;Submit&#39;)

    btn = frame.addChild(&#39;Button2&#39;)
    btn.setAttribute(&#39;label&#39;, &#39;Browse&#39;)

    # print(window)
    # print(window.Frame)
    # print(window.Frame.Button1)
    # print(window.Frame.Button2)
    print(window.Frame.Button1.label)
    print(window.Frame.Button2.label)

### OUTPUT ###
# Submit
# Browse
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 修饰模式&lt;/h2&gt;

&lt;p&gt;　　修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。&lt;/p&gt;

&lt;h3&gt;4.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;https://docs.python.org/2/library/functools.html#functools.wraps&quot;&quot;&quot;
&quot;&quot;&quot;https://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/739665#739665&quot;&quot;&quot;

from functools import wraps


def makebold(fn):
    @wraps(fn)
    def wrapped():
        return &quot;&amp;lt;b&amp;gt;&quot; + fn() + &quot;&amp;lt;/b&amp;gt;&quot;
    return wrapped


def makeitalic(fn):
    @wraps(fn)
    def wrapped():
        return &quot;&amp;lt;i&amp;gt;&quot; + fn() + &quot;&amp;lt;/i&amp;gt;&quot;
    return wrapped


@makebold
@makeitalic
def hello():
    &quot;&quot;&quot;a decorated hello world&quot;&quot;&quot;
    return &quot;hello world&quot;

if __name__ == &#39;__main__&#39;:
    print(&#39;result:{}   name:{}   doc:{}&#39;.format(hello(), hello.__name__, hello.__doc__))

### OUTPUT ###
# result:&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;hello world&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;   name:hello   doc:a decorated hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. 外观模式&lt;/h2&gt;

&lt;p&gt;　　外观模式（Facade pattern），是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。&lt;/p&gt;

&lt;h3&gt;5.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time

SLEEP = 0.5


# Complex Parts
class TC1:

    def run(self):
        print(&quot;###### In Test 1 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


class TC2:

    def run(self):
        print(&quot;###### In Test 2 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


class TC3:

    def run(self):
        print(&quot;###### In Test 3 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


# Facade
class TestRunner:

    def __init__(self):
        self.tc1 = TC1()
        self.tc2 = TC2()
        self.tc3 = TC3()
        self.tests = [i for i in (self.tc1, self.tc2, self.tc3)]

    def runAll(self):
        [i.run() for i in self.tests]


# Client
if __name__ == &#39;__main__&#39;:
    testrunner = TestRunner()
    testrunner.runAll()

### OUTPUT ###
# ###### In Test 1 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
# ###### In Test 2 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
# ###### In Test 3 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-13-design-pattern-structural-pattern.md.jpg&quot; alt=&quot;2015-03-13-design-pattern-structural-pattern.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结之行为型模式</title>
     <link href="/design-pattern-behavior-pattern"/>
     <updated>2015-03-12T00:00:00+08:00</updated>
     <id>/design-pattern-behavior-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 迭代器模式&lt;/h2&gt;

&lt;p&gt;　　提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。迭代器模式的结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。&lt;/li&gt;
&lt;li&gt;具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。&lt;/li&gt;
&lt;li&gt;抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(),&lt;/li&gt;
&lt;li&gt;迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;1.1 Python源码实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/
Implementation of the iterator pattern with a generator&quot;&quot;&quot;


def count_to(count):
    &quot;&quot;&quot;Counts by word numbers, up to a maximum of five&quot;&quot;&quot;
    numbers = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]
    # enumerate() returns a tuple containing a count (from start which
    # defaults to 0) and the values obtained from iterating over sequence
    for pos, number in zip(range(count), numbers):
        yield number

# Test the generator
count_to_two = lambda: count_to(2)
count_to_five = lambda: count_to(5)

print(&#39;Counting to two...&#39;)
for number in count_to_two():
    print(number, end=&#39; &#39;)

print()

print(&#39;Counting to five...&#39;)
for number in count_to_five():
    print(number, end=&#39; &#39;)

print()

### OUTPUT ###
# Counting to two...
# one two
# Counting to five...
# one two three four five
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 观察者模式&lt;/h2&gt;

&lt;p&gt;　　观察者模式（有时又被称为发布/订阅模式）是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。&lt;/p&gt;

&lt;h3&gt;2.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;
Reference: http://www.slideshare.net/ishraqabd/publish-subscribe-model-overview-13368808
Author: https://github.com/HanWenfang
&quot;&quot;&quot;


class Provider:

    def __init__(self):
        self.msg_queue = []
        self.subscribers = {}

    def notify(self, msg):
        self.msg_queue.append(msg)

    def subscribe(self, msg, subscriber):
        if msg not in self.subscribers:
            self.subscribers[msg] = []
            self.subscribers[msg].append(subscriber)  # unfair
        else:
            self.subscribers[msg].append(subscriber)

    def unsubscribe(self, msg, subscriber):
        self.subscribers[msg].remove(subscriber)

    def update(self):
        for msg in self.msg_queue:
            if msg in self.subscribers:
                for sub in self.subscribers[msg]:
                    sub.run(msg)
        self.msg_queue = []


class Publisher:

    def __init__(self, msg_center):
        self.provider = msg_center

    def publish(self, msg):
        self.provider.notify(msg)


class Subscriber:

    def __init__(self, name, msg_center):
        self.name = name
        self.provider = msg_center

    def subscribe(self, msg):
        self.provider.subscribe(msg, self)

    def run(self, msg):
        print(&quot;{} got {}&quot;.format(self.name, msg))


def main():
    message_center = Provider()

    fftv = Publisher(message_center)

    jim = Subscriber(&quot;jim&quot;, message_center)
    jim.subscribe(&quot;cartoon&quot;)
    jack = Subscriber(&quot;jack&quot;, message_center)
    jack.subscribe(&quot;music&quot;)
    gee = Subscriber(&quot;gee&quot;, message_center)
    gee.subscribe(&quot;movie&quot;)

    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;music&quot;)
    fftv.publish(&quot;ads&quot;)
    fftv.publish(&quot;movie&quot;)
    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;movie&quot;)
    fftv.publish(&quot;blank&quot;)

    message_center.update()


if __name__ == &quot;__main__&quot;:
    main()

### OUTPUT ###
# jim got cartoon
# jack got music
# gee got movie
# jim got cartoon
# jim got cartoon
# gee got movie
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 策略模式&lt;/h2&gt;

&lt;p&gt;　　策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。主要是应对：在软件构建过程中，某些对象使用的算法可能多种多样，经常发生变化。如果在对象内部实现这些算法，将会使对象变得异常复杂，甚至会造成性能上的负担。GoF《设计模式》中说道：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。该模式使得算法可独立于它们的客户变化。&lt;/p&gt;

&lt;h3&gt;3.1 Python 源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class Duck(object):
    # 上面使用继承，这里通用的使用参数方式，传入的就是操作工厂的类
    def __init__(self, strategy=None):
        self.action = None
        self.count = 0
        if strategy:
            # 指定策略，那么执行action就是用这个类的实例
            self.action = strategy()

    def fly(self, kind):
        if self.action:
            self.count += 1
            # 这里的第二个参数self，算是炫技吧，就是为了让操作的方法获得这里计算好的count
            return self.action.fly(kind, self)

        else:
            raise UnboundLocalError(&#39;Exception raised, no strategyClass supplied to Duck!&#39;)

# 注意这里没有继承Duck，因为是以参数的方式传入类名
class Duck1(object):

    def fly(self, kind, instance):
        return &#39;Duck1 fly kind: &#39; + kind + &#39;#&#39; + str(instance.count)


class Duck2(object):

    def fly(self, kind, instance):
        return &#39;Duck2 fly kind: &#39; + kind + &#39;#&#39; + str(instance.count)


if __name__ == &#39;__main__&#39;:
    duckfly = Duck()
    duck1fly = Duck(strategy=Duck1)
    duck2fly = Duck(strategy=Duck2)

    try:
        print duckfly.fly(&#39;yes&#39;)
    except Exception as e:
        print &quot;The following exception was expected:&quot;
        print e

    print duck1fly.fly(&#39;yes&#39;)
    print duck1fly.fly(&#39;no&#39;)
    print duck1fly.fly(&#39;yes&#39;)
    print duck2fly.fly(&#39;yes&#39;)
    print duck2fly.fly(&#39;no&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 模板方法模式&lt;/h2&gt;

&lt;p&gt;　　模板方法模式定义了一个算法的步骤，并允许次类别为一个或多个步骤提供其实践方式。让次类别在不改变算法架构的情况下，重新定义算法中的某些步骤。在软件工程中，它是一种软件设计模式，和C++模板没有关连。也可以理解为定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。因此模板方法使得子类可以在不改变一个算法的结构的情况下重新定义该算法的某些特定变量。优点是把不变行为搬移到超类，去除子类中的重复代码。&lt;/p&gt;

&lt;h3&gt;4.1 Python源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;http://blog.csdn.net/five3/article/details/7564578&quot;&gt;csdn.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python  
#encoding: utf-8  

class template:
    def __init__(self):
        pass

    def logic(self):
        print &#39;do something before ....&#39;
        print self.do_something_now()
        print &#39;do something after ....&#39;

    def do_something_now(self):
        return None      

class apply_temp1(template):
    def __init__(self):
        pass

    def do_something_now(self):
        return &#39;apply 1&#39;  

class apply_temp2(template):
    def __init__(self):
        pass

    def do_something_now(self):
        return &#39;apply 2&#39;  


if &#39;__main__&#39; == __name__:  
    obj1 = apply_temp1()
    obj2 = apply_temp2()
    obj1.logic()
    obj2.logic()
    print obj1.__class__
    print obj2.__class__
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-12-design-pattern-behavior-pattern.md.jpg&quot; alt=&quot;2015-03-12-design-pattern-behavior-pattern.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结之创建型模式</title>
     <link href="/design-pattern-create-pattern"/>
     <updated>2015-03-11T00:00:00+08:00</updated>
     <id>/design-pattern-create-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 抽象工厂模式&lt;/h2&gt;

&lt;p&gt;　　抽象工厂模式（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。&lt;/p&gt;

&lt;p&gt;　　举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建邮件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（邮件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“邮件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“邮件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“邮件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“邮件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。&lt;/p&gt;

&lt;p&gt;　　“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。&lt;/p&gt;

&lt;p&gt;　　使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。&lt;/p&gt;

&lt;h3&gt;1.1 Python 源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;https://github.com/faif/python-patterns/&quot;&gt;github:python-patterns&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

# http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/

&quot;&quot;&quot;Implementation of the abstract factory pattern&quot;&quot;&quot;

import random

class PetShop:

    &quot;&quot;&quot;A pet shop&quot;&quot;&quot;

    def __init__(self, animal_factory=None):
        &quot;&quot;&quot;pet_factory is our abstract factory.  We can set it at will.&quot;&quot;&quot;

        self.pet_factory = animal_factory

    def show_pet(self):
        &quot;&quot;&quot;Creates and shows a pet using the abstract factory&quot;&quot;&quot;

        pet = self.pet_factory.get_pet()
        print(&quot;We have a lovely {}&quot;.format(pet))
        print(&quot;It says {}&quot;.format(pet.speak()))
        print(&quot;We also have {}&quot;.format(self.pet_factory.get_food()))


# Stuff that our factory makes

class Dog:

    def speak(self):
        return &quot;woof&quot;

    def __str__(self):
        return &quot;Dog&quot;


class Cat:

    def speak(self):
        return &quot;meow&quot;

    def __str__(self):
        return &quot;Cat&quot;


# Factory classes

class DogFactory:

    def get_pet(self):
        return Dog()

    def get_food(self):
        return &quot;dog food&quot;


class CatFactory:

    def get_pet(self):
        return Cat()

    def get_food(self):
        return &quot;cat food&quot;

# Create the proper family
def get_factory():
    &quot;&quot;&quot;Let&#39;s be dynamic!&quot;&quot;&quot;
    return random.choice([DogFactory, CatFactory])()


# Show pets with various factories
if __name__ == &quot;__main__&quot;:
    for i in range(3):
        shop = PetShop(get_factory())
        shop.show_pet()
        print(&quot;=&quot; * 20)

### OUTPUT ###
# We have a lovely Dog
# It says woof
# We also have dog food
# ====================
# We have a lovely Dog
# It says woof
# We also have dog food
# ====================
# We have a lovely Cat
# It says meow
# We also have cat food
# ====================
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2.工厂方法模式&lt;/h2&gt;

&lt;p&gt;　　工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”&lt;/p&gt;

&lt;p&gt;　　创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。&lt;/p&gt;

&lt;p&gt;　　对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。&lt;/p&gt;

&lt;p&gt;　　如果抛开设计模式的范畴，“工厂方法”这个词也可以指作为“工厂”的方法，这个方法的主要目的就是创建对象，而这个方法不一定在单独的工厂类中。这些方法通常作为静态方法，定义在方法所实例化的类中。&lt;/p&gt;

&lt;p&gt;　　每个工厂方法都有特定的名称。在许多面向对象的编程语言中，构造方法必须和它所在的类具有相同的名称，这样的话，如果有多种创建对象的方式（重载）就可能导致歧义。工厂方法没有这种限制，所以可以具有描述性的名称。举例来说，根据两个实数创建一个复数，而这两个实数表示直角坐标或极坐标，如果使用工厂方法，方法的含义就非常清晰了。当工厂方法起到这种消除歧义的作用时，构造方法常常被设置为私有方法，从而强制客户端代码使用工厂方法创建对象。&lt;/p&gt;

&lt;h3&gt;2.1 Python 源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;https://github.com/faif/python-patterns/&quot;&gt;github:python-patterns&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/&quot;&quot;&quot;


class GreekGetter:

    &quot;&quot;&quot;A simple localizer a la gettext&quot;&quot;&quot;

    def __init__(self):
        self.trans = dict(dog=&quot;σκύλος&quot;, cat=&quot;γάτα&quot;)

    def get(self, msgid):
        &quot;&quot;&quot;We&#39;ll punt if we don&#39;t have a translation&quot;&quot;&quot;
        try:
            return self.trans[msgid]
        except KeyError:
            return str(msgid)


class EnglishGetter:

    &quot;&quot;&quot;Simply echoes the msg ids&quot;&quot;&quot;

    def get(self, msgid):
        return str(msgid)


def get_localizer(language=&quot;English&quot;):
    &quot;&quot;&quot;The factory method&quot;&quot;&quot;
    languages = dict(English=EnglishGetter, Greek=GreekGetter)
    return languages[language]()

# Create our localizers
e, g = get_localizer(language=&quot;English&quot;), get_localizer(language=&quot;Greek&quot;)
# Localize some text
for msgid in &quot;dog parrot cat bear&quot;.split():
    print(e.get(msgid), g.get(msgid))

### OUTPUT ###
# dog σκύλος
# parrot parrot
# cat γάτα
# bear bear
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 单例模式&lt;/h2&gt;

&lt;p&gt;　　单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。&lt;/p&gt;

&lt;p&gt;　　实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。&lt;/p&gt;

&lt;p&gt;　　单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。&lt;/p&gt;

&lt;h3&gt;3.1 Python源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;http://blog.csdn.net/ghostfromheaven/article/details/7671853&quot;&gt;csdn.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#-*- encoding=utf-8 -*-
print &#39;----------------------方法1--------------------------&#39;
#方法1,实现__new__方法
#并在将一个类的实例绑定到类变量_instance上,
#如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回
#如果cls._instance不为None,直接返回cls._instance
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, &#39;_instance&#39;):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1

one = MyClass()
two = MyClass()

two.a = 3
print one.a
#3
#one和two完全相同,可以用id(), ==, is检测
print id(one)
#29097904
print id(two)
#29097904
print one == two
#True
print one is two
#True

print &#39;----------------------方法2--------------------------&#39;
#方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)
#同一个类的所有实例天然拥有相同的行为(方法),
#只需要保证同一个类的所有实例具有相同的状态(属性)即可
#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)
#可参看:http://code.activestate.com/recipes/66531/
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1

one = MyClass2()
two = MyClass2()

#one和two是两个不同的对象,id, ==, is对比结果可看出
two.a = 3
print one.a
#3
print id(one)
#28873680
print id(two)
#28873712
print one == two
#False
print one is two
#False
#但是one和two具有相同的（同一个__dict__属性）,见:
print id(one.__dict__)
#30104000
print id(two.__dict__)
#30104000

print &#39;----------------------方法3--------------------------&#39;
#方法3:本质上是方法1的升级（或者说高级）版
#使用__metaclass__（元类）的高级python用法
class Singleton2(type):
    def __init__(cls, name, bases, dict):
        super(Singleton2, cls).__init__(name, bases, dict)
        cls._instance = None
    def __call__(cls, *args, **kw):
        if cls._instance is None:
            cls._instance = super(Singleton2, cls).__call__(*args, **kw)
        return cls._instance

class MyClass3(object):
    __metaclass__ = Singleton2

one = MyClass3()
two = MyClass3()

two.a = 3
print one.a
#3
print id(one)
#31495472
print id(two)
#31495472
print one == two
#True
print one is two
#True

print &#39;----------------------方法4--------------------------&#39;
#方法4:也是方法1的升级（高级）版本,
#使用装饰器(decorator),
#这是一种更pythonic,更elegant的方法,
#单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的
def singleton(cls, *args, **kw):
    instances = {}
    def _singleton():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return _singleton

@singleton
class MyClass4(object):
    a = 1
    def __init__(self, x=0):
        self.x = x

one = MyClass4()
two = MyClass4()

two.a = 3
print one.a
#3
print id(one)
#29660784
print id(two)
#29660784
print one == two
#True
print one is two
#True
one.x = 1
print one.x
#1
print two.x
#1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-11-design-pattern-create-pattern.md.jpg&quot; alt=&quot;2015-03-11-design-pattern-create-pattern.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   

</feed>


</body>
</html>
