<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Taotao's Zone</title>
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css" type="text/css" />
  <link rel="stylesheet" href="/css/default.css" type="text/css" />
  <link rel="stylesheet" href="/css/desktop.css" type="text/css" />
  <link rel="stylesheet" href="/css/mobile.css" type="text/css" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
  <script src="/js/jquery-1.11.0.min.js" type="text/javascript"></script>
  <script src="/js/jquery-migrate-1.2.1.js" type="text/javascript"></script>
  <script src="/js/jquery.transit.min.js" type="text/javascript"></script>
  <script src="/js/common.js" type="text/javascript"></script>
</head>
<body>
  <?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

   <title>Taotao's Zone</title>
   <link href="http://litaotao.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://litaotao.github.io" rel="alternate" type="text/html" />
   <updated>2015-05-06T13:35:30+08:00</updated>
   <id>http://litaotao.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>book-3. 设计模式总结之结构型模式</title>
     <link href="/design-pattern-structural-pattern"/>
     <updated>2015-03-13T00:00:00+08:00</updated>
     <id>/design-pattern-structural-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 适配器模式&lt;/h2&gt;

&lt;p&gt;　　在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类别自己的接口包裹在一个已存在的类中。&lt;/p&gt;

&lt;h3&gt;1.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2008/11/06/generic-adapter-class-in-python/&quot;&quot;&quot;

import os

class Dog(object):
    def __init__(self):
        self.name = &quot;Dog&quot;
    def bark(self):
        return &quot;woof!&quot;

class Cat(object):
    def __init__(self):
        self.name = &quot;Cat&quot;
    def meow(self):
        return &quot;meow!&quot;

class Human(object):
    def __init__(self):
        self.name = &quot;Human&quot;
    def speak(self):
        return &quot;&#39;hello&#39;&quot;


class Car(object):
    def __init__(self):
        self.name = &quot;Car&quot;
    def make_noise(self, octane_level):
        return &quot;vroom{0}&quot;.format(&quot;!&quot; * octane_level)


class Adapter(object):

    &quot;&quot;&quot;
    Adapts an object by replacing methods.
    Usage:
    dog = Dog
    dog = Adapter(dog, dict(make_noise=dog.bark))
    &amp;gt;&amp;gt;&amp;gt; objects = []
    &amp;gt;&amp;gt;&amp;gt; dog = Dog()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(dog, make_noise=dog.bark))
    &amp;gt;&amp;gt;&amp;gt; cat = Cat()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(cat, make_noise=cat.meow))
    &amp;gt;&amp;gt;&amp;gt; human = Human()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(human, make_noise=human.speak))
    &amp;gt;&amp;gt;&amp;gt; car = Car()
    &amp;gt;&amp;gt;&amp;gt; car_noise = lambda: car.make_noise(3)
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(car, make_noise=car_noise))
    &amp;gt;&amp;gt;&amp;gt; for obj in objects:
    ...     print(&#39;A {} goes {}&#39;.format(obj.name, obj.make_noise()))
    A Dog goes woof!
    A Cat goes meow!
    A Human goes &#39;hello&#39;
    A Car goes vroom!!!
    &quot;&quot;&quot;

    def __init__(self, obj, **adapted_methods):
        &quot;&quot;&quot;We set the adapted methods in the object&#39;s dict&quot;&quot;&quot;
        self.obj = obj
        self.__dict__.update(adapted_methods)

    def __getattr__(self, attr):
        &quot;&quot;&quot;All non-adapted calls are passed to the object&quot;&quot;&quot;
        return getattr(self.obj, attr)


def main():
    objects = []
    dog = Dog()
    objects.append(Adapter(dog, make_noise=dog.bark))
    cat = Cat()
    objects.append(Adapter(cat, make_noise=cat.meow))
    human = Human()
    objects.append(Adapter(human, make_noise=human.speak))
    car = Car()
    objects.append(Adapter(car, make_noise=lambda: car.make_noise(3)))

    for obj in objects:
        print(&quot;A {0} goes {1}&quot;.format(obj.name, obj.make_noise()))


if __name__ == &quot;__main__&quot;:
    main()

### OUTPUT ###
# A Dog goes woof!
# A Cat goes meow!
# A Human goes &#39;hello&#39;
# A Car goes vroom!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 桥接模式&lt;/h2&gt;

&lt;p&gt;　　桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。&lt;/p&gt;

&lt;h3&gt;2.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://en.wikibooks.org/wiki/Computer_Science_Design_Patterns/Bridge_Pattern#Python&quot;&quot;&quot;


# ConcreteImplementor 1/2
class DrawingAPI1(object):

    def draw_circle(self, x, y, radius):
        print(&#39;API1.circle at {}:{} radius {}&#39;.format(x, y, radius))


# ConcreteImplementor 2/2
class DrawingAPI2(object):

    def draw_circle(self, x, y, radius):
        print(&#39;API2.circle at {}:{} radius {}&#39;.format(x, y, radius))


# Refined Abstraction
class CircleShape(object):

    def __init__(self, x, y, radius, drawing_api):
        self._x = x
        self._y = y
        self._radius = radius
        self._drawing_api = drawing_api

    # low-level i.e. Implementation specific
    def draw(self):
        self._drawing_api.draw_circle(self._x, self._y, self._radius)

    # high-level i.e. Abstraction specific
    def scale(self, pct):
        self._radius *= pct


def main():
    shapes = (
        CircleShape(1, 2, 3, DrawingAPI1()),
        CircleShape(5, 7, 11, DrawingAPI2())
    )

    for shape in shapes:
        shape.scale(2.5)
        shape.draw()


if __name__ == &#39;__main__&#39;:
    main()

### OUTPUT ###
# API1.circle at 1:2 radius 7.5
# API2.circle at 5:7 radius 27.5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 组合模式&lt;/h2&gt;

&lt;p&gt;　　针对“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;

&lt;h3&gt;3.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;
A class which defines a composite object which can store
hieararchical dictionaries with names.
This class is same as a hiearchical dictionary, but it
provides methods to add/access/modify children by name,
like a Composite.
Created Anand B Pillai     &amp;lt;abpillai@gmail.com&amp;gt;
&quot;&quot;&quot;
__author__ = &quot;Anand B Pillai&quot;
__maintainer__ = &quot;Anand B Pillai&quot;
__version__ = &quot;0.2&quot;


def normalize(val):
    &quot;&quot;&quot; Normalize a string so that it can be used as an attribute
    to a Python object &quot;&quot;&quot;

    if val.find(&#39;-&#39;) != -1:
        val = val.replace(&#39;-&#39;, &#39;_&#39;)

    return val


def denormalize(val):
    &quot;&quot;&quot; De-normalize a string &quot;&quot;&quot;

    if val.find(&#39;_&#39;) != -1:
        val = val.replace(&#39;_&#39;, &#39;-&#39;)

    return val


class SpecialDict(dict):

    &quot;&quot;&quot; A dictionary type which allows direct attribute
    access to its keys &quot;&quot;&quot;

    def __getattr__(self, name):

        if name in self.__dict__:
            return self.__dict__[name]
        elif name in self:
            return self.get(name)
        else:
            # Check for denormalized name
            name = denormalize(name)
            if name in self:
                return self.get(name)
            else:
                raise AttributeError(&#39;no attribute named %s&#39; % name)

    def __setattr__(self, name, value):

        if name in self.__dict__:
            self.__dict__[name] = value
        elif name in self:
            self[name] = value
        else:
            # Check for denormalized name
            name2 = denormalize(name)
            if name2 in self:
                self[name2] = value
            else:
                # New attribute
                self[name] = value


class CompositeDict(SpecialDict):

    &quot;&quot;&quot; A class which works like a hierarchical dictionary.
    This class is based on the Composite design-pattern &quot;&quot;&quot;

    ID = 0

    def __init__(self, name=&#39;&#39;):

        if name:
            self._name = name
        else:
            self._name = &#39;&#39;.join((&#39;id#&#39;, str(self.__class__.ID)))
            self.__class__.ID += 1

        self._children = []
        # Link  back to father
        self._father = None
        self[self._name] = SpecialDict()

    def __getattr__(self, name):

        if name in self.__dict__:
            return self.__dict__[name]
        elif name in self:
            return self.get(name)
        else:
            # Check for denormalized name
            name = denormalize(name)
            if name in self:
                return self.get(name)
            else:
                # Look in children list
                child = self.findChild(name)
                if child:
                    return child
                else:
                    attr = getattr(self[self._name], name)
                    if attr:
                        return attr

                    raise AttributeError(&#39;no attribute named %s&#39; % name)

    def isRoot(self):
        &quot;&quot;&quot; Return whether I am a root component or not &quot;&quot;&quot;

        # If I don&#39;t have a parent, I am root
        return not self._father

    def isLeaf(self):
        &quot;&quot;&quot; Return whether I am a leaf component or not &quot;&quot;&quot;

        # I am a leaf if I have no children
        return not self._children

    def getName(self):
        &quot;&quot;&quot; Return the name of this ConfigInfo object &quot;&quot;&quot;

        return self._name

    def getIndex(self, child):
        &quot;&quot;&quot; Return the index of the child ConfigInfo object &#39;child&#39; &quot;&quot;&quot;

        if child in self._children:
            return self._children.index(child)
        else:
            return -1

    def getDict(self):
        &quot;&quot;&quot; Return the contained dictionary &quot;&quot;&quot;

        return self[self._name]

    def getProperty(self, child, key):
        &quot;&quot;&quot; Return the value for the property for child
        &#39;child&#39; with key &#39;key&#39; &quot;&quot;&quot;

        # First get the child&#39;s dictionary
        childDict = self.getInfoDict(child)
        if childDict:
            return childDict.get(key, None)

    def setProperty(self, child, key, value):
        &quot;&quot;&quot; Set the value for the property &#39;key&#39; for
        the child &#39;child&#39; to &#39;value&#39; &quot;&quot;&quot;

        # First get the child&#39;s dictionary
        childDict = self.getInfoDict(child)
        if childDict:
            childDict[key] = value

    def getChildren(self):
        &quot;&quot;&quot; Return the list of immediate children of this object &quot;&quot;&quot;

        return self._children

    def getAllChildren(self):
        &quot;&quot;&quot; Return the list of all children of this object &quot;&quot;&quot;

        l = []
        for child in self._children:
            l.append(child)
            l.extend(child.getAllChildren())

        return l

    def getChild(self, name):
        &quot;&quot;&quot; Return the immediate child object with the given name &quot;&quot;&quot;

        for child in self._children:
            if child.getName() == name:
                return child

    def findChild(self, name):
        &quot;&quot;&quot; Return the child with the given name from the tree &quot;&quot;&quot;

        # Note - this returns the first child of the given name
        # any other children with similar names down the tree
        # is not considered.

        for child in self.getAllChildren():
            if child.getName() == name:
                return child

    def findChildren(self, name):
        &quot;&quot;&quot; Return a list of children with the given name from the tree &quot;&quot;&quot;

        # Note: this returns a list of all the children of a given
        # name, irrespective of the depth of look-up.

        children = []

        for child in self.getAllChildren():
            if child.getName() == name:
                children.append(child)

        return children

    def getPropertyDict(self):
        &quot;&quot;&quot; Return the property dictionary &quot;&quot;&quot;

        d = self.getChild(&#39;__properties&#39;)
        if d:
            return d.getDict()
        else:
            return {}

    def getParent(self):
        &quot;&quot;&quot; Return the person who created me &quot;&quot;&quot;

        return self._father

    def __setChildDict(self, child):
        &quot;&quot;&quot; Private method to set the dictionary of the child
        object &#39;child&#39; in the internal dictionary &quot;&quot;&quot;

        d = self[self._name]
        d[child.getName()] = child.getDict()

    def setParent(self, father):
        &quot;&quot;&quot; Set the parent object of myself &quot;&quot;&quot;

        # This should be ideally called only once
        # by the father when creating the child :-)
        # though it is possible to change parenthood
        # when a new child is adopted in the place
        # of an existing one - in that case the existing
        # child is orphaned - see addChild and addChild2
        # methods !
        self._father = father

    def setName(self, name):
        &quot;&quot;&quot; Set the name of this ConfigInfo object to &#39;name&#39; &quot;&quot;&quot;

        self._name = name

    def setDict(self, d):
        &quot;&quot;&quot; Set the contained dictionary &quot;&quot;&quot;

        self[self._name] = d.copy()

    def setAttribute(self, name, value):
        &quot;&quot;&quot; Set a name value pair in the contained dictionary &quot;&quot;&quot;

        self[self._name][name] = value

    def getAttribute(self, name):
        &quot;&quot;&quot; Return value of an attribute from the contained dictionary &quot;&quot;&quot;

        return self[self._name][name]

    def addChild(self, name, force=False):
        &quot;&quot;&quot; Add a new child &#39;child&#39; with the name &#39;name&#39;.
        If the optional flag &#39;force&#39; is set to True, the
        child object is overwritten if it is already there.
        This function returns the child object, whether
        new or existing &quot;&quot;&quot;

        if type(name) != str:
            raise ValueError(&#39;Argument should be a string!&#39;)

        child = self.getChild(name)
        if child:
            # print(&#39;Child %s present!&#39; % name)
            # Replace it if force==True
            if force:
                index = self.getIndex(child)
                if index != -1:
                    child = self.__class__(name)
                    self._children[index] = child
                    child.setParent(self)

                    self.__setChildDict(child)
            return child
        else:
            child = self.__class__(name)
            child.setParent(self)

            self._children.append(child)
            self.__setChildDict(child)

            return child

    def addChild2(self, child):
        &quot;&quot;&quot; Add the child object &#39;child&#39;. If it is already present,
        it is overwritten by default &quot;&quot;&quot;

        currChild = self.getChild(child.getName())
        if currChild:
            index = self.getIndex(currChild)
            if index != -1:
                self._children[index] = child
                child.setParent(self)
                # Unset the existing child&#39;s parent
                currChild.setParent(None)
                del currChild

                self.__setChildDict(child)
        else:
            child.setParent(self)
            self._children.append(child)
            self.__setChildDict(child)


if __name__ == &quot;__main__&quot;:
    window = CompositeDict(&#39;Window&#39;)
    frame = window.addChild(&#39;Frame&#39;)
    tfield = frame.addChild(&#39;Text Field&#39;)
    tfield.setAttribute(&#39;size&#39;, &#39;20&#39;)

    btn = frame.addChild(&#39;Button1&#39;)
    btn.setAttribute(&#39;label&#39;, &#39;Submit&#39;)

    btn = frame.addChild(&#39;Button2&#39;)
    btn.setAttribute(&#39;label&#39;, &#39;Browse&#39;)

    # print(window)
    # print(window.Frame)
    # print(window.Frame.Button1)
    # print(window.Frame.Button2)
    print(window.Frame.Button1.label)
    print(window.Frame.Button2.label)

### OUTPUT ###
# Submit
# Browse
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 修饰模式&lt;/h2&gt;

&lt;p&gt;　　修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。&lt;/p&gt;

&lt;h3&gt;4.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;https://docs.python.org/2/library/functools.html#functools.wraps&quot;&quot;&quot;
&quot;&quot;&quot;https://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/739665#739665&quot;&quot;&quot;

from functools import wraps


def makebold(fn):
    @wraps(fn)
    def wrapped():
        return &quot;&amp;lt;b&amp;gt;&quot; + fn() + &quot;&amp;lt;/b&amp;gt;&quot;
    return wrapped


def makeitalic(fn):
    @wraps(fn)
    def wrapped():
        return &quot;&amp;lt;i&amp;gt;&quot; + fn() + &quot;&amp;lt;/i&amp;gt;&quot;
    return wrapped


@makebold
@makeitalic
def hello():
    &quot;&quot;&quot;a decorated hello world&quot;&quot;&quot;
    return &quot;hello world&quot;

if __name__ == &#39;__main__&#39;:
    print(&#39;result:{}   name:{}   doc:{}&#39;.format(hello(), hello.__name__, hello.__doc__))

### OUTPUT ###
# result:&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;hello world&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;   name:hello   doc:a decorated hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. 外观模式&lt;/h2&gt;

&lt;p&gt;　　外观模式（Facade pattern），是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。&lt;/p&gt;

&lt;h3&gt;5.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time

SLEEP = 0.5


# Complex Parts
class TC1:

    def run(self):
        print(&quot;###### In Test 1 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


class TC2:

    def run(self):
        print(&quot;###### In Test 2 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


class TC3:

    def run(self):
        print(&quot;###### In Test 3 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


# Facade
class TestRunner:

    def __init__(self):
        self.tc1 = TC1()
        self.tc2 = TC2()
        self.tc3 = TC3()
        self.tests = [i for i in (self.tc1, self.tc2, self.tc3)]

    def runAll(self):
        [i.run() for i in self.tests]


# Client
if __name__ == &#39;__main__&#39;:
    testrunner = TestRunner()
    testrunner.runAll()

### OUTPUT ###
# ###### In Test 1 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
# ###### In Test 2 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
# ###### In Test 3 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结之行为型模式</title>
     <link href="/design-pattern-behavior-pattern"/>
     <updated>2015-03-12T00:00:00+08:00</updated>
     <id>/design-pattern-behavior-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 迭代器模式&lt;/h2&gt;

&lt;p&gt;　　提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。迭代器模式的结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。&lt;/li&gt;
&lt;li&gt;具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。&lt;/li&gt;
&lt;li&gt;抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(),&lt;/li&gt;
&lt;li&gt;迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;1.1 Python源码实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/
Implementation of the iterator pattern with a generator&quot;&quot;&quot;


def count_to(count):
    &quot;&quot;&quot;Counts by word numbers, up to a maximum of five&quot;&quot;&quot;
    numbers = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]
    # enumerate() returns a tuple containing a count (from start which
    # defaults to 0) and the values obtained from iterating over sequence
    for pos, number in zip(range(count), numbers):
        yield number

# Test the generator
count_to_two = lambda: count_to(2)
count_to_five = lambda: count_to(5)

print(&#39;Counting to two...&#39;)
for number in count_to_two():
    print(number, end=&#39; &#39;)

print()

print(&#39;Counting to five...&#39;)
for number in count_to_five():
    print(number, end=&#39; &#39;)

print()

### OUTPUT ###
# Counting to two...
# one two
# Counting to five...
# one two three four five
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 观察者模式&lt;/h2&gt;

&lt;p&gt;　　观察者模式（有时又被称为发布/订阅模式）是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。&lt;/p&gt;

&lt;h3&gt;2.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;
Reference: http://www.slideshare.net/ishraqabd/publish-subscribe-model-overview-13368808
Author: https://github.com/HanWenfang
&quot;&quot;&quot;


class Provider:

    def __init__(self):
        self.msg_queue = []
        self.subscribers = {}

    def notify(self, msg):
        self.msg_queue.append(msg)

    def subscribe(self, msg, subscriber):
        if msg not in self.subscribers:
            self.subscribers[msg] = []
            self.subscribers[msg].append(subscriber)  # unfair
        else:
            self.subscribers[msg].append(subscriber)

    def unsubscribe(self, msg, subscriber):
        self.subscribers[msg].remove(subscriber)

    def update(self):
        for msg in self.msg_queue:
            if msg in self.subscribers:
                for sub in self.subscribers[msg]:
                    sub.run(msg)
        self.msg_queue = []


class Publisher:

    def __init__(self, msg_center):
        self.provider = msg_center

    def publish(self, msg):
        self.provider.notify(msg)


class Subscriber:

    def __init__(self, name, msg_center):
        self.name = name
        self.provider = msg_center

    def subscribe(self, msg):
        self.provider.subscribe(msg, self)

    def run(self, msg):
        print(&quot;{} got {}&quot;.format(self.name, msg))


def main():
    message_center = Provider()

    fftv = Publisher(message_center)

    jim = Subscriber(&quot;jim&quot;, message_center)
    jim.subscribe(&quot;cartoon&quot;)
    jack = Subscriber(&quot;jack&quot;, message_center)
    jack.subscribe(&quot;music&quot;)
    gee = Subscriber(&quot;gee&quot;, message_center)
    gee.subscribe(&quot;movie&quot;)

    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;music&quot;)
    fftv.publish(&quot;ads&quot;)
    fftv.publish(&quot;movie&quot;)
    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;movie&quot;)
    fftv.publish(&quot;blank&quot;)

    message_center.update()


if __name__ == &quot;__main__&quot;:
    main()

### OUTPUT ###
# jim got cartoon
# jack got music
# gee got movie
# jim got cartoon
# jim got cartoon
# gee got movie
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 策略模式&lt;/h2&gt;

&lt;p&gt;　　策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。主要是应对：在软件构建过程中，某些对象使用的算法可能多种多样，经常发生变化。如果在对象内部实现这些算法，将会使对象变得异常复杂，甚至会造成性能上的负担。GoF《设计模式》中说道：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。该模式使得算法可独立于它们的客户变化。&lt;/p&gt;

&lt;h3&gt;3.1 Python 源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class Duck(object):
    # 上面使用继承，这里通用的使用参数方式，传入的就是操作工厂的类
    def __init__(self, strategy=None):
        self.action = None
        self.count = 0
        if strategy:
            # 指定策略，那么执行action就是用这个类的实例
            self.action = strategy()

    def fly(self, kind):
        if self.action:
            self.count += 1
            # 这里的第二个参数self，算是炫技吧，就是为了让操作的方法获得这里计算好的count
            return self.action.fly(kind, self)

        else:
            raise UnboundLocalError(&#39;Exception raised, no strategyClass supplied to Duck!&#39;)

# 注意这里没有继承Duck，因为是以参数的方式传入类名
class Duck1(object):

    def fly(self, kind, instance):
        return &#39;Duck1 fly kind: &#39; + kind + &#39;#&#39; + str(instance.count)


class Duck2(object):

    def fly(self, kind, instance):
        return &#39;Duck2 fly kind: &#39; + kind + &#39;#&#39; + str(instance.count)


if __name__ == &#39;__main__&#39;:
    duckfly = Duck()
    duck1fly = Duck(strategy=Duck1)
    duck2fly = Duck(strategy=Duck2)

    try:
        print duckfly.fly(&#39;yes&#39;)
    except Exception as e:
        print &quot;The following exception was expected:&quot;
        print e

    print duck1fly.fly(&#39;yes&#39;)
    print duck1fly.fly(&#39;no&#39;)
    print duck1fly.fly(&#39;yes&#39;)
    print duck2fly.fly(&#39;yes&#39;)
    print duck2fly.fly(&#39;no&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 模板方法模式&lt;/h2&gt;

&lt;p&gt;　　模板方法模式定义了一个算法的步骤，并允许次类别为一个或多个步骤提供其实践方式。让次类别在不改变算法架构的情况下，重新定义算法中的某些步骤。在软件工程中，它是一种软件设计模式，和C++模板没有关连。也可以理解为定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。因此模板方法使得子类可以在不改变一个算法的结构的情况下重新定义该算法的某些特定变量。优点是把不变行为搬移到超类，去除子类中的重复代码。&lt;/p&gt;

&lt;h3&gt;4.1 Python源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;http://blog.csdn.net/five3/article/details/7564578&quot;&gt;csdn.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python  
#encoding: utf-8  

class template:
    def __init__(self):
        pass

    def logic(self):
        print &#39;do something before ....&#39;
        print self.do_something_now()
        print &#39;do something after ....&#39;

    def do_something_now(self):
        return None      

class apply_temp1(template):
    def __init__(self):
        pass

    def do_something_now(self):
        return &#39;apply 1&#39;  

class apply_temp2(template):
    def __init__(self):
        pass

    def do_something_now(self):
        return &#39;apply 2&#39;  


if &#39;__main__&#39; == __name__:  
    obj1 = apply_temp1()
    obj2 = apply_temp2()
    obj1.logic()
    obj2.logic()
    print obj1.__class__
    print obj2.__class__
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结之创建型模式</title>
     <link href="/design-pattern-create-pattern"/>
     <updated>2015-03-11T00:00:00+08:00</updated>
     <id>/design-pattern-create-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 抽象工厂模式&lt;/h2&gt;

&lt;p&gt;　　抽象工厂模式（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。&lt;/p&gt;

&lt;p&gt;　　举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建邮件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（邮件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“邮件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“邮件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“邮件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“邮件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。&lt;/p&gt;

&lt;p&gt;　　“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。&lt;/p&gt;

&lt;p&gt;　　使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。&lt;/p&gt;

&lt;h3&gt;1.1 Python 源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;https://github.com/faif/python-patterns/&quot;&gt;github:python-patterns&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

# http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/

&quot;&quot;&quot;Implementation of the abstract factory pattern&quot;&quot;&quot;

import random

class PetShop:

    &quot;&quot;&quot;A pet shop&quot;&quot;&quot;

    def __init__(self, animal_factory=None):
        &quot;&quot;&quot;pet_factory is our abstract factory.  We can set it at will.&quot;&quot;&quot;

        self.pet_factory = animal_factory

    def show_pet(self):
        &quot;&quot;&quot;Creates and shows a pet using the abstract factory&quot;&quot;&quot;

        pet = self.pet_factory.get_pet()
        print(&quot;We have a lovely {}&quot;.format(pet))
        print(&quot;It says {}&quot;.format(pet.speak()))
        print(&quot;We also have {}&quot;.format(self.pet_factory.get_food()))


# Stuff that our factory makes

class Dog:

    def speak(self):
        return &quot;woof&quot;

    def __str__(self):
        return &quot;Dog&quot;


class Cat:

    def speak(self):
        return &quot;meow&quot;

    def __str__(self):
        return &quot;Cat&quot;


# Factory classes

class DogFactory:

    def get_pet(self):
        return Dog()

    def get_food(self):
        return &quot;dog food&quot;


class CatFactory:

    def get_pet(self):
        return Cat()

    def get_food(self):
        return &quot;cat food&quot;

# Create the proper family
def get_factory():
    &quot;&quot;&quot;Let&#39;s be dynamic!&quot;&quot;&quot;
    return random.choice([DogFactory, CatFactory])()


# Show pets with various factories
if __name__ == &quot;__main__&quot;:
    for i in range(3):
        shop = PetShop(get_factory())
        shop.show_pet()
        print(&quot;=&quot; * 20)

### OUTPUT ###
# We have a lovely Dog
# It says woof
# We also have dog food
# ====================
# We have a lovely Dog
# It says woof
# We also have dog food
# ====================
# We have a lovely Cat
# It says meow
# We also have cat food
# ====================
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2.工厂方法模式&lt;/h2&gt;

&lt;p&gt;　　工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”&lt;/p&gt;

&lt;p&gt;　　创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。&lt;/p&gt;

&lt;p&gt;　　对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。&lt;/p&gt;

&lt;p&gt;　　如果抛开设计模式的范畴，“工厂方法”这个词也可以指作为“工厂”的方法，这个方法的主要目的就是创建对象，而这个方法不一定在单独的工厂类中。这些方法通常作为静态方法，定义在方法所实例化的类中。&lt;/p&gt;

&lt;p&gt;　　每个工厂方法都有特定的名称。在许多面向对象的编程语言中，构造方法必须和它所在的类具有相同的名称，这样的话，如果有多种创建对象的方式（重载）就可能导致歧义。工厂方法没有这种限制，所以可以具有描述性的名称。举例来说，根据两个实数创建一个复数，而这两个实数表示直角坐标或极坐标，如果使用工厂方法，方法的含义就非常清晰了。当工厂方法起到这种消除歧义的作用时，构造方法常常被设置为私有方法，从而强制客户端代码使用工厂方法创建对象。&lt;/p&gt;

&lt;h3&gt;2.1 Python 源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;https://github.com/faif/python-patterns/&quot;&gt;github:python-patterns&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/&quot;&quot;&quot;


class GreekGetter:

    &quot;&quot;&quot;A simple localizer a la gettext&quot;&quot;&quot;

    def __init__(self):
        self.trans = dict(dog=&quot;σκύλος&quot;, cat=&quot;γάτα&quot;)

    def get(self, msgid):
        &quot;&quot;&quot;We&#39;ll punt if we don&#39;t have a translation&quot;&quot;&quot;
        try:
            return self.trans[msgid]
        except KeyError:
            return str(msgid)


class EnglishGetter:

    &quot;&quot;&quot;Simply echoes the msg ids&quot;&quot;&quot;

    def get(self, msgid):
        return str(msgid)


def get_localizer(language=&quot;English&quot;):
    &quot;&quot;&quot;The factory method&quot;&quot;&quot;
    languages = dict(English=EnglishGetter, Greek=GreekGetter)
    return languages[language]()

# Create our localizers
e, g = get_localizer(language=&quot;English&quot;), get_localizer(language=&quot;Greek&quot;)
# Localize some text
for msgid in &quot;dog parrot cat bear&quot;.split():
    print(e.get(msgid), g.get(msgid))

### OUTPUT ###
# dog σκύλος
# parrot parrot
# cat γάτα
# bear bear
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 单例模式&lt;/h2&gt;

&lt;p&gt;　　单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。&lt;/p&gt;

&lt;p&gt;　　实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。&lt;/p&gt;

&lt;p&gt;　　单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。&lt;/p&gt;

&lt;h3&gt;3.1 Python源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;http://blog.csdn.net/ghostfromheaven/article/details/7671853&quot;&gt;csdn.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#-*- encoding=utf-8 -*-
print &#39;----------------------方法1--------------------------&#39;
#方法1,实现__new__方法
#并在将一个类的实例绑定到类变量_instance上,
#如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回
#如果cls._instance不为None,直接返回cls._instance
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, &#39;_instance&#39;):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1

one = MyClass()
two = MyClass()

two.a = 3
print one.a
#3
#one和two完全相同,可以用id(), ==, is检测
print id(one)
#29097904
print id(two)
#29097904
print one == two
#True
print one is two
#True

print &#39;----------------------方法2--------------------------&#39;
#方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)
#同一个类的所有实例天然拥有相同的行为(方法),
#只需要保证同一个类的所有实例具有相同的状态(属性)即可
#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)
#可参看:http://code.activestate.com/recipes/66531/
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1

one = MyClass2()
two = MyClass2()

#one和two是两个不同的对象,id, ==, is对比结果可看出
two.a = 3
print one.a
#3
print id(one)
#28873680
print id(two)
#28873712
print one == two
#False
print one is two
#False
#但是one和two具有相同的（同一个__dict__属性）,见:
print id(one.__dict__)
#30104000
print id(two.__dict__)
#30104000

print &#39;----------------------方法3--------------------------&#39;
#方法3:本质上是方法1的升级（或者说高级）版
#使用__metaclass__（元类）的高级python用法
class Singleton2(type):
    def __init__(cls, name, bases, dict):
        super(Singleton2, cls).__init__(name, bases, dict)
        cls._instance = None
    def __call__(cls, *args, **kw):
        if cls._instance is None:
            cls._instance = super(Singleton2, cls).__call__(*args, **kw)
        return cls._instance

class MyClass3(object):
    __metaclass__ = Singleton2

one = MyClass3()
two = MyClass3()

two.a = 3
print one.a
#3
print id(one)
#31495472
print id(two)
#31495472
print one == two
#True
print one is two
#True

print &#39;----------------------方法4--------------------------&#39;
#方法4:也是方法1的升级（高级）版本,
#使用装饰器(decorator),
#这是一种更pythonic,更elegant的方法,
#单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的
def singleton(cls, *args, **kw):
    instances = {}
    def _singleton():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return _singleton

@singleton
class MyClass4(object):
    a = 1
    def __init__(self, x=0):
        self.x = x

one = MyClass4()
two = MyClass4()

two.a = 3
print one.a
#3
print id(one)
#29660784
print id(two)
#29660784
print one == two
#True
print one is two
#True
one.x = 1
print one.x
#1
print two.x
#1
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>IPython 学习</title>
     <link href="/ipython-learning"/>
     <updated>2015-03-10T00:00:00+08:00</updated>
     <id>/ipython-learning</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;　　最近一直在学习spark，延伸到学习IPython，发现IPython这东西还真是不一般啊，所以决定还是应该坐下了认真学习一下。下面都是我在官网上学习时的笔记了。&lt;/p&gt;

&lt;h2&gt;2. 前言&lt;/h2&gt;

&lt;p&gt;　　IPython provides a rich architecture for interactive computing with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Powerful interactive shells (terminal and Qt-based).&lt;/li&gt;
&lt;li&gt;A browser-based notebook with support for code, text, mathematical expressions, inline plots and other rich media.&lt;/li&gt;
&lt;li&gt;Support for interactive data visualization and use of GUI toolkits.&lt;/li&gt;
&lt;li&gt;Flexible, embeddable interpreters to load into your own projects.&lt;/li&gt;
&lt;li&gt;Easy to use, high performance tools for parallel computing.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　IPython 3.x will be the last monolithic release of IPython, containing the notebook server, qtconsole, etc. The language-agnostic parts of the project: the notebook format, message protocol, qtconsole, notebook web application, etc. will move to new projects under the name Jupyter. IPython itself will return to being focused on interactive Python, part of which will be providing a Python kernel for Jupyter.&lt;/p&gt;

&lt;h2&gt;3. 介绍&lt;/h2&gt;

&lt;p&gt;　　The goal of IPython is to create a comprehensive environment for interactive and exploratory computing. To support this goal, IPython has three main components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An enhanced interactive Python shell.&lt;/li&gt;
&lt;li&gt;A decoupled two-process communication model, which allows for multiple clients to connect to a computation kernel, most notably the web-based notebook&lt;/li&gt;
&lt;li&gt;An architecture for interactive parallel computing.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.1 Enhanced interactive Python shell&lt;/h3&gt;

&lt;p&gt;　　看官网。&lt;a href=&quot;http://ipython.org/ipython-doc/stable/overview.html#ipythonzmq&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3.2 Decoupled two-process model&lt;/h3&gt;

&lt;p&gt;　　IPython has abstracted and extended the notion of a traditional Read-Evaluate-Print Loop (REPL) environment by decoupling the evaluation into its own process. We call this process a kernel: it receives execution instructions from clients and communicates the results back to them.&lt;/p&gt;

&lt;p&gt;　　This decoupling allows us to have several clients connected to the same kernel, and even allows clients and kernels to live on different machines. With the exclusion of the traditional single process terminal-based IPython (what you start if you run ipython without any subcommands), all other IPython machinery uses this two-process model. This includes ipython console, ipython qtconsole, and ipython notebook.&lt;/p&gt;

&lt;p&gt;　　As an example, this means that when you start ipython qtconsole, you’re really starting two processes, a kernel and a Qt-based client can send commands to and receive results from that kernel. If there is already a kernel running that you want to connect to, you can pass the --existing flag which will skip initiating a new kernel and connect to the most recent kernel, instead. To connect to a specific kernel once you have several kernels running, use the %connect_info magic to get the unique connection file, which will be something like --existing kernel-19732.json but with different numbers which correspond to the Process ID of the kernel.&lt;/p&gt;

&lt;p&gt;　　You can read more about using ipython qtconsole, and ipython notebook. There is also a message spec which documents the protocol for communication between kernels and clients.&lt;/p&gt;

&lt;p&gt;　　zeppelin也是用了这样的机制的，看来databricks也是这样搞的。关于这个机制，这篇notebook有简单的&lt;a href=&quot;http://nbviewer.ipython.org/github/ipython/ipython/blob/1.x/examples/notebooks/Frontend-Kernel%20Model.ipynb&quot;&gt;描述&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3.3 Interactive parallel computing&lt;/h3&gt;

&lt;p&gt;　　看官网。&lt;/p&gt;

&lt;h2&gt;4. 安装&lt;/h2&gt;

&lt;p&gt;　　还是看&lt;a href=&quot;../http://ipython.org/ipython-doc/stable/install/install.html&quot;&gt;官网&lt;/a&gt;有用，主要还是要解决依赖的问题，最好的方法就是 pip install &quot;ipython[all]&quot;。&lt;/p&gt;

&lt;h2&gt;5. Using IPython for interactive work&lt;/h2&gt;

&lt;h3&gt;5.1 Introducing IPython&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;常用的四个帮助方法：

&lt;ul&gt;
&lt;li&gt;? ：  Introduction and overview of IPython’s features.&lt;/li&gt;
&lt;li&gt;%quickref ：  Quick reference.&lt;/li&gt;
&lt;li&gt;help ：   Python’s own help system.&lt;/li&gt;
&lt;li&gt;object? ： Details about ‘object’, use ‘object??’ for extra details.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　Typing object_name? will print all sorts of details about any object, including docstrings, function definition lines (for call arguments) and constructor details for classes. To get specific information on an object, you can use the magic commands %pdoc, %pdef, %psource and %pfile&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configuration&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Much of IPython can be tweaked through configuration. To get started, use the command ipython profile create to produce the default config files. These will be placed in ~/.ipython/profile_default, and contain comments explaining what the various options do.&lt;/p&gt;

&lt;p&gt;Profiles allow you to use IPython for different tasks, keeping separate config files and history for each one. More details in the profiles section.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Startup Files&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If you want some code to be run at the beginning of every IPython session, the easiest way is to add Python (.py) or IPython (.ipy) scripts to your profile_default/startup/ directory. Files here will be executed as soon as the IPython shell is constructed, before any other code or scripts you have specified. The files will be run in order of their names, so you can control the ordering with prefixes, like 10-myimports.py.&lt;/p&gt;

&lt;h3&gt;5.2 IPython reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Command-line usage&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;You start IPython with the command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ipython [options] files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If invoked with no options, it executes all the files listed in sequence and drops you into the interpreter while still acknowledging any options you may have set in your ipython_config.py. This behavior is different from standard Python, which when called as python -i will only execute one file and ignore your configuration setup.&lt;/p&gt;

&lt;p&gt;Please note that some of the configuration options are not available at the command line, simply because they are not practical here. Look into your configuration files for details on those. There are separate configuration files for each profile, and the files look like ipython_config.py or ipython_config_frontendname.py. Profile directories look like profile_profilename and are typically installed in the IPYTHONDIR directory, which defaults to $HOME/.ipython. For Windows users, HOME resolves to C:\Users\YourUserName in most instances.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IPython as your default Python environment&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Python honors the environment variable PYTHONSTARTUP and will execute at startup the file referenced by this variable. If you put the following code at the end of that file, then IPython will be your working environment anytime you start Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os, IPython
os.environ[&#39;PYTHONSTARTUP&#39;] = &#39;&#39;  # Prevent running this again
IPython.start_ipython()
raise SystemExit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The raise SystemExit is needed to exit Python when it finishes, otherwise you’ll be back at the normal Python &gt;&gt;&gt; prompt.&lt;/p&gt;

&lt;p&gt;This is probably useful to developers who manage multiple Python versions and don’t want to have correspondingly multiple IPython versions. Note that in this mode, there is no way to pass IPython any command-line options, as those are trapped first by Python itself.&lt;/p&gt;

&lt;h2&gt;6. The IPython notebook&lt;/h2&gt;

&lt;h3&gt;6.1 Running a notebook server&lt;/h3&gt;

&lt;p&gt;The IPython notebook web-application is based on a server-client structure. This server uses a &lt;strong&gt;&lt;em&gt;two-process kernel architecture&lt;/em&gt;&lt;/strong&gt; based on &lt;strong&gt;&lt;em&gt;ZeroMQ&lt;/em&gt;&lt;/strong&gt;, as well as &lt;strong&gt;&lt;em&gt;Tornado&lt;/em&gt;&lt;/strong&gt; for serving HTTP requests. By default, a notebook server runs on http://127.0.0.1:8888/ and is accessible only from localhost. This document describes how you can secure a notebook server and how to run it on a public interface.&lt;/p&gt;

&lt;h2&gt;7. Using IPython for parallel computing&lt;/h2&gt;

&lt;p&gt;目前研究的方向和IPython自身的parallel关联不大，暂时不看这块。&lt;/p&gt;

&lt;h2&gt;8. Configuration and customization&lt;/h2&gt;

&lt;h3&gt;8.1 Serveral config methods&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Config files&lt;/li&gt;
&lt;li&gt;Command line arguments&lt;/li&gt;
&lt;li&gt;The config magics&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;8.2 IPython options&lt;/h3&gt;

&lt;p&gt;重点研究notebook options和kernel options，细节用到时再仔细看。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Terminal IPython options&lt;/li&gt;
&lt;li&gt;IPython kernel options&lt;/li&gt;
&lt;li&gt;IPython notebook options&lt;/li&gt;
&lt;li&gt;IPython Qt console options&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;8.3 IPython extensions&lt;/h3&gt;

&lt;p&gt;A level above configuration are IPython extensions, Python modules which modify the behaviour of the shell. They are referred to by an importable module name, and can be placed anywhere you’d normally import from, or in .ipython/extensions/.&lt;/p&gt;

&lt;p&gt;Getting extensions
A few important extensions are bundled with IPython. Others can be found on the extensions index on the wiki, and the Framework :: IPython tag on PyPI.&lt;/p&gt;

&lt;p&gt;Extensions on PyPI can be installed using pip, like any other Python package. Other simple extensions can be installed with the %install_ext magic. The latter does no validation, so be careful using it on untrusted networks like public wifi.&lt;/p&gt;

&lt;p&gt;Using extensions
To load an extension while IPython is running, use the %load_ext magic:
&lt;code&gt;
In [1]: %load_ext myextension
&lt;/code&gt;
To load it each time IPython starts, list it in your configuration file:
&lt;code&gt;
c.InteractiveShellApp.extensions = [
    &#39;myextension&#39;
]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Writing extensions
An IPython extension is an importable Python module that has a couple of special functions to load and unload it. Here is a template:
```&lt;/p&gt;

&lt;h1&gt;myextension.py&lt;/h1&gt;

&lt;p&gt;def load_ipython_extension(ipython):
    # The &lt;code&gt;ipython&lt;/code&gt; argument is the currently active &lt;code&gt;InteractiveShell&lt;/code&gt;
    # instance, which can be used in any way. This allows you to register
    # new magics or aliases, for example.&lt;/p&gt;

&lt;p&gt;def unload_ipython_extension(ipython):
    # If you want your extension to be unloadable, put that logic here.
```
This load_ipython_extension() function is called after your extension is imported, and the currently active InteractiveShell instance is passed as the only argument. You can do anything you want with IPython at that point.&lt;/p&gt;

&lt;p&gt;load_ipython_extension() will be called again if you load or reload the extension again. It is up to the extension author to add code to manage that.&lt;/p&gt;

&lt;p&gt;Useful InteractiveShell methods include register_magic_function(), push() (to add variables to the user namespace) and drop_by_id() (to remove variables on unloading).&lt;/p&gt;

&lt;p&gt;My extensions dir:
/root/anaconda/lib/python2.7/site-packages/IPython/entensions/&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Defining custom magics&lt;/strong&gt;
There are two main ways to define your own magic functions: from standalone functions and by inheriting from a base class provided by IPython: IPython.core.magic.Magics. Below we show code you can place in a file that you load from your configuration, such as any file in the startup subdirectory of your default IPython profile.&lt;/p&gt;

&lt;p&gt;First, let us see the simplest case. The following shows how to create a line magic, a cell one and one that works in both modes, using just plain functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from IPython.core.magic import (register_line_magic, register_cell_magic,
                                register_line_cell_magic)

@register_line_magic
def lmagic(line):
    &quot;my line magic&quot;
    return line

@register_cell_magic
def cmagic(line, cell):
    &quot;my cell magic&quot;
    return line, cell

@register_line_cell_magic
def lcmagic(line, cell=None):
    &quot;Magic that works both as %lcmagic and as %%lcmagic&quot;
    if cell is None:
        print(&quot;Called as line magic&quot;)
        return line
    else:
        print(&quot;Called as cell magic&quot;)
        return line, cell

# We delete these to avoid name conflicts for automagic to work
del lmagic, lcmagic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also create magics of all three kinds by inheriting from the IPython.core.magic.Magics class. This lets you create magics that can potentially hold state in between calls, and that have full access to the main IPython object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This code can be put in any Python module, it does not require IPython
# itself to be running already.  It only creates the magics subclass but
# doesn&#39;t instantiate it yet.
from __future__ import print_function
from IPython.core.magic import (Magics, magics_class, line_magic,
                                cell_magic, line_cell_magic)

# The class MUST call this class decorator at creation time
@magics_class
class MyMagics(Magics):

    @line_magic
    def lmagic(self, line):
        &quot;my line magic&quot;
        print(&quot;Full access to the main IPython object:&quot;, self.shell)
        print(&quot;Variables in the user namespace:&quot;, list(self.shell.user_ns.keys()))
        return line

    @cell_magic
    def cmagic(self, line, cell):
        &quot;my cell magic&quot;
        return line, cell

    @line_cell_magic
    def lcmagic(self, line, cell=None):
        &quot;Magic that works both as %lcmagic and as %%lcmagic&quot;
        if cell is None:
            print(&quot;Called as line magic&quot;)
            return line
        else:
            print(&quot;Called as cell magic&quot;)
            return line, cell


# In order to actually use these magics, you must register them with a
# running IPython.  This code must be placed in a file that is loaded once
# IPython is up and running:
ip = get_ipython()
# You can register the class itself without instantiating it.  IPython will
# call the default constructor on it.
ip.register_magics(MyMagics)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to create a class with a different constructor that holds additional state, then you should always call the parent constructor and instantiate the class yourself before registration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@magics_class
class StatefulMagics(Magics):
    &quot;Magics that hold additional state&quot;

    def __init__(self, shell, data):
        # You must call the parent constructor
        super(StatefulMagics, self).__init__(shell)
        self.data = data

    # etc...

# This class must then be registered with a manually created instance,
# since its constructor has different arguments from the default:
ip = get_ipython()
magics = StatefulMagics(ip, some_data)
ip.register_magics(magics)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In earlier versions, IPython had an API for the creation of line magics (cell magics did not exist at the time) that required you to create functions with a method-looking signature and to manually pass both the function and the name. While this API is no longer recommended, it remains indefinitely supported for backwards compatibility purposes. With the old API, you’d create a magic as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def func(self, line):
    print(&quot;Line magic called with line:&quot;, line)
    print(&quot;IPython object:&quot;, self.shell)

ip = get_ipython()
# Declare this function as the magic %mycommand
ip.define_magic(&#39;mycommand&#39;, func)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;9. IPython developer’s guide&lt;/h2&gt;

&lt;p&gt;This are two categories of developer focused documentation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Documentation for developers of IPython itself.&lt;/li&gt;
&lt;li&gt;Documentation for developers of third party tools and libraries that use IPython.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This part of our documentation only contains information in the second category.&lt;/p&gt;

&lt;p&gt;Developers interested in working on IPython itself should consult our developer information on the IPython GitHub wiki.&lt;/p&gt;

&lt;h2&gt;10 How IPython works&lt;/h2&gt;

&lt;h3&gt;10.1 Terminal IPython&lt;/h3&gt;

&lt;p&gt;When you type ipython, you get the original IPython interface, running in the terminal. It does something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while True:
    code = input(&quot;&amp;gt;&amp;gt;&amp;gt; &quot;)
    exec(code)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, it’s much more complex, because it has to deal with multi-line code, tab completion using readline, magic commands, and so on. But the model is like that: prompt the user for some code, and when they’ve entered it, exec it in the same process. This model is often called a REPL, or Read-Eval-Print-Loop.&lt;/p&gt;

&lt;h3&gt;10.2 The IPython Kernel&lt;/h3&gt;

&lt;p&gt;All the other interfaces—the Notebook, the Qt console, ipython console in the terminal, and third party interfaces—use the IPython Kernel. This is a separate process which is responsible for running user code, and things like computing possible completions. Frontends communicate with it using JSON messages sent over ZeroMQ sockets; the protocol they use is described in Messaging in IPython.&lt;/p&gt;

&lt;p&gt;The core execution machinery for the kernel is shared with terminal IPython:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ipy_kernel_and_terminal.png&quot; alt=&quot;ipy_kernel_and_terminal.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A kernel process can be connected to more than one frontend simultaneously. In this case, the different frontends will have access to the same variables.&lt;/p&gt;

&lt;p&gt;This design was intended to allow easy development of different frontends based on the same kernel, but it also made it possible to support new languages in the same frontends, by developing kernels in those languages, and we are refining IPython to make that more practical.&lt;/p&gt;

&lt;p&gt;Today, there are two ways to develop a kernel for another language. Wrapper kernels reuse the communications machinery from IPython, and implement only the core execution part. Native kernels implement execution and communications in the target language:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/other_kernels.png&quot; alt=&quot;other_kernels.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Wrapper kernels are easier to write quickly for languages that have good Python wrappers, like octave_kernel, or languages where it’s impractical to implement the communications machinery, like bash_kernel. Native kernels are likely to be better maintained by the community using them, like IJulia or IHaskell.&lt;/p&gt;

&lt;h3&gt;10.3 Notebook&lt;/h3&gt;

&lt;p&gt;The Notebook frontend does something extra. In addition to running your code, it stores code and output, together with markdown notes, in an editable document called a notebook. When you save it, this is sent from your browser to the notebook server, which saves it on disk as a JSON file with a .ipynb extension.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/notebook_components.png&quot; alt=&quot;notebook_components.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The notebook server, not the kernel, is responsible for saving and loading notebooks, so you can edit notebooks even if you don’t have the kernel for that language—you just won’t be able to run code. The kernel doesn’t know anything about the notebook document: it just gets sent cells of code to execute when the user runs them.&lt;/p&gt;

&lt;p&gt;The Nbconvert tool in IPython converts notebook files to other formats, such as HTML, LaTeX, or reStructuredText. This conversion goes through a series of steps:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/nbconvert.png&quot; alt=&quot;nbconvert.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preprocessors modify the notebook in memory. E.g. ExecutePreprocessor runs the code in the notebook and updates the output.&lt;/li&gt;
&lt;li&gt;An exporter converts the notebook to another file format. Most of the exporters use templates for this.&lt;/li&gt;
&lt;li&gt;Postprocessors work on the file produced by exporting.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The nbviewer website uses nbconvert with the HTML exporter. When you give it a URL, it fetches the notebook from that URL, converts it to HTML, and serves that HTML to you.&lt;/p&gt;

&lt;h2&gt;11. Messaging in IPython&lt;/h2&gt;

&lt;p&gt;The IPython message specification is versioned independently of IPython. The current version of the specification is 5.0.&lt;/p&gt;

&lt;h3&gt;11.1 Introduction&lt;/h3&gt;

&lt;p&gt;This document explains the basic communications design and messaging specification for how the various IPython objects interact over a network transport. The current implementation uses the ZeroMQ library for messaging within and between hosts.&lt;/p&gt;

&lt;p&gt;The basic design is explained in the following diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/frontend-kernel.png&quot; alt=&quot;frontend-kernel.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A single kernel can be simultaneously connected to one or more frontends. The kernel has three sockets that serve the following functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Shell: this single ROUTER socket allows multiple incoming connections from frontends, and this is the socket where requests for code execution, object information, prompts, etc. are made to the kernel by any frontend. The communication on this socket is a sequence of request/reply actions from each frontend and the kernel.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IOPub: this socket is the ‘broadcast channel’ where the kernel publishes all side effects (stdout, stderr, etc.) as well as the requests coming from any client over the shell socket and its own requests on the stdin socket. There are a number of actions in Python which generate side effects: print() writes to sys.stdout, errors generate tracebacks, etc. Additionally, in a multi-client scenario, we want all frontends to be able to know what each other has sent to the kernel (this can be useful in collaborative scenarios, for example). This socket allows both side effects and the information about communications taking place with one client over the shell channel to be made available to all clients in a uniform manner.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stdin: this ROUTER socket is connected to all frontends, and it allows the kernel to request input from the active frontend when raw_input() is called. The frontend that executed the code has a DEALER socket that acts as a ‘virtual keyboard’ for the kernel while this communication is happening (illustrated in the figure by the black outline around the central keyboard). In practice, frontends may display such kernel requests using a special input widget or otherwise indicating that the user is to type input for the kernel instead of normal commands in the frontend. &lt;br/&gt;
All messages are tagged with enough information (details below) for clients to know which messages come from their own interaction with the kernel and which ones are from other clients, so they can display each type appropriately.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Control: This channel is identical to Shell, but operates on a separate socket, to allow important messages to avoid queueing behind execution requests (e.g. shutdown or abort).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The actual format of the messages allowed on each of these channels is specified below. Messages are dicts of dicts with string keys and values that are reasonably representable in JSON. Our current implementation uses JSON explicitly as its message format, but this shouldn’t be considered a permanent feature. As we’ve discovered that JSON has non-trivial performance issues due to excessive copying, we may in the future move to a pure pickle-based raw message format. However, it should be possible to easily convert from the raw objects to JSON, since we may have non-python clients (e.g. a web frontend). As long as it’s easy to make a JSON version of the objects that is a faithful representation of all the data, we can communicate with such clients.&lt;/p&gt;

&lt;h3&gt;11.2 General Message Format&lt;/h3&gt;

&lt;p&gt;A message is defined by the following four-dictionary structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  # The message header contains a pair of unique identifiers for the
  # originating session and the actual message id, in addition to the
  # username for the process that generated the message.  This is useful in
  # collaborative settings where multiple users may be interacting with the
  # same kernel simultaneously, so that frontends can label the various
  # messages in a meaningful way.
  &#39;header&#39; : {
                &#39;msg_id&#39; : uuid,
                &#39;username&#39; : str,
                &#39;session&#39; : uuid,
                # All recognized message type strings are listed below.
                &#39;msg_type&#39; : str,
                # the message protocol version
                &#39;version&#39; : &#39;5.0&#39;,
     },

  # In a chain of messages, the header from the parent is copied so that
  # clients can track where messages come from.
  &#39;parent_header&#39; : dict,

  # Any metadata associated with the message.
  &#39;metadata&#39; : dict,

  # The actual content of the message must be a dict, whose structure
  # depends on the message type.
  &#39;content&#39; : dict,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;12. Making kernels for IPython&lt;/h2&gt;

&lt;p&gt;A ‘kernel’ is a program that runs and introspects the user’s code. IPython includes a kernel for Python code, and people have written kernels for several other languages.&lt;/p&gt;

&lt;p&gt;When IPython starts a kernel, it passes it a connection file. This specifies how to set up communications with the frontend.&lt;/p&gt;

&lt;p&gt;There are two options for writing a kernel:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You can reuse the IPython kernel machinery to handle the communications, and just describe how to execute your code. This is much simpler if the target language can be driven from Python. See Making simple Python wrapper kernels for details.&lt;/li&gt;
&lt;li&gt;You can implement the kernel machinery in your target language. This is more work initially, but the people using your kernel might be more likely to contribute to it if it’s in the language they know.&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;. 学习资源&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ipython.org/&quot;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ipython/ipython/wiki?path=Cookbook&quot;&gt;IPython Cookbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结</title>
     <link href="/design-pattern"/>
     <updated>2015-03-09T00:00:00+08:00</updated>
     <id>/design-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 设计模式概念&lt;/h2&gt;

&lt;p&gt;　　设计模式这个术语是由Erich Gamma等人在1990年代从建筑设计领域引入到计算机科学的。它是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 &lt;br/&gt;
　　设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。 &lt;br/&gt;
　　并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其它非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。&lt;/p&gt;

&lt;h2&gt;2. 模式分类&lt;/h2&gt;

&lt;p&gt;　　《设计模式》一书把设计模式分为创建型、结构性、行为型三大模式。把它们通过授权，聚合，诊断的概念来描述。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建型模式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;抽象工厂：为一个产品族提供了统一的创建接口，当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。&lt;/li&gt;
&lt;li&gt;工厂方法：定义一个接口用于创建对象，但是让子类觉得初始化那个类。工厂方法把一个类的初始化下方到子类。&lt;/li&gt;
&lt;li&gt;生成器：讲一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/li&gt;
&lt;li&gt;惰性初始：推迟对象的创建，数据的计算等需要耗费较多资源的操作，只有在第一次访问的时候才执行。&lt;/li&gt;
&lt;li&gt;对象池：通过回收利用对象避免获取和释放资源所需的昂贵成本。&lt;/li&gt;
&lt;li&gt;原型：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/li&gt;
&lt;li&gt;单例：确保一个类只有一个实例，并提供对该实例的全局访问。&lt;/li&gt;
&lt;li&gt;多例：确保一个类只有命名的实例，并提供对这些实例的全局访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构型模式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;适配器：将某个类的接口转化为客户端期望的另一个接口表示，适配器模式可以消除由于接口不匹配所造成的类兼容性问题。&lt;/li&gt;
&lt;li&gt;桥接：将一个抽象与实现解耦，以便两者可以独立地变化。&lt;/li&gt;
&lt;li&gt;组合：把多个对象组成树状结构来表示局部与整体，这样用户可以一样地对待单个对象和对象的组合。&lt;/li&gt;
&lt;li&gt;修饰：向某个对象动态地添加更多的功能，修饰模式是除类继承之外另一种扩展功能的方法。&lt;/li&gt;
&lt;li&gt;外观模式：为子系统的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/li&gt;
&lt;li&gt;享元：通过共享以便有效地支持大量小颗粒对象。&lt;/li&gt;
&lt;li&gt;代理：为其他对象提供一个代理以控制这个对象的访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;责任链：为接触请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。&lt;/li&gt;
&lt;li&gt;命令：将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化，对请求排队或者记录请求日志，以及支持可取消的操作。&lt;/li&gt;
&lt;li&gt;解释器：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。&lt;/li&gt;
&lt;li&gt;迭代器：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/li&gt;
&lt;li&gt;备忘录：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象，备忘录模式的用意是在不破坏封装的条件下，讲一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。&lt;/li&gt;
&lt;li&gt;观察者：在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动更新。&lt;/li&gt;
&lt;li&gt;策略：定义一个算法的系列，将其各个分装，并且使他们有交互性，策略模式使得算法在用户使用的时候能独立地改变。&lt;/li&gt;
&lt;li&gt;模板方法：模板方法模式准备一个抽象类，将部分逻辑以具体的方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。&lt;/li&gt;
&lt;li&gt;访问者：封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结果和作用于结构上的操作之间的耦合解开，使得操作集合可以相对自由的演化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. 2/8原则&lt;/h2&gt;

&lt;p&gt;　　本着2/8原则的指导，准备先仔细了解学习以下几种最常用的模式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建型模式：抽象工厂，工厂方法，单例模式；&lt;/li&gt;
&lt;li&gt;结构性模式：适配器，桥接，组合，修饰，外观；&lt;/li&gt;
&lt;li&gt;行为型模式：迭代器，观察者，模板，策略；&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>book-2. 苏黎世投机定律</title>
     <link href="/zurich-invest-principles"/>
     <updated>2015-03-01T00:00:00+08:00</updated>
     <id>/zurich-invest-principles</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;引言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;瑞士，贫瘠而多岩，国土面积相当于美国缅因州的一半，自然资源缺乏，没有石油，没有煤炭，甚至气候和地形也不太适合大多数农作物。但是三百多年来没有卷入任何一场欧洲战争，而且瑞士人是世界上最富有的国民之一，瑞士法郎也是世界上最强势的货币之一。&lt;/li&gt;
&lt;li&gt;本书讲述瑞士人如何投机赚钱，并总结其中的一些经验。&lt;/li&gt;
&lt;li&gt;人的一生不能逃避风险，而应当谨慎地投入风险。小心地去赌，保持收益大于损失的原则，去赌，去赢。&lt;/li&gt;
&lt;li&gt;不要整天想着薪水，没有一个人能靠薪水发财，倒是有不少人因此而一贫如洗。所以你必须放手一搏，投机才是你所需要的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;定律一：论冒险&lt;/h2&gt;

&lt;p&gt;如果你对从事的投机不感到忧虑，那么你冒的风险肯定不够。&lt;br/&gt;
该定律要求你把钱投入到风险事业中，不要怕遭受损失。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;大多数人紧紧抓着安全，仿佛他是世界上最重要的东西。&lt;/li&gt;
&lt;li&gt;任何投机家都会告诉你，如果你一生的主要目标是避免忧虑，那么你将永远贫困。&lt;/li&gt;
&lt;li&gt;生命应当是一场冒险活动，而不是一种单调的生活。&lt;/li&gt;
&lt;li&gt;冒险会使生命更有价值，冒险的途径是把自己暴露于风险之中。&lt;/li&gt;
&lt;li&gt;每种职业都有它的渴望和痛苦。&lt;/li&gt;
&lt;li&gt;一切的投资都是投机，唯一的差异是有人承认，有人不承认。&lt;/li&gt;
&lt;li&gt;苏黎世投机定律是讨论投机的，这一点毋庸置疑。他们绝不是要你疯狂地去冒险，只不过话说的比较直率而已。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律一&lt;/em&gt;&lt;/strong&gt;：始终要下有意义的赌注。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只下你负担得起损失的赌注。&lt;/li&gt;
&lt;li&gt;在投机的过程中，一开始你就要有甘心承受损失的心理准备。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律二&lt;/em&gt;&lt;/strong&gt;：避免过分分散风险&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分散风险会降低你的风险，但这也同时减少了你可能致富的希望。&lt;/li&gt;
&lt;li&gt;你所投入的机会越多，就越需要更多的时间去研究，这额能会把你弄得焦头烂额。&lt;/li&gt;
&lt;li&gt;千万不要为了多样化而分散资金，这样，你会变得像在超级市场里参加购物比赛一样，竞赛的目的只是快速装满篮子，回到家时却发现带了一堆昂贵但又不真正需要的物品。在投机中，你应该把钱放在值得冒险的事业里，永远不要为了分散风险的投资组合而从事太多项目的投机。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;定律二：论贪婪&lt;/h2&gt;

&lt;p&gt;尽早获利了结。 &lt;br/&gt;
该定律推荐不要等到涨势的顶峰，不要希望获利会一直持续下去，不要希望好运气会连续不断，要有“好运气是短暂的”心理。在你达到预定的目标时，立即获利了结。即使你周围的所有人都说暴涨将持续下去，你也要坚持自己的做法。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果你能战胜贪婪，这种自制的行为将使你比其他99%的追逐财富的人更能成为优秀的投机者。&lt;/li&gt;
&lt;li&gt;减少贪婪，你将有更多致富的机会。&lt;/li&gt;
&lt;li&gt;一旦渴望变得杂乱无章甚至失去控制，并达到一定程度时，它就会战胜你的意志，这就是贪婪。&lt;/li&gt;
&lt;li&gt;不要过度压榨你的运气。&lt;/li&gt;
&lt;li&gt;你总会有短暂的连续盈利的时候，千万不要让贪婪抓住了你。&lt;/li&gt;
&lt;li&gt;遵守贪婪定律，对某些人而言非常困难，主要困难可能就是怕后悔。&lt;/li&gt;
&lt;li&gt;永远不要去核对已经卖掉股票的股价。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律三&lt;/em&gt;&lt;/strong&gt;：预先决定利润目标，目标达成后，立即获利了结。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;到底赚多少才算够？贪婪是这个问题如此难解的主要原因，不管一个人已经拥有多少，他总是还要更多。&lt;/li&gt;
&lt;li&gt;钱来得太快会让你感觉这笔钱本来就应该是你的。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;定律三：论希望&lt;/h2&gt;

&lt;p&gt;船开始下沉时，不要祷告，赶紧脱身。
定律三告诉我，当困难到来时，不要等待，果断地离开它。
定律二告诉我们当事情顺利时该怎么办，而定律三要说的是，当情况不好时该如何拯救自己。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当你知道自己是怎么失败的时候，你就离成功不远了。&lt;/li&gt;
&lt;li&gt;一个业余的赌徒只会希望或祈祷好牌发到自己手里，但是职业赌徒研究的却是如何在逆境中生存。&lt;/li&gt;
&lt;li&gt;知道如何从困境中解脱，可能是最可贵的投机天赋。&lt;/li&gt;
&lt;li&gt;记住，当船刚开始下沉时，而不是等到已经下沉一半时，镇定地逃离这艘船，保全自己。&lt;/li&gt;
&lt;li&gt;拒绝认错本身就是最大的错误。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律四&lt;/em&gt;&lt;/strong&gt;：欣然接受小的损失，这是生活的一部分；尽管经历多次失败，但要设法一次振作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果你能坦然地停止损失，你将会很好地保护自己，你可能永远不会受到严重的伤害。&lt;/li&gt;
&lt;li&gt;只要等待，一切终会发生。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;定律四：论预测&lt;/h2&gt;

&lt;p&gt;人类的行为不能预测，不要相信任何未卜先知。&lt;br/&gt;
定律四告诉我们不要依靠预测来决定你的投机计划，因为它起不了作用。&lt;/p&gt;

&lt;h2&gt;定律五：论模式&lt;/h2&gt;

&lt;p&gt;在没有显示秩序之前，混乱并不危险。
定律五警告你，不要去设想一种模式，模式并不存在。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当你感觉到一个有秩序的世界正在形成时，你已经处于危险之中了。&lt;/li&gt;
&lt;li&gt;真实情况是：金钱世界从未有过秩序，甚至是混乱得没有条理的世界。&lt;/li&gt;
&lt;li&gt;为什么人们不可能找到投资的公式，原因是这个公式根本不存在。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律五&lt;/em&gt;&lt;/strong&gt;：警惕历史会重演的心理暗示。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;历史的缺陷是一种特殊的对模式的幻想。&lt;/li&gt;
&lt;li&gt;不要跌进这个陷阱，历史有时候的确会重演，但大多数时候它不是这样的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律六&lt;/em&gt;&lt;/strong&gt;：谨防图表分析的幻觉。
&lt;strong&gt;&lt;em&gt;次要定律七&lt;/em&gt;&lt;/strong&gt;：不要妄作因果关系。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;出发你能确切地看到一个原因在起作用，是真的看到它，否则你就要以最怀疑的态度看待所有的因果设想。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律八&lt;/em&gt;&lt;/strong&gt;：勿犯赌徒的荒谬心理。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你持续扔硬币，迟早会得到正面。但是在这个过程中并无规律可言，你不能预先知道它将何时开始，当它开始后，你也不会知道它将持续多久。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;定律六：论灵活&lt;/h2&gt;

&lt;p&gt;避免扎根，他们会妨碍你的灵活。
定律六要你保持灵活性，它告诫你，要避免因为扎根而丧失投机机会，比如忠诚的情感、持续等待回报的行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律九&lt;/em&gt;&lt;/strong&gt;：不要因为一起活练就的情绪而驻足于已经没有希望的投资活动。
&lt;strong&gt;&lt;em&gt;次要定律十&lt;/em&gt;&lt;/strong&gt;：如果有更吸引人的机会出现，要毫不迟疑放弃原来的事物。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果你根植于某些投机活动，它将迟早有损于你赚钱的目标。&lt;/li&gt;
&lt;li&gt;永远不要留恋旧事物，但是别忘了老朋友。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;定律七：论直觉&lt;/h2&gt;

&lt;p&gt;如果一个预感可以被解释，那么它就是指的依赖的。
定律七认为，嘲笑和一味相信预感都是错误的。虽然直觉不会都是正确的，但如果以谨慎和怀疑的态度对待它，它可能就是一个有利的投机工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律十一&lt;/em&gt;&lt;/strong&gt;：绝对不要把希望和直觉混为一谈。&lt;/p&gt;

&lt;h2&gt;定律八：论神秘主义&lt;/h2&gt;

&lt;p&gt;上帝创造世界的计划中，未必包括使你发财。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律十二&lt;/em&gt;&lt;/strong&gt;：占星术要是灵的话，占星学家们早就富裕了。
&lt;strong&gt;&lt;em&gt;次要定律十三&lt;/em&gt;&lt;/strong&gt;：不要过度迷信，如果你能泰然处之，也可以从中享受到一些乐趣。&lt;/p&gt;

&lt;h2&gt;定律九：论乐观与悲观&lt;/h2&gt;

&lt;p&gt;乐观就是预期最好的情况会发生，信心则是知道如何处理最坏的状况。绝不要仅仅因为乐观而采取投机活动。
定律九警告，乐观可能是投机者的敌人，它会使人感觉良好，因此它是危险的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将乐观应用于金钱冒险时，你就需要警惕了。这是一种危险的心理状态。&lt;/li&gt;
&lt;li&gt;知道如何处理最坏的情况，那就是信心。&lt;/li&gt;
&lt;li&gt;在你感到乐观时，判断一下，这种愉快的感觉是不是真正见过了事实的证明。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;定律十：论舆论&lt;/h2&gt;

&lt;p&gt;藐视大多数人的意见，因为他们很有可能是错的。
定律十教会我们，大多数人虽然不会一直主动滴犯错，但是犯错的机会还是比较大滴。
务必警惕不假思索地采取与大多数人相同或不同的立场，尤其是前者。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;真理通常由少数人掌握，而不是由多数人发现的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律十四&lt;/em&gt;&lt;/strong&gt;：不要追逐投机的风潮，最好的购买机会常常是没有人注意到他的时候。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当你周围的人都在冲你喊“不”的时候，你要想“是”是一件很困难的事情。&lt;/li&gt;
&lt;li&gt;当还没有一时到事情将如何发生的时候，新手早已被大多数人推动了。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;定律十一：论固执&lt;/h2&gt;

&lt;p&gt;如果第一次没能赚到钱，忘掉他，重新再来。
毅力是一种很好的品质，但不可随便运用到投机活动中。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;毅力对我们日常生活的很多方面都有帮助。在投机活动中，它有时可以引导你走向成功，但有时也会使你陷入困境。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;次要定律十五&lt;/em&gt;&lt;/strong&gt;：绝对不要用摊平法挽救失败的投资。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>［touch spark］10. Spark 学习资源集锦</title>
     <link href="/spark-resources"/>
     <updated>2015-03-01T00:00:00+08:00</updated>
     <id>/spark-resources</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;　　实际上，学习任何一门技术，最好的学习资料肯定是官网。但是，在我学习spark的过程中，我发现有两个理由告诉我为什么学习一门技术仍然需要一些官网之外的资料：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;广度：官网上的资料大都focus在技术本身的实现和用法，而有很多资料会提及这门技术的应用，以及实践、应用这门技术中遇到的坑，还有由这门技术衍生出来的其他辅助技术。&lt;/li&gt;
&lt;li&gt;深度：很多资料都会解析这门技术的实现以及原理，反应到官网上，大多都是API文档或技术架构；我发现，很多在官网上理解不了的细节，可能在一些资料上描述起来更明确。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　基于上面这两个原因，我准备把自己在学习Spark过程中有幸遇到的好的资料搜集起来，并从广度和深度两个方面来整理这些资料，希望对大家有所帮助。还有，我会整理一些和spark相关的第三方开源工具，相信这些工具在帮助大家构建基于spark的应用时会助一臂之力。&lt;/p&gt;

&lt;p&gt;　　所有这些我都会同步到github上：&lt;a href=&quot;https://github.com/litaotao/spark-materials&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;2. 资源列表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;广度&lt;/strong&gt;：&lt;a href=&quot;http://blog.cloudera.com/blog/2014/08/how-to-use-ipython-notebook-with-apache-spark/&quot;&gt;spark和ipython notebook结合&lt;/a&gt;&lt;br/&gt;
&lt;strong&gt;备注&lt;/strong&gt;：我参考这篇文章搭建了自己基于ipython notebook的分析平台，详细记录在这篇博客上了：&lt;a href=&quot;../ipython-notebook-server-spark&quot;&gt;当Ipython Notebook遇见Spark&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;广深&lt;/strong&gt;：&lt;a href=&quot;http://www.cs.berkeley.edu/~matei/papers/2012/nsdi_spark.pdf&quot;&gt;RDD论文英文版&lt;/a&gt; &lt;br/&gt;
&lt;strong&gt;备注&lt;/strong&gt;：这篇论文绝对值得多读和深读，中文版在&lt;a href=&quot;https://code.csdn.net/CODE_Translation/spark_matei_phd&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个对Spark 2分钟的介绍视频，如果有人要你介绍Spark，按照里面的说就perfect了。&lt;a href=&quot;https://www.youtube.com/watch?v=cs3_3LdCny8&quot;&gt;YouTube&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;Apache Spark is：&lt;/strong&gt;  &lt;br/&gt;
    + A data analytics, cluster computing framework;   &lt;br/&gt;
    + Fits into Hadoop open-source community, and builds on top of Hadoop     Distributed File System(HDFS);  &lt;br/&gt;
    + Not tied to two-stage MapReduce paradigm, it&#39;s performance up to 100 times faster than Hadoop MapReduce for certain applications;         &lt;br/&gt;
    + Provides primitives for in-memeory cluster computing;         &lt;br/&gt;
    + In-memory cluster computing allows user load data to cluster&#39;s memory and queried repeatedly;        &lt;br/&gt;
    + Suited for machine learning algorithms;&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;广深&lt;/strong&gt;：&lt;a href=&quot;http://down.51cto.com/tag-spark%E4%B8%93%E5%88%8A.html&quot;&gt;Spark专刊之：spark最佳学习路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;广深&lt;/strong&gt;：&lt;a href=&quot;http://down.51cto.com/tag-spark%E4%B8%93%E5%88%8A.html&quot;&gt;Spark专刊之：spark运行原理解析&lt;/a&gt;    &lt;br/&gt;
&lt;strong&gt;备注&lt;/strong&gt;：国人整理和翻译的spark学习资料，质量不错哦~&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. Spark相关的第三方开源工具&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Zeppelin&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官网：&lt;a href=&quot;http://zeppelin-project.org/&quot;&gt;http://zeppelin-project.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Hue&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官网：&lt;a href=&quot;http://gethue.com/&quot;&gt;http://gethue.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;IPyhon&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官网：&lt;a href=&quot;http://ipython.org/&quot;&gt;http://ipython.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ISpark&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github：&lt;a href=&quot;https://github.com/tribbloid/ISpark&quot;&gt;https://github.com/tribbloid/ISpark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;scala-notebook&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github: &lt;a href=&quot;https://github.com/Bridgewater/scala-notebook&quot;&gt;https://github.com/Bridgewater/scala-notebook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;spark-notebook&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github: &lt;a href=&quot;https://github.com/andypetrella/spark-notebook&quot;&gt;https://github.com/andypetrella/spark-notebook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Ipython-sql&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github: &lt;a href=&quot;https://github.com/catherinedevlin/ipython-sql&quot;&gt;https://github.com/catherinedevlin/ipython-sql&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;sparknotebook&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github: &lt;a href=&quot;https://github.com/hohonuuli/sparknotebook&quot;&gt;https://github.com/hohonuuli/sparknotebook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;spark-kernel&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github: &lt;a href=&quot;https://github.com/ibm-et/spark-kernel&quot;&gt;https://github.com/ibm-et/spark-kernel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;spark-jobserver&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github: &lt;a href=&quot;https://github.com/spark-jobserver/spark-jobserver&quot;&gt;https://github.com/spark-jobserver/spark-jobserver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;spark-packages&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官网：&lt;a href=&quot;http://spark-packages.org/&quot;&gt;http://spark-packages.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>今天发生了一件坏事，也发生了一件好事</title>
     <link href="/the-badest-thing-in-my-life"/>
     <updated>2015-02-06T00:00:00+08:00</updated>
     <id>/the-badest-thing-in-my-life</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;　　以前读过两篇文章，一片叫《为什么从现在起你应该写博客》，第二篇记不得了，但其中有一个中心思想，说的是你写的东西都是给别人看的，应该都是对别人有用的。看了第一篇文章，我从不久之前终于借助Github建立了自己的一个博客，记录自己的技术成长经历；看了第二篇文章，我几乎每周都会对自己有一个总结，而从不把这些总结发到博客上。因为我认为这些总结都是未来回忆自己年轻时的年少轻狂用的，不应该发到博客上了。&lt;br/&gt;
　　但是今天，发生了一件坏事，算是从小到大最丑的一件事了，但同时也是一件好事。至少以后别人再问我最丑的经历时，我有话可说了。&lt;/p&gt;

&lt;h2&gt;2. 人生最丑的事&lt;/h2&gt;

&lt;p&gt;　　今天在小组内做第二次关于spark的技术分享，讲得很烂，算是人生的一个污点了，具体经历就不讲了。但我保证这是历史和未来所有presentation中最烂的一次。我将从以下几个方面来记录这次事件，以后每次活动之前，我都要自己看看今天的这篇文章，告诫自己，不要在同一个地方跌倒两次。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;没有事先准备好&lt;br/&gt;
　　以后进行presentation，一定要提前半小时入场，把电脑环境配置好。今天失败的根本原因是一个自定义的配置文件在断网重连后没有进行source操作，导致IPython Notebook Server和Spark集群之间连接不上。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;紧急情况下不会冷静分析问题&lt;br/&gt;
　　在启动IPython Notebook后，发现 &lt;code&gt;from pyspark import SparkContext, SparkConf&lt;/code&gt; 不能成功，提示没有pyspark这个包。当时我就慌了，没有沿着本质去分析问题，然后在老板的催促和心慌当中就开始讲了，在大家的迷茫和我不知所以的回答中，我就这样浑浑噩噩的度过了几十分钟，中间还幸得一位同事解围。在最后几分钟的时候，我实在忍不住了，心想反正今天已经完蛋了，就不管别人在那里讨论什么了。我开始研究到底是什么原因导致Notebook Server连接不上spark集群。我首先查看了下IPython的配置，在 &lt;code&gt;~/.ipython/profile_pyspark/&lt;/code&gt; 目录下面，我先看ipython_notebook_config.py文件，发现没有什么异常的，心想也应该不会出现在这里吧，因为IPython notebook还是能用的，只是找不到pyspark这个包。我突然回忆起来，在当初配置spark+IPython的时候，需要设置一个启动脚本文件。接着，我查看了那个启动脚本，在 &lt;code&gt;/root/.ipython/profile_pyspark/startup/00-pyspark-setup.py&lt;/code&gt; 下，恍然大悟，我发现问题了，这个脚本是这样写的：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;import os
import sys

spark_home = os.environ.get(&#39;SPARK_HOME&#39;, None)

if not spark_home:
    raise ValueError(&#39;SPARK_HOME environment variable is not set&#39;)
sys.path.insert(0, os.path.join(spark_home, &#39;python&#39;))
sys.path.insert(0, os.path.join(spark_home, &#39;python/lib/py4j-0.8.2.1-src.zip&#39;))
#execfile(os.path.join(spark_home, &#39;python/pyspark/shell.py&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　Say，关键就是这句 &lt;code&gt;spark_home = os.environ.get(&#39;SPARK_HOME&#39;, None)&lt;/code&gt; 因为没有定义一个环境变量，因此不能在IPython Notebook的环境变量sys.path里加入pyspark包所在的地址。再想想自己在哪里定义了SPARK_HOME这个变量，明明就在Desktop下的&lt;code&gt;ipython_notebook_spark.bashrc&lt;/code&gt; 里，看看里面是怎么写的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;export SPARK_HOME=&quot;/usr/local/spark-1.2.0-bin-cdh4/&quot;
export PYSPARK_SUBMIT_ARGS=&quot;--master spark://10.21.208.21:7077 --deploy-mode client&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这下知道了，原因是自己定义的.bashrc文件在登出linux后会失效，而刚才把电脑带到会议室后重新连接的网络，linux console重新登出了，所以必须重新source这个文件。 &lt;br/&gt;
　　现在回想，其实应该在看到错误提示没有pyspark这个包的时候就应该发现这个问题了，之所以一开始没有推测出这个问题，有几个原因：一是在这种情况下发现错误，头脑发热发慌，不能冷静处理；二是自己对这部分技术没有掌握彻底；3是在学习一门新技术时，没有详细地把学习过程和一些操作过程记录下来，导致出问题后不能及时参考。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;表达不清 &lt;br/&gt;
　　还有一条经验就是表达不清楚，思路不清楚，回答别人的问题不够明确。在别人提问没有表达清晰时，自己没有和别人进行沟通就贸然回答，导致交流效率极低。曾经看过很多文章，都讲做技术的一定要努力提高自己的表达能力，我满不在乎，因为平时和大家感觉交流起来还算流畅的，没想到这次碰了瓷。得到一条宝贵的经验，以后再做分享的时候，一定要准备好详细讲稿和提纲。别人在提问时，一定要先把别人提问的问题搞清楚，理解了再进行回答。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一些细节问题 &lt;br/&gt;
　　这次分享出来本组人员，还有鹏哥和他们组的两个人员，这种情况下在开始前应该由主讲人[我]来互相介绍一下，介绍双方的人员和职责。 &lt;br/&gt;
　　在讲稿，PPT，程序准备的时候，要注意配色和字体，字体要大，颜色要和谐，让听众能清晰地看到投影仪的东西。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后&lt;br/&gt;
　　最后，我想说，这真的是人生最糟糕的一次经历，以后绝对不能出现同样的问题，在以后每次做分享的时候，我要多回头看看这篇文章，想想今天尴尬的我。今天的分享，远远没有达到预期效果，还耽误了大家不少时间，也影响了自己的形象。这种情况下不能逃避，我应该给参会的每个人员发封邮件表示歉意，这也是对别人的尊重。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. 感悟&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;机会，永远只给有所准备，并且已经准备好了的人；&lt;/li&gt;
&lt;li&gt;从每一件小事做起，把每一件小事做到极致；
&lt;img src=&quot;../images/make_little_thing_best.jpg&quot; alt=&quot;make_little_thing_best&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>［touch spark］9. 编译Zeppelin</title>
     <link href="/compile-zeppelin"/>
     <updated>2015-01-29T00:00:00+08:00</updated>
     <id>/compile-zeppelin</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;　　这篇记录是我按照&lt;a href=&quot;http://zeppelin-project.org/docs/install/install.html&quot;&gt;官网&lt;/a&gt;的步骤来写的，主要是记录在编译Zeppelin过程中的一些经验。&lt;br/&gt;
　　对于这类没有发布特别稳定版本的项目，我倾向于这样一种实践方法，在本地建两个文件夹：project, project-build，把project文件夹作为一个本地的repo，可以随时update到最新的源码，然后在project-build里构建，就算失败了也可以保证不会污染项目源文件。
　　再具体一点就是我在实践Zeppelin的时候使用的方法，如下所示，可以随时保证zeppelin文件夹里的源码最新，然后在zeppelin-build里用最新的源码构建。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop# mkdir zeppelin zeppelin-build
root@kali:~/Desktop# cd zeppelin
root@kali:~/Desktop/zeppelin# git init
Initialized empty Git repository in /root/Desktop/zeppelin/.git/
root@kali:~/Desktop/zeppelin# git remote add origin git@github.com:NFLabs/zeppelin.git
root@kali:~/Desktop/zeppelin# git pull origin master
root@kali:~/Desktop/zeppelin# cd ../zeppelin-build/
root@kali:~/Desktop/zeppelin-build# cp -R ../zeppelin/* .
root@kali:~/Desktop/zeppelin-build# mvn clean package -DskipTests
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 详细步骤及错误解决&lt;/h2&gt;

&lt;h3&gt;2.1 按照默认配置编译 : mvn clean package -DskipTests&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu2[15:30:17]:~/Desktop/zeppelin-build#mvn clean package -DskipTests
.
.
.
[INFO] npm WARN deprecated grunt-ngmin@0.0.3: use grunt-ng-annotate instead
[INFO] npm ERR! 
[INFO] npm ERR! Additional logging details can be found in:
[INFO] npm ERR!     /root/Desktop/zeppelin-build/zeppelin-web/npm-debug.log
[INFO] npm ERR! not ok code 0
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Summary:
[INFO] 
[INFO] Zeppelin ........................................... SUCCESS [ 37.320 s]
[INFO] Zeppelin: Zengine .................................. SUCCESS [  9.899 s]
[INFO] Zeppelin: Spark .................................... SUCCESS [ 12.115 s]
[INFO] Zeppelin: Markdown interpreter ..................... SUCCESS [  2.257 s]
[INFO] Zeppelin: Shell interpreter ........................ SUCCESS [  2.239 s]
[INFO] Zeppelin: web Application .......................... FAILURE [04:10 min]
[INFO] Zeppelin: Server ................................... SKIPPED
[INFO] Zeppelin: Packaging distribution ................... SKIPPED
[INFO] ------------------------------------------------------------------------
[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 05:15 min
[INFO] Finished at: 2015-02-11T15:30:16+08:00
[INFO] Final Memory: 61M/409M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal com.github.eirslett:frontend-maven-plugin:0.0.20:npm (npm install) on project zeppelin-web: Failed to run task: &#39;npm install --color=false&#39; failed. (error code 1) -&amp;gt; [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
[ERROR] 
[ERROR] After correcting the problems, you can resume the build with the command
[ERROR]   mvn &amp;lt;goals&amp;gt; -rf :zeppelin-web
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.1 出错: npm install --color=false&lt;/h3&gt;

&lt;p&gt;　　这个错误在&lt;a href=&quot;https://groups.google.com/forum/#!searchin/zeppelin-developers/npm$20install&quot;&gt;mailing list&lt;/a&gt;里提到了，我们按照里面的解决方案来尝试一下。注意，以前的mailing list的维护在google groups里面的，但今年2月份之后groups就只读，不可以发帖了，新的mailing list移植到apache旗下，地址在&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/incubator-zeppelin-users/&quot;&gt;这里&lt;/a&gt;。
　　解决方案：先在zeppelin-web文件夹里运行 &lt;code&gt;npm install&lt;/code&gt;，然后再回到zeppelin-build目录构建。&lt;/p&gt;

&lt;h3&gt;2.2 启动zeppelin服务器错误，提示Unsupported major.minor&lt;/h3&gt;

&lt;p&gt;　　在运行 bin/zeppelin-daemon.sh start 的时候提示错误如下。一开始没有发现什么原因，后来google 关键字 &lt;code&gt;nsupported major.minor&lt;/code&gt;后在&lt;a href=&quot;http://www.oecp.cn/hi/yangtaoorange/blog/1168263&quot;&gt;这里&lt;/a&gt;知道问题应该和JAVA编译器的版本有问题，因为zeppelin需要java 1.7以上，我本机是java 1.6的，当时为了编译zeppelin我自己下了java 1.7和设置了一个java 1.7的环境变量文件，应该是没有source这个环境变量吧，测试一下发现$JAVA_HOME这个环境变量为空。这里再次source一下java_1.7_path.bashrc这个文件就可以了，这个文件是这样写的：
&lt;code&gt;
root@ubuntu2[10:59:24]:~/Desktop#cat java_1.7_path.bashrc
export PATH=/usr/local/jdk1.7.0_71/bin:$PATH
export CLASSPATH=&quot;/usr/local/jdk1.7.0_71/lib:.&quot;
export JAVA_HOME=&quot;/usr/local/jdk1.7.0_71/&quot;
&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu2[10:51:15]:~/Desktop/zeppelin-build#vi logs/zeppelin-root-ubuntu2.out 
Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: com/nflabs/zeppelin/
server/ZeppelinServer : Unsupported major.minor version 51.0
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:643)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:277)
        at java.net.URLClassLoader.access$000(URLClassLoader.java:73)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:212)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:205)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:323)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:294)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:268)
Could not find the main class: com.nflabs.zeppelin.server.ZeppelinServer. Program will
exit.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.3 运行出错，日志提示：java.net.UnknownHostException: &lt;em&gt;&lt;your hostname&gt;&lt;/em&gt;: nodename nor servname provided, or not known&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/zeppelin-run-error.jpg&quot; alt=&quot;run-error&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解决办法[我的机器host名叫mac007]，修改/etc/hosts，新增一项 127.0.0.1   mac007&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/zeppelin-hosts.jpg&quot; alt=&quot;revise-hosts&quot; /&gt;
　　&lt;/p&gt;

&lt;h3&gt;2.4 RDD Action 出错，提示：java.io.IOException: Failed on local exception: com.google.protobuf.InvalidProtocolBufferException: Protocol message contained an invalid tag (zero).; Host Details : local host is: &quot;ubuntu2/10.20.70.80&quot;; destination host is: &quot;sh-demo-hadoop-01&quot;:8020;&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../images/zeppelin-error-1.jpg&quot; alt=&quot;zeppelin-error-1.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;原因是我是连接到公司spark集群的，截图里可以看到，公司spark集群的hadoop版本和我当时编译zeppelin是定义的hadoop版本不一致。公司spark集群的hadoop版本是：Hadoop 2.0.0-cdh4.5.0，而我当时编译zeppelin时的命令是：mvn clean package -Pspark-1.2 -Dhadoop.version=2.2.0 -Phadoop-2.2 -DskipTests。&lt;/p&gt;

&lt;p&gt;解决办法就是重新拉zeppelin最新源码，然后用如下命令再次编译了：mvn clean package -Pspark-1.2 -Dhadoop.version=2.0.0-cdh4.5.0 -Phadoop-2.0 -DskipTests&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>［touch spark］8. 当Ipython Notebook遇见Spark</title>
     <link href="/ipython-notebook-server-spark"/>
     <updated>2015-01-27T00:00:00+08:00</updated>
     <id>/ipython-notebook-server-spark</id>
     <content type="html">&lt;p&gt;注：和本文相关的资料和文件都放到Github上了：&lt;a href=&quot;https://github.com/litaotao/ipython-notebook-spark&quot;&gt;ipython-notebook-spark&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 致谢&lt;/h2&gt;

&lt;p&gt;　　首先我忠心地感谢Ipython，Spark的开源作者，真心谢谢你们开发这么方便，好用，功能强大的项目，而且还无私地奉献给大众使用。刚刚很轻松地搭建了一个机遇Ipython Notebook的Spark客户端，真的感受到 The power of technology, the power of open source.&lt;br/&gt;
　　下面是这两个项目的github地址：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ipython/ipython&quot;&gt;Ipython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/apache/spark&quot;&gt;Spark&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　同时，这篇文章在刚开始的部分，参考了很多 &lt;a href=&quot;http://blog.cloudera.com/blog/2014/08/how-to-use-ipython-notebook-with-apache-spark/&quot;&gt;这篇博客&lt;/a&gt;的内容，感谢这么多人能无私分享如此高质量的内容。 &lt;br/&gt;
　　但是，这篇文章不是简单记录怎么做，我尽量做到量少质高，所以有些地方会说得比较详细，其中也会提到在解决遇到的问题上的一些方法和思路。&lt;/p&gt;

&lt;h2&gt;2. 路线规划&lt;/h2&gt;

&lt;p&gt;　　基于 &lt;a href=&quot;http://www.databricks.com/&quot;&gt;Databricks&lt;/a&gt;，&lt;a href=&quot;zeppelin-project.org&quot;&gt;Zeppelin&lt;/a&gt; 和 &lt;a href=&quot;www.gethue.com&quot;&gt;Hue&lt;/a&gt; 的启发，我也想尝试搭建一个丰富可用的在线大数据REPL分析平台，正好用此机会好好实践一下spark，毕竟都学习spark几个月了呢。 &lt;br/&gt;
　　不说废话，同&lt;a href=&quot;../weibo-api-in-action&quot;&gt;使用spark分析微博数据那篇博文一样&lt;/a&gt;，我们也要有一个路线规划：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;搭建一个可多用户使用的，底层接入了spark集群的Ipython Notebook Server；&lt;/li&gt;
&lt;li&gt;完善 Weibo Message Driver，使用户可在Notebook里获取、分析微博数据，as simple as possible；&lt;/li&gt;
&lt;li&gt;研究Zeppelin和Hue项目，把其中一个嫁接在Notebook的上层，实现准产品级的大数据实时ETL，Analytic，Sharing平台；这一步可能需要较长时间，可根据自己的时间安排灵活调整；&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　Dream：在年前完成上面三步，that&#39;s really full or chanllenge, but more funny. &lt;strong&gt;Anyway, we need dreams, and I can&#39;t wait to make this dream into reality.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/dreams.jpg&quot; alt=&quot;dreams&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　这篇主要记录我在实现第一步的过程中遇到的主要步骤，遇到的问题和解决方法：搭建一个可多用户使用的，底层接入了spark集群的Ipython Notebook Server。&lt;/p&gt;

&lt;h2&gt;3. 配置Ipython&lt;/h2&gt;

&lt;h3&gt;3.1: ipython 配置名profile介绍&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;profile 命令说明&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　profile是ipython的一个子命令，其中profile又有两个子命令，分别是create和list，顾名思义，create就是创建一个配置文件，list就是列出当前配置文件。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu2[13:54:01]:~/Desktop#ipython profile 
No subcommand specified. Must specify one of: [&#39;create&#39;, &#39;list&#39;]

Manage IPython profiles

Profile directories contain configuration, log and security related files and
are named using the convention &#39;profile_&amp;lt;name&amp;gt;&#39;. By default they are located in
your ipython directory.  You can create profiles with `ipython profile create
&amp;lt;name&amp;gt;`, or see the profiles you already have with `ipython profile list`

To get started configuring IPython, simply do:

$&amp;gt; ipython profile create

and IPython will create the default profile in &amp;lt;ipython_dir&amp;gt;/profile_default,
where you can edit ipython_config.py to start configuring IPython.

Subcommands
-----------

Subcommands are launched as `ipython cmd [args]`. For information on using
subcommand &#39;cmd&#39;, do: `ipython cmd -h`.

create
    Create an IPython profile by name
list
    List available IPython profiles
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;profile子命令list说明&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　本想list命令应该很简单的，和linux下的ls差不多嘛，但我自己看了下，其中还是有些细节值得推敲的。其中这项 &lt;code&gt;Available profiles in /root/.config/ipython:&lt;/code&gt; 是说目前有两个配置文件在那个目录下面，pyspark是我自己创建的了。在参考的&lt;a href=&quot;http://blog.cloudera.com/blog/2014/08/how-to-use-ipython-notebook-with-apache-spark/&quot;&gt;这篇文章&lt;/a&gt;中，作者说创建的配置文件会放到 &lt;code&gt;~/.ipython/profile_pyspark/&lt;/code&gt; 下，其实这并不是一定的，具体放在哪个目录下面，可以根据profile list的命令来查看。如此看来，我们在这台机器上创建的配置文件应该是放在目录 &lt;code&gt;/root/.config/ipython&lt;/code&gt; 下面的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu2[14:09:12]:~/Desktop#ipython profile list

Available profiles in IPython:
    pysh
    math
    sympy
    cluster

    The first request for a bundled profile will copy it
    into your IPython directory (/root/.config/ipython),
    where you can customize it.

Available profiles in /root/.config/ipython:
    default
    pyspark

To use any of the above profiles, start IPython with:
    ipython --profile=&amp;lt;name&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;profile子命令create说明&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　简单介绍下create子命令的用法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu2[09:25:57]:~/Desktop#ipython profile help create
Create an IPython profile by name

Create an ipython profile directory by its name or profile directory path.
Profile directories contain configuration, log and security related files and
are named using the convention &#39;profile_&amp;lt;name&amp;gt;&#39;. By default they are located in
your ipython directory. Once created, you will can edit the configuration files
in the profile directory to configure IPython. Most users will create a profile
directory by name, `ipython profile create myprofile`, which will put the
directory in `&amp;lt;ipython_dir&amp;gt;/profile_myprofile`.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.2 创建新的Ipython配置文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建配置文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　因为我之前已经配置过一个pyspark的配置文件了，这里我们创建一个测试用的配置文件，pytest。运行一下命令后，会在 &lt;code&gt;/root/.config/ipython&lt;/code&gt; 下生成一个 pytest的目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu2[14:54:14]:~/Desktop#ipython profile create pytest
[ProfileCreate] Generating default config file: u&#39;/root/.config/ipython/profile_pytest/ipython_config.py&#39;
[ProfileCreate] Generating default config file: u&#39;/root/.config/ipython/profile_pytest/ipython_notebook_config.py&#39;

root@ubuntu2[15:00:57]:~/Desktop#ls ~/.config/ipython/profile_pytest/
ipython_config.py  ipython_notebook_config.py  log  pid  security  startup 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.3 编辑配置文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;编辑ipython_notebook_config.py&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;    c = get_config()

    # about line 15, the ip address the notebook server will listen on. Set it to * means that any IP/Machine which can connect to the server can connect to the notebook server.
    c.NotebookApp.ip = &#39;*&#39;
    # about line 37, whether to open a browser or not. cause what we want to build is a backend server, so we set it False, no need to open a browser.
    c.NotebookApp.open_browser = False
    # about line 54, the port which the notebook server will listen on
    c.NotebookApp.port = 8880 # or whatever you want, make sure the port is available  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置访问密码 &lt;br/&gt;
　　如果你的notebook server是需要访问控制的，简单的话可以设置一个访问密码。听说Ipython 2.x 版本有用户访问控制，这里我还没有接触过，晚点会看看是否有成熟的可用的用户控制方案。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;生成密码文件&lt;br/&gt;
这里我们用python自带的密码包生成一个密码，然后再把这个密码重定向到nvpasswd.txt文件里。注意这里重定向的路径哦。&lt;/li&gt;
&lt;li&gt;编辑配置文件，设置读取密码文件配置项
这里有一个需要注意的，就是PWDFILE的设置，一开始我设置为 &lt;code&gt;~/.config/ipython/profile_pytest/nbpasswd.txt&lt;/code&gt;，但是启动ipython notebook server的时候老师报错，说找不到密码文件nbpasswd.txt，很奇怪，明明文件就是在的，可就是提示找不到。无奈我到nbpasswd.txt路径下用 pwd 打印当前路径，显示为 &lt;code&gt;root/.config/ipython/profile_pytest/nbpasswd.txt&lt;/code&gt;，可是这两个路径应该是一样的啊。无奈之下，死马当作活马医，我就把PWDFILE设置成为 &lt;code&gt;root/.config/ipython/profile_pytest/nbpasswd.txt&lt;/code&gt;，没想到这样还成功了。关于这点为什么会有效，目前我还不是很清楚，等我请教了公司大神后再补上这一个tip吧。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  示例如下：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;root@ubuntu2[09:40:29]:~/Desktop#python -c &#39;from IPython.lib import passwd; print passwd()&#39; &amp;gt; ~/.config/ipython/profile_pytest/nbpasswd.txt
Enter password: 
Verify password: 
root@ubuntu2[09:43:35]:~/Desktop#vi /root/.config/ipython/profile_pytest/nbpasswd.txt 
sha1:c6b748a8e1e2:4688f91ccfb9a8e0afd041ec77cdda99d0e1fb8f  

root@ubuntu2[09:49:09]:~/Desktop#vi /root/.config/ipython/profile_pytest/ipython_notebook_config.py 
# about line 95
PWDFILE=&#39;root/.config/ipython/profile_pytest/nbpasswd.txt&#39;
c.NotebookApp.password = open(PWDFILE).read().strip()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;设置启动文件&lt;br/&gt;
　　这一步算是比较重要的了，也是我在配置这个notebook server中遇到的比较难解的问题。这里我们首先需要创建一个启动文件，并在启动文件里设置一些spark的启动参数。如下：&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;root@ubuntu2[09:52:14]:~/Desktop#touch ~/.config/ipython/profile_pytest/startup/00-pytest-setup.py 
root@ubuntu2[10:08:44]:~/Desktop#vi ~/.config/ipython/profile_pytest/startup/00-pytest-setup.py   

import os
import sys

spark_home = os.environ.get(&#39;SPARK_HOME&#39;, None)
if not spark_home:
    raise ValueError(&#39;SPARK_HOME environment variable is not set&#39;)
sys.path.insert(0, os.path.join(spark_home, &#39;python&#39;))
sys.path.insert(0, os.path.join(spark_home, &#39;python/lib/py4j-0.8.1-src.zip&#39;))
# execfile(os.path.join(spark_home, &#39;python/pyspark/shell.py&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　上面的启动配置文件也还简单，即拿到spark_home路径，并在系统环境变量path里加上两个路径，然后再执行一个shell.py文件。不过，在保存之前还是先确认下配置文件写对了，比如说你的SPARK_HOME配置对了，并且下面有python这个文件夹，并且python/lib下有py4j-0.8.1这个文件。我在检查的时候就发现我的包版本是py4j-0.8.2.1的，所以还是要改得和自己的包一致才行。 &lt;br/&gt;
　　这里得到一个经验，在这种手把手，step by step的教程中，一定要注意版本控制，毕竟各人的机器，操作系统，软件版本等都不可能完全一致，也许在别人机器上能成功，在自己的机器上不成功也是很正常的事情，毕竟细节决定成败啊！所以在我这里，这句我是这样写的： &lt;code&gt;sys.path.insert(0, os.path.join(spark_home, &#39;python/lib/py4j-0.8.2.1-src.zip&#39;))&lt;/code&gt;  &lt;br/&gt;
　　注意，上面的最后一行 &lt;code&gt;execfile(os.path.join(spark_home, &#39;python/pyspark/shell.py&#39;))&lt;/code&gt; 被注释掉了，表示在新建或打开一个notebook时并不去执行shell.py这个文件，这个文件是创建SparkContext的，即如果执行改行语句，那在启动notebook时就会初始化一个sc，但这个sc的配置都是写死了的，在spark web UI监控里的appName也是一样的，很不方便。而且考虑到并不是打开一个notebook就要用到spark的资源，所以最好是要用户自己定义sc了。 &lt;br/&gt;
　　python/pyspark/shell.py的核心代码： &lt;br/&gt;
&lt;code&gt;
sc = SparkContext(appName=&quot;PySparkShell&quot;, pyFiles=add_files)
atexit.register(lambda: sc.stop())
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;4. Ok，here we go　　&lt;/h2&gt;

&lt;p&gt;　　到这里差不多大功告成了，可以启动notebook server了。不过在启动之前，需要配置两个环境变量参数，同样，这两个环境变量参数在也是根据个人配置而定的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# for the CDH-installed Spark
export SPARK_HOME=&#39;/usr/local/spark-1.2.0-bin-cdh4/&#39;

# this is where you specify all the options you wou
ld normally add after bin/pyspark
  export PYSPARK_SUBMIT_ARGS=&#39;--master spark://10.21.208.21:7077 --deploy-mode client&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　ok，万事具备，只欠东风了。让我们来尝尝鲜吧：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@ubuntu2[10:40:50]:~/Desktop#ipython notebook --profile=pyspark
2015-02-01 10:40:54.850 [NotebookApp] Using existing profile dir: u&#39;/root/.config/ipython/profile_pyspark&#39;
2015-02-01 10:40:54.858 [NotebookApp] Using MathJax from CDN: http://cdn.mathjax.org/mathjax/latest/MathJax.js
2015-02-01 10:40:54.868 [NotebookApp] CRITICAL | WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.
2015-02-01 10:40:54.869 [NotebookApp] Serving notebooks from local directory: /root/Desktop
2015-02-01 10:40:54.869 [NotebookApp] The IPython Notebook is running at: http://[all ip addresses on your system]:8880/
2015-02-01 10:40:54.869 [NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　在浏览器输入driver:8880即可访问notebook server了，首先会提示输入密码，密码正确后就可以使用了。
&lt;img src=&quot;../images/notebook-spark-1.jpg&quot; alt=&quot;notebook-spark-1&quot; /&gt;
&lt;img src=&quot;../images/notebook-spark-2.jpg&quot; alt=&quot;notebook-spark-2&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;5. 总结&lt;/h2&gt;

&lt;p&gt;　　下面是简单的步骤总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;建立环境变量配置文件：ipython_notebook_spark.bashrc&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;export SPARK_HOME=&quot;/usr/local/spark-1.2.0-bin-cdh4/&quot;
export PYSPARK_SUBMIT_ARGS=&quot;--master spark://10.21.208.21:7077 --deploy-mode client&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;配置Ipython notebook server

&lt;ul&gt;
&lt;li&gt;ipython profile create pyspark&lt;/li&gt;
&lt;li&gt;编辑ipython_notebook_config.py&lt;/li&gt;
&lt;li&gt;[可选]配置ipython notebook登录密码&lt;/li&gt;
&lt;li&gt;设置启动文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设置启动脚本&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;6. 启动脚本和文件&lt;/h2&gt;

&lt;p&gt;　　为了方便，都放到Github上了。&lt;/p&gt;
</content>
   </entry>
   

</feed>


</body>
</html>
