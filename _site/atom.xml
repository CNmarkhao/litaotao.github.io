<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Taotao's Zone</title>
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css" type="text/css" />
  <!-- <link rel="stylesheet" href="/css/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="/css/default.css" type="text/css" />
  <link rel="stylesheet" href="/css/desktop.css" type="text/css" />
  <link rel="stylesheet" href="/css/mobile.css" type="text/css" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
  <script src="/js/jquery-1.11.0.min.js" type="text/javascript"></script>
  <script src="/js/jquery-migrate-1.2.1.js" type="text/javascript"></script>
  <script src="/js/jquery.transit.min.js" type="text/javascript"></script>
  <script src="/js/common.js" type="text/javascript"></script>
</head>
<body>
  <?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

   <title>Taotao's Zone</title>
   <link href="http://litaotao.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://litaotao.github.io" rel="alternate" type="text/html" />
   <updated>2015-10-26T15:37:57+08:00</updated>
   <id>http://litaotao.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>python else 用法总结</title>
     <link href="/python-if-else-usage"/>
     <updated>2015-10-25T00:00:00+08:00</updated>
     <id>/python-if-else-usage</id>
     <content type="html">&lt;h2&gt;1. 常规的 if else 用法&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;x = True

if x:
    print &amp;#39;x is true&amp;#39;
else:
    print &amp;#39;x is not true&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. if else 快捷用法&lt;/h2&gt;

&lt;p&gt;这里的 &lt;code&gt;if else&lt;/code&gt; 可以作为三元操作符使用。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mark = 40
is_pass = True if mark &amp;gt;= 50 else False
print &amp;quot;Pass? &amp;quot; + str(is_pass)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. 与 &lt;code&gt;for&lt;/code&gt; 关键字一起用&lt;/h2&gt;

&lt;p&gt;在满足以下情况的时候，&lt;code&gt;else&lt;/code&gt; 下的代码块会被执行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;for 循环里的语句执行完成&lt;/li&gt;
&lt;li&gt;for 循环里的语句没有被 &lt;code&gt;break&lt;/code&gt; 语句打断&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# 打印 `For loop completed the execution`
for i in range(10):
    print i
else:
    print &amp;#39;For loop completed the execution&amp;#39;

# 不打印 `For loop completed the execution`
for i in range(10):
    print i
    if i == 5:
        break
else:
    print &amp;#39;For loop completed the execution&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4. 与 &lt;code&gt;while&lt;/code&gt; 关键字一起用&lt;/h2&gt;

&lt;p&gt;和上面类似，在满足以下情况的时候，&lt;code&gt;else&lt;/code&gt; 下的代码块会被执行：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;while 循环里的语句执行完成&lt;/li&gt;
&lt;li&gt;while 循环里的语句没有被 &lt;code&gt;break&lt;/code&gt; 语句打断&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# 打印 `While loop execution completed`
a = 0
loop = 0
while a &amp;lt;= 10:
    print a
    loop += 1
    a += 1
else:
    print &amp;quot;While loop execution completed&amp;quot;

# 不打印 `While loop execution completed`
a = 50
loop = 0
while a &amp;gt; 10:
    print a
    if loop == 5:
        break
    a += 1
    loop += 1
else:
    print &amp;quot;While loop execution completed&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5. 与 &lt;code&gt;try except&lt;/code&gt; 一起用&lt;/h2&gt;

&lt;p&gt;和 &lt;code&gt;try except&lt;/code&gt; 一起使用时，如果不抛出异常，&lt;code&gt;else&lt;/code&gt;里的语句就能被执行。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;file_name = &amp;quot;result.txt&amp;quot;
try:
    f = open(file_name, &amp;#39;r&amp;#39;)
except IOError:
    print &amp;#39;cannot open&amp;#39;, file_name
else:
    # Executes only if file opened properly
    print file_name, &amp;#39;has&amp;#39;, len(f.readlines()), &amp;#39;lines&amp;#39;
    f.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.idiotinside.com/2015/10/18/5-methods-to-use-else-block-in-python&quot;&gt;5 different methods to use an else block in python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>打包 python package 到 pypi</title>
     <link href="/submit-push-package-to-pypi"/>
     <updated>2015-10-24T00:00:00+08:00</updated>
     <id>/submit-push-package-to-pypi</id>
     <content type="html">&lt;h2&gt;1. 注册 pypi 账号&lt;/h2&gt;

&lt;p&gt;点击这张图片去注册吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://pypi.python.org/pypi&quot;&gt;&lt;img src=&quot;../images/pypi_register.jpg&quot; alt=&quot;pypi_register.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;2. 编写 setup.py 必要信息&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;setup(
    name=&amp;quot;IPython-Dashboard&amp;quot;,
    version=&amp;#39;0.1.1&amp;#39;,
    author=&amp;quot;Taotao Li&amp;quot;,
    author_email=&amp;quot;taotao.engineer@gmail.com&amp;quot;,
    url=&amp;quot;https://github.com/litaotao/IPython-Dashboard/tree/v-0.2-dashboard-server&amp;quot;,
    keywords = (&amp;quot;ipython&amp;quot;, &amp;quot;dashboard&amp;quot;, &amp;quot;interactive&amp;quot;, &amp;quot;visualization&amp;quot;, &amp;quot;data science&amp;quot;, &amp;quot;data analysis&amp;quot;, &amp;quot;streaming&amp;quot;),
    license=&amp;quot;BSD&amp;quot;,
    packages=find_packages(),
    package_dir={&amp;quot;dashboard&amp;quot;: &amp;quot;dashboard&amp;quot;},
    include_package_data=True,
    description=&amp;quot;An stand alone, light-weight web server for building, sharing graphs in created in ipython. Let ipython do what it focus, let this do what everyone needs for building a interactive, collaborated and real-time streaming dashboards.&amp;quot;,
    long_description=io.open(&amp;quot;README.md&amp;quot;, encoding=&amp;#39;utf8&amp;#39;).read(),
    install_requires=io.open(&amp;quot;requirements.txt&amp;quot;, encoding=&amp;#39;utf8&amp;#39;).read(),
    ...
    ...
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是我的一个项目的 &lt;code&gt;setup.py&lt;/code&gt; 内容，可以对比源文件和在 pypi 上到描述。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/litaotao/IPython-Dashboard/blob/master/setup.py&quot;&gt;项目文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pypi.python.org/pypi/IPython-Dashboard&quot;&gt;pypi上的描述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我觉得关键的几 点是： &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;keywords: 这点就不用说了吧&lt;/li&gt;
&lt;li&gt;description: 这点很多人都会忽略，其实也很重要的，我相信pypi在检索的时候，也会检索里面的一些关键字的。&lt;/li&gt;
&lt;li&gt;long&lt;em&gt;description: 这点也很重要，或者说不能更重要了。如果说上面的 &lt;code&gt;keywords&lt;/code&gt; 和 &lt;code&gt;description&lt;/code&gt; 能提高别人搜索到项目的概率的话，那 `long&lt;/em&gt;description&lt;code&gt;就在很大程度上决定别人对你对项目有没有进一步的想法了。对比一下这几种&lt;/code&gt;long_description` 

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;No long_description&lt;/em&gt;&lt;/strong&gt;
&lt;img src=&quot;../images/ld_1.jpg&quot; alt=&quot;ld_1.jpg&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Ugly long_description&lt;/em&gt;&lt;/strong&gt;
&lt;img src=&quot;../images/ld_2.jpg&quot; alt=&quot;ld_2.jpg&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;long_description with highlight, but need to make it cleaner&lt;/em&gt;&lt;/strong&gt;
&lt;img src=&quot;../images/ld_3.jpg&quot; alt=&quot;ld_3.jpg&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对了，还要注意一下，pypi 上只接受 &lt;code&gt;rst&lt;/code&gt; 格式的 &lt;code&gt;readme&lt;/code&gt;，不接受 &lt;code&gt;markdown&lt;/code&gt; 格式的，所以想要高亮和排版的话，需要先把 &lt;code&gt;md&lt;/code&gt; 格式的转换成 &lt;code&gt;rst&lt;/code&gt; 格式的 &lt;code&gt;readme&lt;/code&gt;。这点改天说。&lt;/p&gt;

&lt;h2&gt;3. 发布包元信息到pypi&lt;/h2&gt;

&lt;p&gt;在你的包目录下使用命令 &lt;code&gt;python setup.py register&lt;/code&gt; 在 pypi 上注册你的包信息，所谓注册包信息就是在 pypi 上建立你的包元信息，包括作者，描述等等。但是要注意的是，注册完元信息别人还不能使用 &lt;code&gt;pip install package&lt;/code&gt; 来安装你的包。注册完元信息只是在 pypi 上占个坑而已。&lt;/p&gt;

&lt;p&gt;就如截图所示，这个项目就是只注册了元信息，所以没有下载包的那个链接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ld_1.jpg&quot; alt=&quot;ld_1.jpg&quot;&gt;&lt;/p&gt;

&lt;h2&gt;4. 发布包到pypi&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;python setup.py sdist upload&lt;/code&gt; 发布包，即先将包在本地打包，然后上传到pypi，然后就ok了。&lt;/p&gt;

&lt;h2&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://peterdowns.com/posts/first-time-with-pypi.html&quot;&gt;How to submit a package to PyPI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>Python format 笔记</title>
     <link href="/python-format"/>
     <updated>2015-10-24T00:00:00+08:00</updated>
     <id>/python-format</id>
     <content type="html">&lt;h2&gt;1. 位置参数&lt;/h2&gt;

&lt;p&gt;字符串的format函数可以接受不限个参数，位置可以不按顺序，可以不用或者用多次，不过2.6不能为空{}，2.7才可以。
值得注意的是，&lt;code&gt;位置可以不按顺序，可以不用或者用多次&lt;/code&gt;，再结合下面的例子，可以发现，这里的位置参数其实和关键字参数是一样的，只是这里的关键字是位置的下标而已了。   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;In [1]: &amp;#39;{0},{1}&amp;#39;.format(&amp;#39;kzc&amp;#39;,18)  
Out[1]: &amp;#39;kzc,18&amp;#39;  
In [2]: &amp;#39;{},{}&amp;#39;.format(&amp;#39;kzc&amp;#39;,18)  
Out[2]: &amp;#39;kzc,18&amp;#39;  
In [3]: &amp;#39;{1},{0},{1}&amp;#39;.format(&amp;#39;kzc&amp;#39;,18)  
Out[3]: &amp;#39;18,kzc,18&amp;#39;

# more powerful

In [7]: p=[&amp;#39;kzc&amp;#39;,18]
In [8]: &amp;#39;{0[0]},{0[1]}&amp;#39;.format(p)
Out[8]: &amp;#39;kzc,18&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 通过关键字参数&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;In [5]: &amp;#39;{name},{age}&amp;#39;.format(age=18,name=&amp;#39;kzc&amp;#39;)  
Out[5]: &amp;#39;kzc,18&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. 对象属性&lt;/h2&gt;

&lt;p&gt;这是很多对象的 &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;__str__&lt;/code&gt;, &lt;code&gt;__repr__&lt;/code&gt; 方法的实现。关于这三个方法的区别，可以简单的理解为下面几点：  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;str&lt;/code&gt; 是 pyhton 的内置函数，&lt;code&gt;str(obj)&lt;/code&gt; 实际是调用 &lt;code&gt;obj.__str__()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj.__str__()&lt;/code&gt; 是简化版的 &lt;code&gt;obj.__repr__()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;need more details, check this on &lt;a href=&quot;http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python&quot;&gt;SO&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;class Person:  
    def __init__(self,name,age):  
        self.name,self.age = name,age  
        def __str__(self):  
            return &amp;#39;This guy is {self.name},is {self.age} old&amp;#39;.format(self=self)  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4. 格式限定符 - 填充与对齐&lt;/h2&gt;

&lt;p&gt;不好解释，解释了还是得看例子才明白，直接看例子吧，哈哈。 &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# 无需对齐，填充
In [1]: &amp;#39;{}&amp;#39;.format(&amp;#39;hello&amp;#39;)
Out[1]: &amp;#39;hello&amp;#39;

In [2]: &amp;#39;{:}&amp;#39;.format(&amp;#39;hello&amp;#39;)
Out[2]: &amp;#39;hello&amp;#39;

# 居中对齐，构建 9 个长度的字符串
In [5]: &amp;#39;{:^9}&amp;#39;.format(&amp;#39;hello&amp;#39;)
Out[5]: &amp;#39;  hello  &amp;#39;

# 右对齐，构建 9 个长度的字符串
In [6]: &amp;#39;{:&amp;gt;9}&amp;#39;.format(&amp;#39;hello&amp;#39;)
Out[6]: &amp;#39;    hello&amp;#39;

# 左对齐，构建 9 个长度的字符串
In [7]: &amp;#39;{:&amp;lt;9}&amp;#39;.format(&amp;#39;hello&amp;#39;)
Out[7]: &amp;#39;hello    &amp;#39;

# 右对齐，构建 9 个长度的字符串，用 0 填充空白位置
In [10]: &amp;#39;{:0&amp;gt;9}&amp;#39;.format(&amp;#39;hello&amp;#39;)
Out[10]: &amp;#39;0000hello&amp;#39;

# # 左对齐，构建 9 个长度的字符串，用 0 填充空白位置
In [11]: &amp;#39;{:0&amp;lt;9}&amp;#39;.format(&amp;#39;hello&amp;#39;)
Out[11]: &amp;#39;hello0000&amp;#39;

# 居中对齐，构建 9 个长度的字符串，用 0 填充空白位置
In [12]: &amp;#39;{:0^9}&amp;#39;.format(&amp;#39;hello&amp;#39;)
Out[12]: &amp;#39;00hello00&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5. 精度与类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;f : float类型&lt;/li&gt;
&lt;li&gt;b : 二进制&lt;/li&gt;
&lt;li&gt;d : 十进制 &lt;/li&gt;
&lt;li&gt;o : 八进制&lt;/li&gt;
&lt;li&gt;x : 十六进制&lt;/li&gt;
&lt;li&gt;, : 逗号可以表示数字的千分位&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;In [44]: &amp;#39;{:.2f}&amp;#39;.format(321.33345)
Out[44]: &amp;#39;321.33&amp;#39;

In [54]: &amp;#39;{:b}&amp;#39;.format(17)
Out[54]: &amp;#39;10001&amp;#39;
In [55]: &amp;#39;{:d}&amp;#39;.format(17)
Out[55]: &amp;#39;17&amp;#39;
In [56]: &amp;#39;{:o}&amp;#39;.format(17)
Out[56]: &amp;#39;21&amp;#39;
In [57]: &amp;#39;{:x}&amp;#39;.format(17)
Out[57]: &amp;#39;11&amp;#39;

In [47]: &amp;#39;{:,}&amp;#39;.format(1234567890)
Out[47]: &amp;#39;1,234,567,890&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6. 完善的格式文档&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../images/python_str_format.jpg&quot; alt=&quot;python_str_format.jpg&quot;&gt;&lt;/p&gt;

&lt;h2&gt;7. % VS format&lt;/h2&gt;

&lt;p&gt;我一直都喜欢用 &lt;code&gt;format&lt;/code&gt; ，不知道为什么，可能喜欢一种写法也是不需要原因的吧，哈哈。其它的，可以在这里找到一大堆说法。  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format&quot;&gt;python-string-formatting-vs-format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/9183303&quot;&gt;飘逸的python - 增强的格式化字符串format函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pyformat.info/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.xiayf.cn/2013/01/26/python-string-format/&quot;&gt;Python格式字符串（译）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>［touch spark］8. 当Ipython Notebook遇见Spark 1， 安装配置篇</title>
     <link href="/ipython-notebook-server-spark"/>
     <updated>2015-08-27T00:00:00+08:00</updated>
     <id>/ipython-notebook-server-spark</id>
     <content type="html">&lt;p&gt;注：和本文相关的资料和文件都放到Github上了：&lt;a href=&quot;https://github.com/litaotao/ipython-notebook-spark&quot;&gt;ipython-notebook-spark&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;1. 致谢&lt;/h2&gt;

&lt;p&gt;　　首先我忠心地感谢Ipython，Spark的开源作者，真心谢谢你们开发这么方便，好用，功能强大的项目，而且还无私地奉献给大众使用。刚刚很轻松地搭建了一个机遇Ipython Notebook的Spark客户端，真的感受到 The power of technology, the power of open source.&lt;br&gt;
　　下面是这两个项目的github地址：  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ipython/ipython&quot;&gt;Ipython&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/apache/spark&quot;&gt;Spark&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　同时，这篇文章在刚开始的部分，参考了很多 &lt;a href=&quot;http://blog.cloudera.com/blog/2014/08/how-to-use-ipython-notebook-with-apache-spark/&quot;&gt;这篇博客&lt;/a&gt;的内容，感谢这么多人能无私分享如此高质量的内容。&lt;br&gt;
　　但是，这篇文章不是简单记录怎么做，我尽量做到量少质高，所以有些地方会说得比较详细，其中也会提到在解决遇到的问题上的一些方法和思路。&lt;/p&gt;

&lt;h2&gt;2. 路线规划&lt;/h2&gt;

&lt;p&gt;　　基于 &lt;a href=&quot;http://www.databricks.com/&quot;&gt;Databricks&lt;/a&gt;，&lt;a href=&quot;zeppelin-project.org&quot;&gt;Zeppelin&lt;/a&gt; 和 &lt;a href=&quot;www.gethue.com&quot;&gt;Hue&lt;/a&gt; 的启发，我也想尝试搭建一个丰富可用的在线大数据REPL分析平台，正好用此机会好好实践一下spark，毕竟都学习spark几个月了呢。&lt;br&gt;
　　不说废话，同&lt;a href=&quot;../weibo-api-in-action&quot;&gt;使用spark分析微博数据那篇博文一样&lt;/a&gt;，我们也要有一个路线规划：  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;因为考虑到公司的data scientist很喜欢R，所以也在我们的ipython notebook环境里加入r kernel；&lt;/li&gt;
&lt;li&gt;搭建一个可多用户使用的，并且各个用户互相独立的环境［至少让用户A不能读取到用户B的文件吧］； &lt;/li&gt;
&lt;li&gt;结合丰富的开源包，能做到在线，实时的数据分析和共享分析报告； &lt;/li&gt;
&lt;li&gt;底层接入了spark集群，支持在notebook做基于spark对大数据分析；&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　Dream：在国庆前完成至少前3步，that&amp;#39;s really full or chanllenge, but more funny. &lt;strong&gt;Anyway, we need dreams, and I can&amp;#39;t wait to make this dream into reality.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/dreams.jpg&quot; alt=&quot;dreams&quot;&gt;&lt;/p&gt;

&lt;p&gt;　　这篇主要记录我在实现第一步的过程中遇到的主要步骤，遇到的问题和解决方法：搭建一个可多用户隔离使用的，能做丰富的大数据在线分析和分享对，并且底层接入了spark集群的Ipython Notebook Server。&lt;/p&gt;

&lt;h2&gt;3. 安装Ipython&lt;/h2&gt;

&lt;p&gt;　　使用 &lt;code&gt;sudo pip install ipython==3.2.0&lt;/code&gt; 来安装ipython 3.2.0 版本，本来打算用和jupyter分离后的ipython 4.0.0的，但是一下子要配置ipython和jupyter，赶紧有点乱，而且ipython 4.0.0 似乎也仅仅是吧notebook分离到jupyter，并没有什么大的改动，所以就先用3.2.0了，短期内应该不会有升级的安排。&lt;/p&gt;

&lt;p&gt;　　安装好之后试试运行下 ipython，看看似乎有错，如果出现下面的错误的话，把 &lt;code&gt;/usr/local/lib/python2.7/dist-packages/IPython/external/path/__init__.py&lt;/code&gt; 里的 &lt;code&gt;from path import *&lt;/code&gt; 改成 &lt;code&gt;from _path import *&lt;/code&gt; 即可。   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Traceback (most recent call last):
  File &amp;quot;/usr/local/bin/ipython&amp;quot;, line 7, in &amp;lt;module&amp;gt;
    from IPython import start_ipython
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/IPython/__init__.py&amp;quot;, line 45, in &amp;lt;module&amp;gt;
    from .config.loader import Config
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/IPython/config/__init__.py&amp;quot;, line 6, in &amp;lt;module&amp;gt;
    from .application import *
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/IPython/config/application.py&amp;quot;, line 19, in &amp;lt;module&amp;gt;
    from IPython.config.configurable import SingletonConfigurable
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/IPython/config/configurable.py&amp;quot;, line 14, in &amp;lt;module&amp;gt;
    from IPython.utils.text import indent, wrap_paragraphs
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/IPython/utils/text.py&amp;quot;, line 28, in &amp;lt;module&amp;gt;
    from IPython.external.path import path
ImportError: cannot import name path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. 配置Ipython&lt;/h2&gt;

&lt;h3&gt;3.1: ipython 配置名profile介绍&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;profile 命令说明&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　profile是ipython的一个子命令，其中profile又有三个子命令，分别是locate，create和list，顾名思义，create就是创建一个配置文件，list就是列出当前配置文件。如下：  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;aaron@dev-chad:~/ipython-notebook-spark$ipython profile
Subcommands
-----------

Subcommands are launched as `ipython profile cmd [args]`. For information on
using subcommand &amp;#39;cmd&amp;#39;, do: `ipython profile cmd -h`.

locate
    print the path to an IPython profile dir
create
    Create an IPython profile by name
list
    List available IPython profiles
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 创建新的Ipython配置文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建配置文件&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    aaron@dev-chad:~/ipython-notebook-spark$ipython profile create bigdata
    [ProfileCreate] Generating default config file: u&amp;#39;/home/aaron/.ipython/profile_bigdata/ipython_console_config.py&amp;#39;
    [ProfileCreate] Generating default config file: u&amp;#39;/home/aaron/.ipython/profile_bigdata/ipython_notebook_config.py&amp;#39;
    [ProfileCreate] Generating default config file: u&amp;#39;/home/aaron/.ipython/profile_bigdata/ipython_nbconvert_config.py&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3 编辑配置文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;编辑ipython&lt;em&gt;notebook&lt;/em&gt;config.py&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    c = get_config()

    c.NotebookApp.ip = &amp;#39;*&amp;#39;

    # 本想指定每次都在一个专有的目录启动notebook server的，可是这样设置还是不行，这样设置后每次打开启动notebook server 的路径是
    # 当前路径 ＋ u&amp;#39;home/aaron/notebooks&amp;#39;，完全达不到我想要的效果，所以暂时注释啦。
    # c.NotebookApp.notebook_dir = u&amp;#39;home/aaron/notebooks&amp;#39;

    c.NotebookApp.open_browser = False

    c.NotebookApp.port = 8880 # or whatever you want, make sure the port is available  

    # 
    # c.NotebookApp.pylab = &amp;#39;inline&amp;#39; 已经被弃用了，官方推荐在notebook中显示指定，不过下面的这个配置依然可以使用的，
    # 我的建议是，先这样使用，然后在以后写到启动的配置文件里去，并且在每一个新建的 notebook 中都能有显式说明。
    c.IPKernelApp.matplotlib = &amp;#39;inline&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;设置访问密码&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　如果你的notebook server是需要访问控制的，简单的话可以设置一个访问密码。听说Ipython 2.x 版本有用户访问控制，这里我还没有接触过，晚点会看看是否有成熟的可用的用户控制方案。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;+ 生成密码文件  
这里我们用python自带的密码包生成一个密码，然后再把这个密码重定向到nvpasswd.txt文件里。注意这里重定向的路径哦。
+ 编辑配置文件，设置读取密码文件配置项
这里有一个需要注意的，就是PWDFILE的设置，一开始我设置为 `~/.config/ipython/profile_pytest/nbpasswd.txt`，但是启动ipython notebook server的时候老师报错，说找不到密码文件nbpasswd.txt，很奇怪，明明文件就是在的，可就是提示找不到。无奈我到nbpasswd.txt路径下用 pwd 打印当前路径，显示为 `root/.config/ipython/profile_pytest/nbpasswd.txt`，可是这两个路径应该是一样的啊。无奈之下，死马当作活马医，我就把PWDFILE设置成为 `root/.config/ipython/profile_pytest/nbpasswd.txt`，没想到这样还成功了。关于这点为什么会有效，目前我还不是很清楚，等我请教了公司大神后再补上这一个tip吧。

示例如下：  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;aaron@dev-chad:~/ipython-notebook-spark$python -c &amp;#39;from IPython.lib import passwd; print passwd()&amp;#39;
Enter password:
Verify password:
sha1:eee72d659d34:bc7cf7fc26700b28eaa16bb8a8ce846fa35084de

root@ubuntu2[09:49:09]:~/Desktop#vi /root/.config/ipython/profile_pytest/ipython_notebook_config.py 

c.NotebookApp.password = u&amp;#39;sha1:eee72d659d34:bc7cf7fc26700b28eaa16bb8a8ce846fa35084de&amp;#39;  # copy your encoded password here 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;设置启动文件&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　这个设置非常好用，在每个ipython的配置路径下，都有一个startup的文件夹，里面你可以写一些脚本，这些脚本都是在启动ipython notebook server之前被执行的，并且是全局的。有两个好处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;脚本的执行是有序的，具体可以参考下面的写法文档&lt;br&gt;&lt;/li&gt;
&lt;li&gt;影响是全局的，也就是说如果你在一个脚本里定义了一个变量a，那在所有新建的notebook中这个变量a都是已经创建了的；但这也许也是一个缺点吧，anyway，看你怎么用了；&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;This is the IPython startup directory

.py and .ipy files in this directory will be run *prior* to any code or files specified
via the exec_lines or exec_files configurables whenever you load this profile.
Files will be run in lexicographical order, so you can control the execution order of files
with a prefix, e.g.::
    00-first.py
    50-middle.py
    99-last.ipy
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　原本打算在启动文件里写入一些package import和设置相关的脚步的，但是我想这样的话会造成一些误解，特别是当你分享notebook的时候，别人都不知道你事先导入了哪些package，会让人感到很迷惑。而且，我认为在每一个notebook的第一个cell里把改notebook里所需要的package和package setting注明是一个非常好的习惯，所有启动脚本就先不用了。   &lt;/p&gt;

&lt;h2&gt;3. 安装R, 配置IRkernel&lt;/h2&gt;

&lt;p&gt;　　关于如何安装R，请参考：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&lt;/a&gt;
　　关于如何安装配置IRkernel，请参考：&lt;a href=&quot;https://github.com/IRkernel/IRkernel&quot;&gt;https://github.com/IRkernel/IRkernel&lt;/a&gt;
　　好吧，我承认了，我现在这台服务器上之前就有人装过R和IRkernel了，具体怎么配置我也不想花时间去研究，因为实在不喜欢R，不要问我为什么不喜欢。“喜欢一个人不需要理由”，不喜欢一个东西有时候也不需要理由啊～&lt;/p&gt;

&lt;h2&gt;4. 总结&lt;/h2&gt;

&lt;p&gt;　　好了，环境算是基本搭建好了，github还没怎么更新，因为不能把公司相关的信息透露出来，所以commit的时候都需要谨慎一点。下一步，我们就来看看怎么让多个用户有个独立的 IPython 开发环境吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/a-good-start.jpg&quot; alt=&quot;a-good-start.jpg&quot;&gt;&lt;/p&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-01-27-ipython-notebook-server-spark.md.jpg&quot; alt=&quot;2015-01-27-ipython-notebook-server-spark.md&quot;&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>我常用到的linux命令</title>
     <link href="/linux-commands"/>
     <updated>2015-08-12T00:00:00+08:00</updated>
     <id>/linux-commands</id>
     <content type="html">&lt;p&gt;无意间发现这本在线书籍挺好的：&lt;a href=&quot;http://linuxtools-rst.readthedocs.org/zh_CN/latest/&quot;&gt;Linux工具快速教程&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;1. ps&lt;/h2&gt;

&lt;p&gt;　　Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。&lt;br&gt;
　　要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。&lt;br&gt;
　　kill 命令用于杀死进程。&lt;br&gt;
　　linux上进程有5种状态:    &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运行(正在运行或在运行队列中等待)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　ps工具标识进程的5种状态码:   &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;D 不可中断 uninterruptible sleep (usually IO) &lt;/li&gt;
&lt;li&gt;R 运行 runnable (on run queue) &lt;/li&gt;
&lt;li&gt;S 中断 sleeping &lt;/li&gt;
&lt;li&gt;T 停止 traced or stopped &lt;/li&gt;
&lt;li&gt;&lt;p&gt;Z 僵死 a defunct (”zombie”) process &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令格式：
ps[参数]&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令功能：&lt;br&gt;
用来显示当前进程的状态  &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令参数：    &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;a  显示所有进程
-a 显示同一终端下的所有程序
-A 显示所有进程
c  显示进程的真实名称
-N 反向选择
-e 等于“-A”
e  显示环境变量
f  显示程序间的关系
-H 显示树状结构
r  显示当前终端的进程
T  显示当前终端的所有程序
u  指定用户的所有进程
-au 显示较详细的资讯
-aux 显示所有包含其他使用者的行程 
-C&amp;lt;命令&amp;gt; 列出指定命令的状况
--lines&amp;lt;行数&amp;gt; 每页显示的行数
--width&amp;lt;字符数&amp;gt; 每页显示的字符数
--help 显示帮助信息
--version 显示版本显示
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2. kill&lt;/h2&gt;

&lt;p&gt;　　Linux中的kill命令用来终止指定的进程（terminate a process）的运行，是Linux下进程管理的常用命令。通常，终止一个前台进程可以使用Ctrl+C键，但是，对于一个后台进程就须用kill命令来终止，我们就需要先使用ps/pidof/pstree/top等工具获取进程PID，然后使用kill命令来杀掉该进程。kill命令是通过向进程发送指定的信号来结束相应进程的。在默认情况下，采用编号为15的TERM信号。TERM信号将终止所有不能捕获该信号的进程。对于那些可以捕获该信号的进程就要用编号为9的kill信号，强行“杀掉”该进程。&lt;br&gt;
- 命令格式：&lt;br&gt;
kill[参数][进程号]&lt;br&gt;
- 命令功能：&lt;br&gt;
　　发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9)，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。
- 命令参数：  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    -l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
    -a  当处理当前进程时，不限制命令名和进程号的对应关系
    -p  指定kill 命令只打印相关进程的进程号，而不发送任何信号
    -s  指定发送信号
    -u  指定用户 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kill命令可以带信号号码选项，也可以不带。如果没有信号号码，kill命令就会发出终止信号(15)，这个信号可以被进程捕获，使得进程在退出之前可以清理并释放资源。也可以用kill向进程发送特定的信号。例如：
kill -2 123
它的效果等同于在前台运行PID为123的进程时按下Ctrl+C键。但是，普通用户只能使用不带signal参数的kill命令或最多使用-9信号。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;kill可以带有进程ID号作为参数。当用kill向这些进程发送信号时，必须是这些进程的主人。如果试图撤销一个没有权限撤销的进程或撤销一个不存在的进程，就会得到一个错误信息。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;可以向多个进程发信号或终止它们。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息。有时这个信息不会马上显示，只有当按下Enter键使shell的命令提示符再次出现时，才会显示出来。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说明：&lt;br&gt;
　　init是Linux系统操作中不可缺少的程序之一。所谓的init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。所以,init始终是第一个进程（其进程编号始终为1）。   其它所有进程都是init进程的子孙。init进程是不可杀的！  &lt;/p&gt;

&lt;h2&gt;3. netstat&lt;/h2&gt;

&lt;p&gt;　　Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。&lt;br&gt;
　　执行netstat后，其输出结果为:   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address Foreign Address State
tcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED
tcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED
tcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED
tcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED
tcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE

Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags Type State I-Node Path
unix 1 [ ] STREAM CONNECTED 16178 @000000dd
unix 1 [ ] STREAM CONNECTED 16176 @000000dc
unix 9 [ ] DGRAM 5292 /dev/log
unix 1 [ ] STREAM CONNECTED 16182 @000000df
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从整体上看，netstat的输出结果可以分为两个部分：&lt;/p&gt;

&lt;p&gt;　　一个是Active Internet connections，称为有源TCP连接，其中&amp;quot;Recv-Q&amp;quot;和&amp;quot;Send-Q&amp;quot;指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。&lt;/p&gt;

&lt;p&gt;　　另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。
Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常见参数  &lt;/p&gt;

&lt;p&gt;-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-l 仅列出有在 Listen (监听) 的服務状态&lt;/p&gt;

&lt;p&gt;-p 显示建立相关链接的程序名
-r 显示路由信息，路由表
-e 显示扩展信息，例如uid等
-s 按各个协议进行统计
-c 每隔一个固定时间，执行该netstat命令。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到&lt;/p&gt;

&lt;p&gt;备注：&lt;br&gt;
这篇 &lt;a href=&quot;linux%E5%91%BD%E4%BB%A4%E4%BA%94%E5%88%86%E9%92%9F%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9B%E5%8D%81%E4%B8%89&quot;&gt;blog&lt;/a&gt; 说netstat命令似乎已经不再维护了，后续将被ip和ss命令取代。&lt;br&gt;
&lt;img src=&quot;../images/netstat_subsititute.jpg&quot; alt=&quot;netstat-replaced&quot;&gt; &lt;/p&gt;

&lt;h2&gt;6. vimdiff&lt;/h2&gt;

&lt;p&gt;linux/mac 下对比多个不同文件，多个不同文件以vim方式打开，可编辑保存，不同的地方会有高亮显示。非常实用，我常用来查看不同的配置文件区别。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/vimdiff.jpg&quot; alt=&quot;vimdiff.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;有几种方法可以使用vimdiff：   &lt;/p&gt;

&lt;p&gt;－ vimdiff file1 file2
－ vim -d file1 file2
－ vim file1 之后打开vim后输入:vertical diffsplit file2&lt;/p&gt;

&lt;p&gt;下面是vimdiff中的一些常用快捷键：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ctrl-w H（把当前窗口移到最左边）&lt;/li&gt;
&lt;li&gt;Ctrl-w L（把当前窗口移到最右边）&lt;/li&gt;
&lt;li&gt;]c，跳到下一个差异点&lt;/li&gt;
&lt;li&gt;[c，跳到上一个差异点&lt;/li&gt;
&lt;li&gt;qa，同时退出&lt;/li&gt;
&lt;li&gt;wa，同时保存&lt;/li&gt;
&lt;li&gt;wqa，同时保存并退出
－ qa，同时退出不保存&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;7. head&lt;/h2&gt;

&lt;p&gt;head 可以用来查看一个文件的前几行，我通常用来查看一个文件的结构。算是最简单的一个命令了，但是很实用啊，当然如果配合其他命令使用起来就更舒服了，比如配合管道做 grep，或者配合管道用 column 来格式化显示csv格式的文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/head_command.jpg&quot; alt=&quot;head_command.jpg&quot;&gt;&lt;/p&gt;

&lt;h2&gt;8. grep&lt;/h2&gt;

&lt;p&gt;这个命令就不用说了，因为用得太多了。常用来在很多数据里找到匹配某一模式［可以是正则哦，很强大］的字段，我更常用的场景是配合 “tail －f” 来在实时更新的日志里查找一些相关的字段，比如查找某一个请求api，在debug的时候比较常用。&lt;/p&gt;

&lt;p&gt;默认的grep是没有高亮匹配字段的，可以在grep 后加上 &amp;quot;--color&amp;quot;来高亮匹配的字段，更方便的做法是 &lt;code&gt;alias grep=&amp;quot;grep --color=auto&lt;/code&gt;，这样每次用grep的时候都有高亮了，用起来更方便。&lt;/p&gt;

&lt;p&gt;常用的几个参数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;-a 以文本文件方式搜索
-c 计算找到的符合行的次数
-i 忽略大小写
-n 顺便输出行号
-v 反向选择，即找 没有搜索字符串的行
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;9. du&lt;/h2&gt;

&lt;p&gt;以前一直没有用过这么命令，因为都用 &lt;code&gt;ls&lt;/code&gt; 加上一些参数来查看文件大小。但有一次，我从 AWS S3 上下载了将近1000个文件下来，想查看这一千个文件的总大小，用 `ls -lh&amp;#39; 发现只能查看每个文件的大小，而显示的文件夹大小并不是文件夹下所有文件的大小，而且这个文件夹的一些元信息的大小：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/ls_command.jpg&quot; alt=&quot;ls_command.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;所以查了半天，才找到 du 这个命令，用起来方便多了。&lt;/p&gt;

&lt;p&gt;关于 ls 和 du 这两个命令，我觉得下面这几个帖子值得一看：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/55/what-does-size-of-a-directory-mean-in-output-of-ls-l-command&quot;&gt;what-does-size-of-a-directory-mean-in-output-of-ls-l-command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_70122437010122m1.html&quot;&gt;file holes/文件黑洞&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;10. tail&lt;/h2&gt;

&lt;p&gt;tail命令和head相反，查看文件的最后几行。不过最常用的还是加上 &amp;quot;-f&amp;quot; 参数后和grep一起使用。&lt;/p&gt;

&lt;h2&gt;11. scp&lt;/h2&gt;

&lt;p&gt;scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。  &lt;/p&gt;

&lt;p&gt;以前在windows下开发的时候，和服务器上的文件上传下载都是通过 securcrt 的sz 和 rz命令，现在用 MAC 了，才知道原来还有这样一个好用的命令，真是弱爆了呀。已经有一篇&lt;a href=&quot;http://www.cnblogs.com/peida/archive/2013/03/15/2960802.html&quot;&gt;文章&lt;/a&gt;讲这个命令很详细了，我就简单copy一下，把自己常用的参数含义纪录下来。&lt;/p&gt;

&lt;p&gt;scp [参数] [原路径] [目标路径]&lt;/p&gt;

&lt;p&gt;-B  使用批处理模式（传输过程中不询问传输口令或短语）&lt;br&gt;
-C  允许压缩。（将-C标志传递给ssh，从而打开压缩功能）&lt;br&gt;
-p 保留原文件的修改时间，访问时间和访问权限。&lt;br&gt;
-q  不显示传输进度条。&lt;br&gt;
-r  递归复制整个目录。&lt;br&gt;
-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。&lt;br&gt;
-F ssh&lt;em&gt;config  指定一个替代的ssh配置文件，此参数直接传递给ssh。&lt;br&gt;
-i identity&lt;/em&gt;file  从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。&lt;br&gt;
-l limit  限定用户所能使用的带宽，以Kbit/s为单位。&lt;br&gt;
-P port  注意是大写的P, port是指定数据传输用到的端口号   &lt;/p&gt;

&lt;h2&gt;12. wc&lt;/h2&gt;

&lt;p&gt;wc -- word, line, character, and byte count&lt;/p&gt;

&lt;h2&gt;13. mkdir&lt;/h2&gt;

&lt;h2&gt;14. tar&lt;/h2&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2014-12-12-linux-commands.md.jpg&quot; alt=&quot;2014-12-12-linux-commands.md&quot;&gt;&lt;/p&gt;

&lt;h2&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-vimdiff/&quot;&gt;技巧：Vimdiff 使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>如何处理用户手机注册时收不到验证码的问题</title>
     <link href="/verified-code-register-failed"/>
     <updated>2015-07-16T00:00:00+08:00</updated>
     <id>/verified-code-register-failed</id>
     <content type="html">&lt;h2&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;　　本文提到的所有案例【实际上就两个案例】，都是自己亲身经历过的，但为了安全友好起见，文中出现的一些数字都是假设的，如果有截图，都会把一些不便透露的信息隐藏的，我想只要能说明问题就行了。   &lt;/p&gt;

&lt;h2&gt;2. 一次新增用户骤减的经历&lt;/h2&gt;

&lt;p&gt;　　那是之前做的一个项目【假设名字叫 Girl】，这个项目对外简单来说有两个访问等级【匿名和登陆】，然后如果需要登陆的话，需要经过一个统一的用户管理系统【假设名字叫 Boy】，boy ，girl 和 第三者【也就是用户 users】之间的关系可以用下面这张图一探一二。   &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/girl-boy-and-user.jpg&quot; alt=&quot;girl-boy-and-user.jpg&quot;&gt; &lt;/p&gt;

&lt;p&gt;　　然后我们定义一下新增用户，所谓新增用户，就是：那些对这个 girl 因为 permission limited 而不满的人，他们愿意通过 boy 注册或登陆之后，全方位地拥有 girl。&lt;/p&gt;

&lt;p&gt;　　事件发生的时间我们假设在 1月1号 - 1月12号 这段时间，在1月9号之前的一段时间，我们发现 girl 项目每天的新增用户都稳定在 100 - 150 之间，然后1月10号，11号是周末，大家12号周一来上班，第一时间当然是看这个周末又新增了多少用户了，我勒个去，一看，才新增了20个不到，oh ~~ my ~~~ go~~~~d, what happened ?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/oh-my-god.gif&quot; alt=&quot;oh-my-god.gif&quot;&gt;&lt;/p&gt;

&lt;p&gt;　　好吧，蛋定后，我们就开始找原因了，新增用户数据不可能一下子就跳崖了啊~&lt;/p&gt;

&lt;p&gt;“此处省略各种场景~~~”     &lt;/p&gt;

&lt;p&gt;　　最后原因定位了，是boy出问题了，关键时候掉链了。因为用户来注册的时候，很多都是通过手机注册的，手机注册需要输入那蛋疼的验证码，然后问题就出来了，11号，12号两天验证码发送出现了问题，选择用手机注册的新用户没法收到验证码，自然也就没法 wholly own that girl 了。当然最后修正好这个问题后，每日新增用户又稳定在 100 - 150 了。&lt;/p&gt;

&lt;h2&gt;3. 最近的一次经历&lt;/h2&gt;

&lt;p&gt;　　前几天一个师兄和我联系，他们做了一个创业公司。既然是师兄，当然要支持了，于是我就准备注册一下，但是同样的问题也发生了，同样也是收不到验证码，而且他们目前只支持手机注册，出现这个问题，比上面那个例子更严重，因为在问题解决之前，都不会有一个新增用户了。而且，聊下来，似乎都是我第一个发现这个问题的，不知道是不是他们后台没有做新增用户这块儿的监控。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/register-photo-2.jpg.jpg&quot; alt=&quot;register-photo-2.jpg.jpg&quot;&gt;&lt;/p&gt;

&lt;h2&gt;4. 同一个坑，为毛还要掉两次&lt;/h2&gt;

&lt;p&gt;　　就在这周，第一个例子中的那个问题再次出现了。还是同样项目，还是同样的人员，还是同样的问题。&lt;/p&gt;

&lt;p&gt;　　看到这个问题，我的第一反应是，怎么之前出现过的问题现在依然还在。为什么同一个坑，还要掉进去两次呢？我们就先不深究到底是不是用户那边出问题了。我的态度是：即使产品这边发送手机验证码的module是work的，而是用户手机端本身有问题，收不到短信验证码，那我们也要尝试替用户解决这个问题。下面我将分析一下，就算接触不了用户的手机，怎么最大限度地替用户解决问题。【 其实图片中已经说到了我的解决方案，但是为了说得更清晰，我在下面一节仔细讲讲】&lt;/p&gt;

&lt;h2&gt;5. 怎么避免掉进同一个坑&lt;/h2&gt;

&lt;p&gt;　　事实上，上面关于 girl 和 boy 项目的那张图有一个重要的遗漏，更完整的应该是下面这样子的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/girl-boy-and-user-1.jpg&quot; alt=&quot;girl-boy-and-user-1.jpg&quot;&gt; &lt;/p&gt;

&lt;p&gt;　　我想这下子有经验的人应该一眼就能看出来，这个结构有一个很大的、并且也是很常见的问题了，就是传说中的单点故障。因为后面的很多菇凉【就是代号如 girl 的那些产品】，要想全部拥有它们，所有用户就都得先通过 boy 的这门关卡。如果说，哪天 boy 不高兴了，或者和 boy 相关的下游模块抽风了，那所有用户就都只能干瞪眼了。   &lt;/p&gt;

&lt;p&gt;　　怎么避免掉进同一个坑，这个问题很宽泛了，都是要具体场景，具体需求实际分析了。今天我想记录一下，我对手机注册这个坑的一个解决办法。我先把案例一中的注册页面贴到下面： &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/register-photos-1.jpg&quot; alt=&quot;register-photos-1.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;　　首先，注册的时候要提供至少两种注册方式：手机和邮箱，现在很多网站除了这两种方式，还有微信、qq登陆这种方式。比如说，上面提到的师兄的创业项目，在注册时只支持手机注册，他们在这个方面第一要改进的就应该是提供第二种注册方法。这是简单的第一步粒度很粗的解决方案。&lt;/p&gt;

&lt;p&gt;　　两种注册方式真的就没有问题了吗？现在我们来看看案例一中的注册界面，如果这个时候，什么信息都填完整了，就等验证码的时候出问题了，那怎么办？首先，这个网站确实提供了邮箱注册方式，但尼玛这“邮箱注册”四个字也太小了吧，而且在图片里看起来还算容易找到，但是在整个网页里看，因为干扰元素太多，“邮箱注册”这四个字得花个吃奶的劲儿才能找到啊。也不知道是哪门子的交互设计砖家这样设计的，好了，言归正传。如果用户收不到手机验证码，那能有幸发现 “邮箱注册” 这四个小字的用户就很幸运了，可以转为邮箱注册。更值得幸运的是，这个网站，无论是手机注册还是邮箱注册，需要用户填写的信息都很少，即使手机注册失败，转到邮箱注册时，也不会再次花费用户的时间。&lt;/p&gt;

&lt;p&gt;　　但是，很多情况下，用户注册时需要填写不少的信息，什么生日，性别，地址，验证问题等等，如果用户花了极大的耐心终于填完这些信息，然后突然发现尼玛验证码收不到了，而转为邮箱注册的话这些信息又得重新再写，这给用户留下的心理阴影，那得多大啊，反正我已经受伤很多次了。所以，即使在提供两种注册方式的情况下，在很多时候，还是会有细节上、体验上的问题。&lt;/p&gt;

&lt;p&gt;　　Details make perfect。有了两种注册方式，再把细节处理好，我觉得那就足够好了。假设说，用户是以手机注册的，这个时候填完了很多附加信息，突然发现验证码收不到，有两种非常 nice 的解决方案：   &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提示，一定要提示用户可以转为邮箱注册，并且告诉用户，即使转为邮箱注册，之前填过的信息都不会丢失；&lt;/li&gt;
&lt;li&gt;因为手机验证码都有一个时间限制，大多都是30-60秒，那前端完全可以监控，看倒计时完成之前，用户是否有在验证码输入框中输入数据，如果说，一个验证码的有效时间是60秒，但直到50秒时用户还没有在验证码输入框中输入数据，那么前端就可以提示用户，也许手机验证码会延迟很久【一定要用“延迟”，把责任推到运营商】，然后弹出一个邮箱输入框，告知用户，可以输入邮箱，通过邮箱来接收验证码即可。&lt;/li&gt;
&lt;/ul&gt;
</content>
   </entry>
   
   <entry>
     <title>我常用的 sublime 快捷键</title>
     <link href="/sublime-key-shortcut"/>
     <updated>2015-06-26T00:00:00+08:00</updated>
     <id>/sublime-key-shortcut</id>
     <content type="html">&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;　　之所以要整理一下我常用的 sublime 快捷键，是源于一个 blog &lt;a href=&quot;http://tech.glowing.com/cn/advices-to-junior-developers/&quot;&gt;如何提升你的能力？给年轻程序员的几条建议&lt;/a&gt;。这个作者 &lt;a href=&quot;https://github.com/yejianye&quot;&gt;Ryan&lt;/a&gt; 是我的新boss，在当时第一次面试结束的时候，我问了他一个问题，像我这样子刚工作不久，基础不好的新人，应该怎么来提升自己。当时他简单的说了一下，内容和博文里面的差不多，没想到不到一个星期在公司的微信公众号上就出现了这样一篇文章。虽然不确定是不是因为我的那个问题而写的，但确实很感动。我想，在个人成长的过程中，如果有人能拉一把，那感觉就跟买股票时，有人突然给了一个内幕消息似的。无论如何，都要谢谢 Ryan，也要感谢他的这篇文章。  &lt;/p&gt;

&lt;p&gt;　　我用sublime很久了，一些快捷用法也挺熟悉，不过似乎还没怎么整理过。估计以后都要和sublime同甘共苦了，还是很有必要好好总结一下的，所以就有了这篇博客。&lt;/p&gt;

&lt;p&gt;　　需要注意的是，sublime的快捷键在 OSX 下和 Windows 下是不一样的，这里我就以 OSX 为标准吧。完整的快捷键可以在 sublime -&amp;gt; Preferences -&amp;gt; King Bindings [Default, User] 这里查看和更改设置。&lt;/p&gt;

&lt;p&gt;　　先说明一下，如果快捷键不work的话，一般是因为和系统或其他快捷键有冲突，可以在 preference -&amp;gt; key binding 里更改一下。&lt;/p&gt;

&lt;h2&gt;1. 功能查找：ctrl + p&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;直接输入，可以快速查找文件&lt;/li&gt;
&lt;li&gt;输入@+函数名，查找函数，这个功能还有快捷键：ctrl + r，已经直接在查找栏里不全了一个 @ 了。&lt;/li&gt;
&lt;li&gt;输入#+文本，文件内文本匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2. 多选：ctrl + d&lt;/h2&gt;

&lt;p&gt;把光标放在一个单词上，按下ctrl + D,将选择这个单词。一直按住ctrl且按D多次，将选择当前选中项的下一个匹配项。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/ctrld.gif&quot; alt=&quot;ctrld.gif&quot;&gt;&lt;/p&gt;

&lt;h2&gt;3. 打开关闭边栏： ctrl + k, ctrl + b&lt;/h2&gt;

&lt;p&gt;这个功能个人觉得很实用，特别是有一个竖屏的时候，在竖屏上写代码时，ctrl + k, ctrl + b 把侧边栏关闭，那感觉叫一个酸爽啊，哈哈。&lt;/p&gt;

&lt;h2&gt;4. 文本查找：ctrl + f, ctrl + shift + f&lt;/h2&gt;

&lt;p&gt;ctrl + f：当前文件内查找
ctrl + shift + f：在当前打开的folder中的所有文件内查找，还可以有替代功能【在windows下，sumblime 2，好像用搜狗輸入法的中文時，不能使用这个功能，需要切换成美式键盘才可以使用这个功能】&lt;/p&gt;

&lt;h2&gt;5. 命令模式：ctrl + shift + p&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;minimap：隐藏或显示右侧的小地图&lt;/li&gt;
&lt;li&gt;set syntax：设置当前文本语法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;6. 快速跳到某一行：ctrl + g&lt;/h2&gt;

&lt;h2&gt;7. 完整拷贝，避免格式错乱：ctrl + shift + v&lt;/h2&gt;

&lt;p&gt;我们发现，在从别的文件中拷贝一段代码过来的时候，多半只是第一行缩进，后面都乱了，这时可以使用Ctrl + Shift + V进行粘贴，可以在粘贴的过程中保持缩进，这时格式都是正确的。&lt;/p&gt;

&lt;h2&gt;8. 重新打开关闭的标签：command + shift + t&lt;/h2&gt;

&lt;p&gt;在Chrome里面，如果你不小心关闭了某个标签页并想恢复它，你可以按下Shift + Ctrl + T重新打开它。
在ST3中也一样，如果你不小心关闭了某个文件，可以按下Shift + command + T快速恢复。连续重复该按键，ST将会按照关闭的先后顺序重新打开标签页。&lt;/p&gt;

&lt;h2&gt;9. 左右标签切换：command + shift + {, }&lt;/h2&gt;

&lt;p&gt;command + shift + {, 转向当前标签的左面一个标签，反之。&lt;/p&gt;

&lt;h2&gt;10. 删除整行：ctrl + shift + k / ctrl + x&lt;/h2&gt;

&lt;p&gt;同样的，在windows下，如果使用搜狗输入法的话，这样也会不能用，应该是被搜狗本身的快捷键覆盖了，需要切换到美式键盘才行。   &lt;/p&gt;

&lt;h2&gt;11. 强力分屏，宽屏的福音：command + alt + 数字键&lt;/h2&gt;

&lt;p&gt;同样也是我经常使用的一个快捷键，因为有3个屏幕，一个笔记本，一个23的宽屏，一个19的竖屏。在竖屏上写代码时基本都是 ctrl + k, ctrl + b 关闭左侧边栏，在宽屏上写代码时常常会用 command + alt + 2 切换成2屏，刷起来感觉刁刁的，爽爽的。&lt;/p&gt;

&lt;h2&gt;12. 关闭当前文件：ctrl + w&lt;/h2&gt;

&lt;h2&gt;13. 选择行：ctrl + l&lt;/h2&gt;

&lt;p&gt;选择某行，重复可以依次增加选择下一行。&lt;/p&gt;

&lt;h2&gt;14. 全屏：ctrl + command + f&lt;/h2&gt;

&lt;h2&gt;15. 切换标签：command + 数字&lt;/h2&gt;

&lt;p&gt;切换到第N个文件。&lt;/p&gt;

&lt;h2&gt;16. 快速查找下一个、上一个&lt;/h2&gt;

&lt;p&gt;选中单词，command + g，快速选中下一个，command + shift + g，快速选中上一个。&lt;/p&gt;

&lt;h2&gt;17. 缩进中tab转为space&lt;/h2&gt;

&lt;p&gt;command + , 打开用户设置，设置 &amp;quot;translateTabsToSpaces&amp;quot; 为 &amp;quot;ture&amp;quot;，然后保存一下就ok了。&lt;/p&gt;

&lt;p&gt;顺便了解一下sublime加载配置文件的顺序：&lt;/p&gt;

&lt;p&gt;Packages/Default/Preferences.sublime-settings
Packages/Default/Preferences (&lt;platform&gt;).sublime-settings
Packages/User/Preferences.sublime-settings
Packages/&lt;syntax&gt;/&lt;syntax&gt;.sublime-settings
Packages/User/&lt;syntax&gt;.sublime-settings&lt;/p&gt;

&lt;p&gt;更多的配置详情可以查询这两个链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.sublimetext.com/docs/2/indentation.html&quot;&gt;config sublime 1&lt;/a&gt;
&lt;a href=&quot;http://www.sublimetext.com/docs/indentation&quot;&gt;config sublime 2&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;18. 安装插件&lt;/h2&gt;

&lt;p&gt;按Ctrl+`调出console，如果这个快捷键不管用，肯定是有其他工具占用了这个快捷键。如果成功调出console，粘贴下面的代码，安装package control组件。  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;import urllib2,os;pf=&amp;#39;Package Control.sublime-package&amp;#39;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),&amp;#39;wb&amp;#39;).write(urllib2.urlopen(&amp;#39;http://sublime.wbond.net/&amp;#39;+pf.replace(&amp;#39; &amp;#39;,&amp;#39;%20&amp;#39;)).read())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功后重启sublime，command + shift + p调出命令面版，输入install，应该能找到install package的选项。&lt;/p&gt;

&lt;h2&gt;19. 大小写互换&lt;/h2&gt;

&lt;p&gt;command + kl：将选中的单词转换为小写
command + ku：将选中的单词转换为大写&lt;/p&gt;

&lt;h2&gt;20. 折叠函数&lt;/h2&gt;

&lt;p&gt;command + k + 1: 折叠所有函数&lt;br&gt;
command + k + j: 展开所有函数    &lt;/p&gt;

&lt;p&gt;如果不work，查看： edit -&amp;gt; code foldingcd &amp;#39;dkaf&amp;#39;&lt;/p&gt;

&lt;h2&gt;21. 复制粘贴整行&lt;/h2&gt;

&lt;p&gt;command + shift + d: 复制光标所在整行，并粘贴到下一行。&lt;/p&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-01-26-sublime-key-shortcut.md.jpg&quot; alt=&quot;2015-01-26-sublime-key-shortcut.md&quot;&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>一次微信升级引发的思考</title>
     <link href="/thinking-of-wechat-design"/>
     <updated>2015-06-08T00:00:00+08:00</updated>
     <id>/thinking-of-wechat-design</id>
     <content type="html">&lt;h2&gt;1. 先看看升级前[6.1]和升级后[6.2]的区别&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;升级前：6.1&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/wechat1.jpg&quot; alt=&quot;6.1.1&quot;&gt;
&lt;img src=&quot;../../images/wechat2.jpg&quot; alt=&quot;6.1.2&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;升级后： 6.2&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/wechat3.jpg&quot; alt=&quot;6.2.1&quot;&gt;
&lt;img src=&quot;../../images/wechat4.jpg&quot; alt=&quot;6.2.2&quot;&gt;&lt;/p&gt;

&lt;h2&gt;2. 我对这次升级的第一印象&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/awesome.jpg&quot; alt=&quot;awesome&quot;&gt;&lt;/p&gt;

&lt;p&gt;　　微信这次升级应该有不少改善的地方，我就 &amp;quot;钱包&amp;quot; 这个比较让我满意的功能点来谈谈我的感想。当时我打开钱包这个功能的时候，第一反应是 “wow，实在太赞了，终于把 “零钱” 这个按钮放出来了“。先说说我为什么喜欢零钱这个按钮，因为红包，常常抢红包，没几天我就会很好奇地去看看自己现在抢红包抢了多少钱，于是乎每次都要操作好几次：我 -&amp;gt; 钱包 -&amp;gt; 钱包 -&amp;gt; 零钱。而现在我只需要操作两次：我 -&amp;gt; 钱包 就可以看见我的零钱有多少了。一下子节省了两步，可能你会觉得这没什么稀奇的。可是我想说，对我这种经常使用这个功能来说的人，两步已经足够让我们惊喜了。   &lt;/p&gt;

&lt;p&gt;　　好了，相信不少人看到我上面的说法，大都想说，众口难调，也许这个功能的升级只是让少部分我这种类型的用户满意而已，也许很多不想把 “零钱” 这个功能暴露出来的用户会吐槽这个改善点。yes，我相信是会有吐槽的用户。但是，我相信每一次升级，都肯定是经过深思熟虑的，肯定是经过验证的。这里就引出了一个很有趣的问题，在没有升级这个功能之前，微信产品组是基于什么来决定要改善这样一个功能的，是经过什么东西来验证这个功能的升级是有必要的？这个问题，也是我通过微信这次升级获得的思考和感悟----如何决定一个功能是否要改善？如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？   &lt;/p&gt;

&lt;p&gt;　　好的，让我们先把问题强调一下，因为最后还要梳理方案呢。   &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 1. 如何决定一个功能是否需要改善？&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;&lt;em&gt;问题 2. 如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？&lt;/em&gt;&lt;/strong&gt;   &lt;/p&gt;

&lt;h2&gt;3. 如何决定一个功能是否需要改善&lt;/h2&gt;

&lt;p&gt;　　其实，在感谢这次升级之余，我想过一个问题：我假设有很多用户向我一样，也很喜欢 ”零钱“ 这个功能的改善。但我确实很好奇，微信是怎么决定来要改善 ”零钱“ 这个功能的？作为一个做技术出生的，我从技术角度想了想，发现这个问题其实做起来，那是easy enough的，而且是完全可以量化的。&lt;/p&gt;

&lt;p&gt;　　在&lt;a href=&quot;http://book.douban.com/subject/25942507/&quot;&gt;《参与感》&lt;/a&gt; 这本书中提到小米最初是如何呵护前几百个粉丝的，如何通过与粉丝的互动来改善小米的功能的。我想，一个反馈很好的功能升级，必然是在某种程度上与用户有所互动后的决定，或者说是在与用户 ”沟通” 后的决议。当然微信用户这么大，不可能向小米当初初创的时候一样，维护一个用户bbs来讨论用户的观点。必须要用一种更精准，更可以量化，可以解释，而且成本低廉的方法来做到与用户在功能点上的 “沟通”。   &lt;/p&gt;

&lt;p&gt;　　好了，说了这么多废话，铺垫都全打好了，下面我就直接来说说在我看来，微信是怎么做到与用户 ”沟通“，微信是怎么决定要升级 ”零钱“ 这个功能的吧？  &lt;/p&gt;

&lt;p&gt;　　其实，all roads lead to Rome，“沟通”的初衷是为了知道用户的想法，but我们应该要知道，用户的表达自己的想法，很多时候并不是通过语言来表达呢【甚至很多人根本没法用语言表达，特别是我这种光长得帅但表达能力处于世界级 low 20%的人】，用户还有很多其他的方法来表达自己的想法，其中最真实，最可信，最可量化的就是用户的action，actions speak louder than words。所以，我们要想知道用户的想法，其实完全可以通过另一条道路，即去探索用户的action，而且这种方法对所有用户都适用，男女老少通吃啊。    &lt;/p&gt;

&lt;p&gt;　　so，现在又来一个问题了，这里的用户的action，具体指的是什么呢？下面给大家一张图，只要做过SEO的，相信看见这张图就完全明白我接下来要说的了。    &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 3. 用户的action，具体指的是什么&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/google_hot_2.jpg&quot; alt=&quot;google_hot_v2.jpg&quot;&gt;    &lt;/p&gt;

&lt;p&gt;　　上面是一张google点击的热点图，颜色越深代表越受到用户的关注。   &lt;/p&gt;

&lt;p&gt;　　google的这个热点分析做得比较复杂，我们就不深入了。接着说我对“用户的action”这个问题的看法。其实最简单，也是最可信的action就是用户的点击了。每一个click，都可以看作用户对每一个功能的关注度，只要时间长，用户样本多，那么这个数据就是可信的。通过用户的点击数据，针对于用户来说，我们可以知道用户最常用的是哪些功能；针对于产品来说，我们可以知道一个产品的新功能点在发布后一段时间内的点击率的变化过程和趋势。&lt;/p&gt;

&lt;p&gt;　　好了，其实上面我堆砌了几打的措辞，就是为了突出上面这段话，就是为了引出我认为本文的核心词---用户的点击数据。    &lt;/p&gt;

&lt;p&gt;　　下面，我想梳理一下我的思路，以对上面提出的三个问题作答的形式来表明我的观点。   &lt;/p&gt;

&lt;h2&gt;4. The kernel behind my mind&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 3. 用户的action，具体指的是什么&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;用户的action，简单的是指用户的点击数据；复杂的是指用户在每一个功能页面的停留时间。
至于怎么处理分析这些数据，方法就太多了。   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 2. 如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;可以根据用户对APP上每一个功能点的点击数据来做统计分析。功能点的划分可以有不同的维度，
比如说微信6.1的钱包是可以是一个功能点，钱包里的零钱也可以作为一个功能点。也就是说，
我们可以以不同的维度和粒度来区分功能点，对每一个功能点来做用户点击数据的统计分析。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 1. 如何决定一个功能是否需要改善？&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;有了上面的各个功能点的统计数据，我想大概就能决定一个功能点是否有必要更改了。
当然，这只是其中一个因素，一个功能点的改善肯定不仅仅靠数据来决定的，
也要看这个逻辑是否合理。比如说微信6.1的钱包，我要想看我自己的零钱的话，
步骤是： 我 -&amp;gt; 钱包 -&amp;gt; 钱包 -&amp;gt; 零钱，我会觉得很奇怪，为什么会有两个“钱包”的功能，
这在功能点上不是重复了吗？
如果说升级成6.2的钱包的花，操作步骤是：我 -&amp;gt; 钱包，
第一，去重了“钱包”这个重复的功能点，
第二，不用点击零钱即可预先知道自己的零钱余额有多少。
当然，这个细节还有很多可以提的，大家可以自行发挥想象和交流。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5. 如何做到真正的参与感&lt;/h2&gt;

&lt;p&gt;　　所有的产品，都是服务于用户。熟话说得好，不以恋爱为目的的约会都是瞎折腾，不以用户为女神的产品都是瞎糊弄。既然产品的核心是用户，那我们关于产品所做的一切设计，优化甚至是改变都应该在改动之前与用户有过沟通，要确保用户对我们所做的改动有所认同。   &lt;/p&gt;

&lt;p&gt;　　我很赞成小米初期的那种做法，维护一个简单的bbs，每天和粉丝们互动，收集需求，整理需求，规划产品，step by step地做到今天这个样子，值得借鉴和思考，但不可照搬。其一，因为人家的那种粉丝和其他很多产品的粉丝都不一样，人家的那种粉丝还有另外一个称呼 ”发烧友“，这些粉丝是有足够的耐心和愿意花足够的时间来反馈产品的优缺点和各自需求的。其二，当一个产品的用户数大了后，维护这个bbs将会话费大量人力物力，性价比太低。   &lt;/p&gt;

&lt;p&gt;　　既然如此，既要和用户沟通，又要保证沟通成本，采用上面说的技术方案岂不是一个很不错的方法。而且上面说的技术方案，实现起来足够简单，而且可量化，可解释，甚至可跟踪。   &lt;/p&gt;

&lt;h2&gt;6. 最后，我想说&lt;/h2&gt;

&lt;p&gt;　　最后，我想说，以上所有，都只是自己对微信这次升级中，钱包功能的一个简单看法。小生是后端工程师一枚，不是的产品经理，只是简单的出于对这次升级的感谢，以及对产品的一点技术方面的简单思考而写的这篇文章。bug肯定很多，不过我享受调bug这个过程啊，哈哈。&lt;/p&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-06-08-thinking-of-wechat-design.md.jpg&quot; alt=&quot;2015-06-08-thinking-of-wechat-design.md&quot;&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Python 并发编程之一：Gevent</title>
     <link href="/python-gevent"/>
     <updated>2015-05-28T00:00:00+08:00</updated>
     <id>/python-gevent</id>
     <content type="html">&lt;h2&gt;1. 什么是Gevent&lt;/h2&gt;

&lt;p&gt;gevent是一个基于libev的python并发框架,以微线程greenlet为核心，使用了epoll事件监听机制以及诸多其他优化而变得高效.而且其中有个monkey类, 将现有基于Python线程直接转化为greenlet(类似于打patch).&lt;/p&gt;

&lt;p&gt;greenlet 包是 Stackless 的副产品，其将微线程称为 “tasklet” 。tasklet运行在伪并发中，使用channel进行同步数据交换。&lt;/p&gt;

&lt;p&gt;一个”greenlet”，是一个更加原始的微线程的概念，但是没有调度，或者叫做协程。这在你需要控制你的代码时很有用。你可以自己构造微线程的 调度器；也可以使用”greenlet”实现高级的控制流。例如可以重新创建构造器；不同于Python的构造器，我们的构造器可以嵌套的调用函数，而被嵌套的函数也可以 yield 一个值。(另外，你并不需要一个”yield”关键字，参考例子)。&lt;/p&gt;

&lt;h2&gt;2. 什么是 Coroutine&lt;/h2&gt;

&lt;p&gt;要理解Gevent，明白Gevent的执行机制，需要了解另外一个概念：Coroutine，中文叫做协程。第一次看见这个名词，确实很奇怪，进程、线程都了解了，突然冒出个协程，还真有点反应不过来。&lt;/p&gt;

&lt;p&gt;按照 &lt;a href=&quot;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&quot;&gt;进程、线程和协程的理解&lt;/a&gt; 的说法：   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的说法不是很好理解，后来发现这篇文章 &lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt;, 里面对协程的解释是：  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;用简单的一句话来说Coroutine，就是可以暂时中断，之后再继续执行的程序，
我们来看一个例子，事实上Python就有最基础的Coroutine，也就是generator
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，通过上面两篇文章，理解协程已经对比协程、进程、线程的概念就清晰很多了：  &lt;/p&gt;

&lt;p&gt;协程就是一种特殊的并发机制，其调度[就是指什么时候调用什么函数]完全由程序员指定，比如说这篇文章里的例子：  &lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt; ：    &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;# -*- coding: utf8 -*-
def foo():
    for i in range(10):
        # 丢资料并且把主控权交给呼叫者
        yield i
        print u&amp;#39;foo: 主控又回到我手上了，打我阿笨蛋&amp;#39;

bar = foo()
# 执行coroutine
print bar.next()
print u&amp;#39;main: 现在主控权在我们手上，做点杂事&amp;#39;
print &amp;#39;main:hello baby!&amp;#39;
# 回到刚才foo这个coroutine中断的地方继续执行
print bar.next()
print bar.next()


###结果：

0
main: 现在主控权在我们手上，做点杂事
main:hello baby!
foo: 主控又回到我手上了，打我阿笨蛋
1
foo: 主控又回到我手上了，打我阿笨蛋
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. Gevent适用场景&lt;/h2&gt;

&lt;p&gt;说到Gevent的适用场景，不得不先理解Gevent的优缺点。按照上面我们的说法，还有那两篇文章的理解，Gevent是通过协程的机制来实现并行，即其并行机制并没有利用到多核CPU的优势，所以很明显了，Gevent的优缺如下：    &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多进程能够利用多核优势，但是进程间通信比较麻烦，另外，进程数目的增加会使性能下降，进程切换的成本较高。程序流程复杂度相对I/O多路复用要低。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;I/O多路复用是在一个进程内部处理多个逻辑流程，不用进行进程切换，性能较高，另外流程间共享信息简单。但是无法利用多核优势，另外，程序流程被事件处理切割成一个个小块，程序比较复杂，难于理解。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;线程运行在一个进程内部，由操作系统调度，切换成本较低，另外，他们共享进程的虚拟地址空间，线程间共享信息简单。但是线程安全问题导致线程学习曲线陡峭，而且易出错。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;协程有编程语言提供，由程序员控制进行切换，所以没有线程安全问题，可以用来处理状态机，并发请求等。但是无法利用多核优势。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，协程的适用场景，应该是一些I/O密集型的并行程序，而对应的计算密集型，应当采用传统的多线程、多进程方案。   &lt;/p&gt;

&lt;h2&gt;4. Gevent编程模式和思维方法&lt;/h2&gt;

&lt;p&gt;我想从两个例子来介绍Gevent的编程模式，第一个比较简单，可以直接去看这篇文章里的开篇例子，&lt;a href=&quot;http://xlambda.com/gevent-tutorial/#&quot;&gt;gevent程序员指南&lt;/a&gt;。不过这个例子只是简单的解释gevent的执行流程和编程模式，离现实应用还有一定的距离。当看完这篇文章后，可以参考Firefox的一个实例就行了，&lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;总结一下，按照我个人的理解，要想用好gevent，需要先思考下面几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你的应用是否需要考虑Gevent；&lt;br&gt;&lt;/li&gt;
&lt;li&gt;如何把你的大任务slice成小任务，这些任务之间是否独立；&lt;br&gt;&lt;/li&gt;
&lt;li&gt;如果收集，处理小任务执行的结果；&lt;/li&gt;
&lt;li&gt;理解如何真正利用gevent来实现并行，很多情况下，如果是网络I/O，需要打patch的；比说 &lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;这里接上一点，打patch要小心，比如说打了socket的patch，要先知道会不会影响到本应用中其他用了socket的服务，因为打patch是直接替换了当前运行时环境里的socket，所以在当前运行时环境里使用socket的服务都会受影响；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;5. Gevent In Action&lt;/h2&gt;

&lt;p&gt;因为Gevent多用于I/O密集型并发程序，而网络请求又是很常见的一种I/O请求，所以在大规模网络并发请求的时候，可以使用Gevent。相信python程序员都应该用过 requests 这个包吧，都应该知道 requests 的作者，kennethreitz，一个货真价实的 python界的大牛。他在写了 requests 的同时，还写了一个包：&lt;a href=&quot;https://github.com/kennethreitz/grequests&quot;&gt;grequest ： gevent + requests &lt;/a&gt;，把requests用gevent包了一下，实现异步的网络请求，下次大家要是有网络方面的并发请求，需要用到gevent的话，就不用重复造轮子了，直接用 &lt;a href=&quot;https://github.com/kennethreitz/grequests&quot;&gt;grequests&lt;/a&gt; 就好了。&lt;/p&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&quot;&gt;进程、线程和协程的理解&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://xlambda.com/gevent-tutorial/#&quot;&gt;gevent程序员指南&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/77240/&quot;&gt;python greenlet背景介绍与实现机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.elias.cn/Python/PyConcurrency?from=Develop.PyConcurrency&quot;&gt;Python几种并发实现方案的性能比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-05-28-python-gevent.md.jpg&quot; alt=&quot;2015-05-28-python-gevent.md&quot;&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-4. Web 高性能开发参考资料</title>
     <link href="/web-high-performance"/>
     <updated>2015-05-02T00:00:00+08:00</updated>
     <id>/web-high-performance</id>
     <content type="html">&lt;h2&gt;0. 写在前面&lt;/h2&gt;

&lt;p&gt;　　工作一年多了，发现自己还是没什么长进。学技术这件事儿，还是得靠自己啊，所以我准备以专题的形式来提升自己的能力。这篇我总结了一些搜集的比较好的讲web高性能开发的文章和书籍，都是我自己看过的。以后再也不怕别人问到高性能web的经验和知识了，用老话说，就算没吃过猪肉也应该见过猪跑吧，咱就算没经历过高性能web开发实践，也至少了解一些这方面的知识吧。哈哈。&lt;/p&gt;

&lt;h2&gt;1. 模式相关&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2014/09/05/design-pattern-cheatsheet/&quot;&gt;设计模式概览图&lt;/a&gt;&lt;br&gt;
　　以图形的形式简单阐述了各种模式的概念，图画得不错，表述也清晰，可以有空翻开看看；
&lt;img src=&quot;../images/design_pattern.png&quot; alt=&quot;design_pattern.png&quot;&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/08/software-architecture-patterns/&quot;&gt;软件架构模式&lt;/a&gt;&lt;br&gt;
　　是作者对这本书的&lt;a href=&quot;http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf&quot;&gt;Software Architecture Patterns&lt;/a&gt; 笔记和总结，写得很详细，可以时常参考，提升架构方面的基础和概念，同时，有时间也推荐读读原书，原书PDF链接在后面。&lt;br&gt;
　　这里面提的架构有：分层架构，事件驱动架构，微内核架构，微服务架构，基于空间的架构。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/10/microservice-architecture-a-quick-guide/&quot;&gt;微服务架构快速指南&lt;/a&gt;&lt;br&gt;
　　不常听说为服务架构，简单的理解，就是介于monolithic和SOA模式之间的一个架构模式，比monolithic灵活，轻便，比SOA有更强的组织性。不必过于在乎三者之间的差别，根据实际情况选择合适自己项目的架构模式。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/24/microservice-design-patterns/&quot;&gt;微服务架构的设计模式&lt;/a&gt;&lt;br&gt;
　　是&lt;strong&gt;微服务架构快速指南&lt;/strong&gt;的细节篇，里面介绍了一些常用的微服务架构的设计模式，在设计项目架构的时候，如果没有什么思路，这篇文章是很好的参考资料。简单的说，里面提到了常用的微服务设计模式：聚合器，代理，链式服务，分支，数据共享，异步消息。   &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.admin10000.com/document/5980.html&quot;&gt;大型网站系统架构的演化&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.admin10000.com/document/5981.html&quot;&gt;大型网站的灵魂——性能&lt;/a&gt;&lt;br&gt;
　　非常好的介绍大型网站架构变化的文章，这个网站有一个专门讲大型网站性能的文章系列，都非常值得学习。我把这个系列也列在下面了，写得很细，算是最值得参考和学习的文章了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5880.html&quot;&gt;关于大型网站技术演进的思考（一）--存储的瓶颈（1）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5881.html&quot;&gt;关于大型网站技术演进的思考（二）--存储的瓶颈（2）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5882.html&quot;&gt;关于大型网站技术演进的思考（三）--存储的瓶颈（3）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5909.html&quot;&gt;关于大型网站技术演进的思考（四）--存储的瓶颈（4）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5910.html&quot;&gt;关于大型网站技术演进的思考（五）--存储的瓶颈（5）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5911.html&quot;&gt;关于大型网站技术演进的思考（六）--存储的瓶颈（6）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5951.html&quot;&gt;关于大型网站技术演进的思考（七）--存储的瓶颈（7）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5952.html&quot;&gt;关于大型网站技术演进的思考（八）--存储的瓶颈终篇（8）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5966.html&quot;&gt;关于大型网站技术演进的思考（九）--网站静态化处理--总述（1）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5967.html&quot;&gt;关于大型网站技术演进的思考（十）--网站静态化处理—动静整合方案（2）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5968.html&quot;&gt;关于大型网站技术演进的思考（十一）--网站静态化处理—动静分离策略（3）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6020.html&quot;&gt;关于大型网站技术演进的思考（十二）--网站静态化处理—缓存（4）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6021.html&quot;&gt;关于大型网站技术演进的思考（十三）--网站静态化处理—CSI（5）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6022.html&quot;&gt;关于大型网站技术演进的思考（十四）--网站静态化处理—前后端分离—上（6）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6023.html&quot;&gt;关于大型网站技术演进的思考（十五）--网站静态化处理—前后端分离—中（7）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6024.html&quot;&gt;关于大型网站技术演进的思考（十六）--网站静态化处理—前后端分离—下（8）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6025.html&quot;&gt;关于大型网站技术演进的思考（十七）--网站静态化处理—满足静态化的前后端分离（9）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6026.html&quot;&gt;关于大型网站技术演进的思考（十八）--网站静态化处理—反向代理（10）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6027.html&quot;&gt;关于大型网站技术演进的思考（十九）--网站静态化处理—web前端优化—上（11）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6028.html&quot;&gt;关于大型网站技术演进的思考（二十）--网站静态化处理—web前端优化—中（12）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6029.html&quot;&gt;关于大型网站技术演进的思考（二十一）--网站静态化处理—web前端优化—下【终篇】（13）&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2. 高性能网站相关&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/20/how-to-build-a-scalable-website/&quot;&gt;如何构建高扩展性网站&lt;/a&gt;&lt;br&gt;
　　是一本小册子&lt;a href=&quot;http://book.douban.com/subject/10756899/&quot;&gt;《高扩展性网站的50条原则》&lt;/a&gt;的读书笔记。这本书不错，值得一看，在设计、改进项目架构时都可以拿来翻翻，不错的小册子。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2014/09/26/best-free-website-speed-testing-tools/&quot;&gt;最佳免费的网站性能测试工具&lt;/a&gt;&lt;br&gt;
　　这篇博文是我认为最有实际意义的一篇博文之一了，里面提到了12个免费的网站性能测试工具，比如大名鼎鼎的google pagespeed insights。我的建议是，在进行任何优化前，都先简单地用这些工具在线测试一下。不要盲目地进行后台的优化，更不要盲目的去设计一些高端的算法来做所谓的加速。比如说，一个请求后台返回的时间控制在100ms之内，但发起这个请求的js脚本被写在一个很大的js文件里面，导致下载这个js文件需要数百毫秒，那此时应该怎么优化呢？别跟我说你会让你的后台工程师去找一什么高大上的算法来解决这个问题。   &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.blogjava.net/BearRui/archive/2010/04/26/web_performance.html&quot;&gt;web高性能开发系列随笔&lt;/a&gt;&lt;br&gt;
　　算是一篇比较简单，但是完善的web性能优化博客了，里面涉及到前后端的各种优化方法，虽然我只是后台开发，但看这种文章能够让开发人员从全局的视角去设计和优化你的web系统。就跟上一篇 &lt;a href=&quot;http://colobu.com/2014/09/26/best-free-website-speed-testing-tools/&quot;&gt;最佳免费的网站性能测试工具&lt;/a&gt; 文章一样，在优化前，先全局、完整地了解你的web系统，再来说具体怎么优化吧。如果你在优化前，不知道怎么对web系统“全局”地了解，这篇博客可以入门用。  &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;3. 参考书籍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf&quot;&gt;Software Architecture Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/10756899/&quot;&gt;高扩展性网站的50条原则&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/3924175/&quot;&gt;构建高性能Web站点&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-05-02-web-high-performance.md.jpg&quot; alt=&quot;2015-05-02-web-high-performance.md&quot;&gt;&lt;/p&gt;
</content>
   </entry>
   

</feed>


</body>
</html>
