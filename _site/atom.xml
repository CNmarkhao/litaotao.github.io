<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Taotao's Zone</title>
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="stylesheet" href="/css/font-awesome/css/font-awesome.min.css" type="text/css" />
  <link rel="stylesheet" href="/css/default.css" type="text/css" />
  <link rel="stylesheet" href="/css/desktop.css" type="text/css" />
  <link rel="stylesheet" href="/css/mobile.css" type="text/css" />
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
  <script src="/js/jquery-1.11.0.min.js" type="text/javascript"></script>
  <script src="/js/jquery-migrate-1.2.1.js" type="text/javascript"></script>
  <script src="/js/jquery.transit.min.js" type="text/javascript"></script>
  <script src="/js/common.js" type="text/javascript"></script>
</head>
<body>
  <?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

   <title>Taotao's Zone</title>
   <link href="http://litaotao.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://litaotao.github.io" rel="alternate" type="text/html" />
   <updated>2015-07-11T17:36:37+08:00</updated>
   <id>http://litaotao.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>我常用的 sublime 快捷键</title>
     <link href="/sublime-key-shortcut"/>
     <updated>2015-06-26T00:00:00+08:00</updated>
     <id>/sublime-key-shortcut</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;写在前面&lt;/h2&gt;

&lt;p&gt;　　之所以要整理一下我常用的 sublime 快捷键，是源于一个 blog &lt;a href=&quot;http://tech.glowing.com/cn/advices-to-junior-developers/&quot;&gt;如何提升你的能力？给年轻程序员的几条建议&lt;/a&gt;。这个作者 &lt;a href=&quot;https://github.com/yejianye&quot;&gt;Ryan&lt;/a&gt; 是我的新boss，在当时第一次面试结束的时候，我问了他一个问题，像我这样子刚工作不久，基础不好的新人，应该怎么来提升自己。当时他简单的说了一下，内容和博文里面的差不多，没想到不到一个星期在公司的微信公众号上就出现了这样一篇文章。虽然不确定是不是因为我的那个问题而写的，但确实很感动。我想，在个人成长的过程中，如果有人能拉一把，那感觉就跟买股票时，有人突然给了一个内幕消息似的。无论如何，都要谢谢 Ryan，也要感谢他的这篇文章。&lt;/p&gt;

&lt;p&gt;　　我用sublime很久了，一些快捷用法也挺熟悉，不过似乎还没怎么整理过。估计以后都要和sublime同甘共苦了，还是很有必要好好总结一下的，所以就有了这篇博客。&lt;/p&gt;

&lt;p&gt;　　需要注意的是，sublime的快捷键在 OSX 下和 Windows 下是不一样的，这里我就以 OSX 为标准吧。完整的快捷键可以在 sublime -&gt; Preferences -&gt; King Bindings [Default, User] 这里查看和更改设置。&lt;/p&gt;

&lt;h2&gt;1. 功能查找：ctrl + p&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;直接输入，可以快速查找文件&lt;/li&gt;
&lt;li&gt;输入@+函数名，查找函数，这个功能还有快捷键：ctrl + r，已经直接在查找栏里不全了一个 @ 了。&lt;/li&gt;
&lt;li&gt;输入#+文本，文件内文本匹配&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. 多选：ctrl + d&lt;/h2&gt;

&lt;p&gt;把光标放在一个单词上，按下ctrl + D,将选择这个单词。一直按住ctrl且按D多次，将选择当前选中项的下一个匹配项。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/ctrld.gif&quot; alt=&quot;ctrld.gif&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;3. 打开关闭边栏： ctrl + k, ctrl + b&lt;/h2&gt;

&lt;p&gt;这个功能个人觉得很实用，特别是有一个竖屏的时候，在竖屏上写代码时，ctrl + k, ctrl + b 把侧边栏关闭，那感觉叫一个酸爽啊，哈哈。&lt;/p&gt;

&lt;h2&gt;4. 文本查找：ctrl + f, ctrl + shift + f&lt;/h2&gt;

&lt;p&gt;ctrl + f：当前文件内查找
ctrl + shift + f：在当前打开的folder中的所有文件内查找，还可以有替代功能【在windows下，sumblime 2，好像用搜狗輸入法的中文時，不能使用这个功能，需要切换成美式键盘才可以使用这个功能】&lt;/p&gt;

&lt;h2&gt;5. 命令模式：ctrl + shift + p&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;minimap：隐藏或显示右侧的小地图&lt;/li&gt;
&lt;li&gt;set syntax：设置当前文本语法&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;6. 快速跳到某一行：ctrl + g&lt;/h2&gt;

&lt;h2&gt;7. 完整拷贝，避免格式错乱：ctrl + shift + v&lt;/h2&gt;

&lt;p&gt;我们发现，在从别的文件中拷贝一段代码过来的时候，多半只是第一行缩进，后面都乱了，这时可以使用Ctrl + Shift + V进行粘贴，可以在粘贴的过程中保持缩进，这时格式都是正确的。&lt;/p&gt;

&lt;h2&gt;8. 重新打开关闭的标签：command + shift + t&lt;/h2&gt;

&lt;p&gt;在Chrome里面，如果你不小心关闭了某个标签页并想恢复它，你可以按下Shift + Ctrl + T重新打开它。
在ST3中也一样，如果你不小心关闭了某个文件，可以按下Shift + command + T快速恢复。连续重复该按键，ST将会按照关闭的先后顺序重新打开标签页。&lt;/p&gt;

&lt;h2&gt;9. 左右标签切换：command + shift + {, }&lt;/h2&gt;

&lt;p&gt;command + shift + {, 转向当前标签的左面一个标签，反之。&lt;/p&gt;

&lt;h2&gt;10. 删除整行：ctrl + shift + k / ctrl + x&lt;/h2&gt;

&lt;p&gt;同样的，在windows下，如果使用搜狗输入法的话，这样也会不能用，应该是被搜狗本身的快捷键覆盖了，需要切换到美式键盘才行。&lt;/p&gt;

&lt;h2&gt;11. 强力分屏，宽屏的福音：command + alt + 数字键&lt;/h2&gt;

&lt;p&gt;同样也是我经常使用的一个快捷键，因为有3个屏幕，一个笔记本，一个23的宽屏，一个19的竖屏。在竖屏上写代码时基本都是 ctrl + k, ctrl + b 关闭左侧边栏，在宽屏上写代码时常常会用 command + alt + 2 切换成2屏，刷起来感觉刁刁的，爽爽的。&lt;/p&gt;

&lt;h2&gt;12. 关闭当前文件：ctrl + w&lt;/h2&gt;

&lt;h2&gt;13. 选择行：ctrl + l&lt;/h2&gt;

&lt;p&gt;选择某行，重复可以依次增加选择下一行。&lt;/p&gt;

&lt;h2&gt;14. 全屏：ctrl + command + f&lt;/h2&gt;

&lt;h2&gt;15. 切换标签：command + 数字&lt;/h2&gt;

&lt;p&gt;切换到第N个文件。&lt;/p&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-01-26-sublime-key-shortcut.md.jpg&quot; alt=&quot;2015-01-26-sublime-key-shortcut.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>一次微信升级引发的思考</title>
     <link href="/thinking-of-wechat-design"/>
     <updated>2015-06-08T00:00:00+08:00</updated>
     <id>/thinking-of-wechat-design</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 先看看升级前[6.1]和升级后[6.2]的区别&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;升级前：6.1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/wechat1.jpg&quot; alt=&quot;6.1.1&quot; /&gt;
&lt;img src=&quot;../../images/wechat2.jpg&quot; alt=&quot;6.1.2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;升级后： 6.2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/wechat3.jpg&quot; alt=&quot;6.2.1&quot; /&gt;
&lt;img src=&quot;../../images/wechat4.jpg&quot; alt=&quot;6.2.2&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;2. 我对这次升级的第一印象&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/awesome.jpg&quot; alt=&quot;awesome&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　微信这次升级应该有不少改善的地方，我就 &quot;钱包&quot; 这个比较让我满意的功能点来谈谈我的感想。当时我打开钱包这个功能的时候，第一反应是 “wow，实在太赞了，终于把 “零钱” 这个按钮放出来了“。先说说我为什么喜欢零钱这个按钮，因为红包，常常抢红包，没几天我就会很好奇地去看看自己现在抢红包抢了多少钱，于是乎每次都要操作好几次：我 -&gt; 钱包 -&gt; 钱包 -&gt; 零钱。而现在我只需要操作两次：我 -&gt; 钱包 就可以看见我的零钱有多少了。一下子节省了两步，可能你会觉得这没什么稀奇的。可是我想说，对我这种经常使用这个功能来说的人，两步已经足够让我们惊喜了。&lt;/p&gt;

&lt;p&gt;　　好了，相信不少人看到我上面的说法，大都想说，众口难调，也许这个功能的升级只是让少部分我这种类型的用户满意而已，也许很多不想把 “零钱” 这个功能暴露出来的用户会吐槽这个改善点。yes，我相信是会有吐槽的用户。但是，我相信每一次升级，都肯定是经过深思熟虑的，肯定是经过验证的。这里就引出了一个很有趣的问题，在没有升级这个功能之前，微信产品组是基于什么来决定要改善这样一个功能的，是经过什么东西来验证这个功能的升级是有必要的？这个问题，也是我通过微信这次升级获得的思考和感悟----如何决定一个功能是否要改善？如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？&lt;/p&gt;

&lt;p&gt;　　好的，让我们先把问题强调一下，因为最后还要梳理方案呢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 1. 如何决定一个功能是否需要改善？&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;&lt;em&gt;问题 2. 如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;3. 如何决定一个功能是否需要改善&lt;/h2&gt;

&lt;p&gt;　　其实，在感谢这次升级之余，我想过一个问题：我假设有很多用户向我一样，也很喜欢 ”零钱“ 这个功能的改善。但我确实很好奇，微信是怎么决定来要改善 ”零钱“ 这个功能的？作为一个做技术出生的，我从技术角度想了想，发现这个问题其实做起来，那是easy enough的，而且是完全可以量化的。&lt;/p&gt;

&lt;p&gt;　　在&lt;a href=&quot;http://book.douban.com/subject/25942507/&quot;&gt;《参与感》&lt;/a&gt; 这本书中提到小米最初是如何呵护前几百个粉丝的，如何通过与粉丝的互动来改善小米的功能的。我想，一个反馈很好的功能升级，必然是在某种程度上与用户有所互动后的决定，或者说是在与用户 ”沟通” 后的决议。当然微信用户这么大，不可能向小米当初初创的时候一样，维护一个用户bbs来讨论用户的观点。必须要用一种更精准，更可以量化，可以解释，而且成本低廉的方法来做到与用户在功能点上的 “沟通”。&lt;/p&gt;

&lt;p&gt;　　好了，说了这么多废话，铺垫都全打好了，下面我就直接来说说在我看来，微信是怎么做到与用户 ”沟通“，微信是怎么决定要升级 ”零钱“ 这个功能的吧？&lt;/p&gt;

&lt;p&gt;　　其实，all roads lead to Rome，“沟通”的初衷是为了知道用户的想法，but我们应该要知道，用户的表达自己的想法，很多时候并不是通过语言来表达呢【甚至很多人根本没法用语言表达，特别是我这种光长得帅但表达能力处于世界级 low 20%的人】，用户还有很多其他的方法来表达自己的想法，其中最真实，最可信，最可量化的就是用户的action，actions speak louder than words。所以，我们要想知道用户的想法，其实完全可以通过另一条道路，即去探索用户的action，而且这种方法对所有用户都适用，男女老少通吃啊。&lt;/p&gt;

&lt;p&gt;　　so，现在又来一个问题了，这里的用户的action，具体指的是什么呢？下面给大家一张图，只要做过SEO的，相信看见这张图就完全明白我接下来要说的了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 3. 用户的action，具体指的是什么&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../images/google_hot_2.jpg&quot; alt=&quot;google_hot_v2.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;　　上面是一张google点击的热点图，颜色越深代表越受到用户的关注。&lt;/p&gt;

&lt;p&gt;　　google的这个热点分析做得比较复杂，我们就不深入了。接着说我对“用户的action”这个问题的看法。其实最简单，也是最可信的action就是用户的点击了。每一个click，都可以看作用户对每一个功能的关注度，只要时间长，用户样本多，那么这个数据就是可信的。通过用户的点击数据，针对于用户来说，我们可以知道用户最常用的是哪些功能；针对于产品来说，我们可以知道一个产品的新功能点在发布后一段时间内的点击率的变化过程和趋势。&lt;/p&gt;

&lt;p&gt;　　好了，其实上面我堆砌了几打的措辞，就是为了突出上面这段话，就是为了引出我认为本文的核心词---用户的点击数据。&lt;/p&gt;

&lt;p&gt;　　下面，我想梳理一下我的思路，以对上面提出的三个问题作答的形式来表明我的观点。&lt;/p&gt;

&lt;h2&gt;4. The kernel behind my mind&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 3. 用户的action，具体指的是什么&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用户的action，简单的是指用户的点击数据；复杂的是指用户在每一个功能页面的停留时间。
至于怎么处理分析这些数据，方法就太多了。   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 2. 如何来预测用户的需求，或者说如何来预测用户对功能升级的反馈？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可以根据用户对APP上每一个功能点的点击数据来做统计分析。功能点的划分可以有不同的维度，
比如说微信6.1的钱包是可以是一个功能点，钱包里的零钱也可以作为一个功能点。也就是说，
我们可以以不同的维度和粒度来区分功能点，对每一个功能点来做用户点击数据的统计分析。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题 1. 如何决定一个功能是否需要改善？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;有了上面的各个功能点的统计数据，我想大概就能决定一个功能点是否有必要更改了。
当然，这只是其中一个因素，一个功能点的改善肯定不仅仅靠数据来决定的，
也要看这个逻辑是否合理。比如说微信6.1的钱包，我要想看我自己的零钱的话，
步骤是： 我 -&amp;gt; 钱包 -&amp;gt; 钱包 -&amp;gt; 零钱，我会觉得很奇怪，为什么会有两个“钱包”的功能，
这在功能点上不是重复了吗？
如果说升级成6.2的钱包的花，操作步骤是：我 -&amp;gt; 钱包，
第一，去重了“钱包”这个重复的功能点，
第二，不用点击零钱即可预先知道自己的零钱余额有多少。
当然，这个细节还有很多可以提的，大家可以自行发挥想象和交流。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. 如何做到真正的参与感&lt;/h2&gt;

&lt;p&gt;　　所有的产品，都是服务于用户。熟话说得好，不以恋爱为目的的约会都是瞎折腾，不以用户为女神的产品都是瞎糊弄。既然产品的核心是用户，那我们关于产品所做的一切设计，优化甚至是改变都应该在改动之前与用户有过沟通，要确保用户对我们所做的改动有所认同。&lt;/p&gt;

&lt;p&gt;　　我很赞成小米初期的那种做法，维护一个简单的bbs，每天和粉丝们互动，收集需求，整理需求，规划产品，step by step地做到今天这个样子，值得借鉴和思考，但不可照搬。其一，因为人家的那种粉丝和其他很多产品的粉丝都不一样，人家的那种粉丝还有另外一个称呼 ”发烧友“，这些粉丝是有足够的耐心和愿意花足够的时间来反馈产品的优缺点和各自需求的。其二，当一个产品的用户数大了后，维护这个bbs将会话费大量人力物力，性价比太低。&lt;/p&gt;

&lt;p&gt;　　既然如此，既要和用户沟通，又要保证沟通成本，采用上面说的技术方案岂不是一个很不错的方法。而且上面说的技术方案，实现起来足够简单，而且可量化，可解释，甚至可跟踪。&lt;/p&gt;

&lt;h2&gt;6. 最后，我想说&lt;/h2&gt;

&lt;p&gt;　　最后，我想说，以上所有，都只是自己对微信这次升级中，钱包功能的一个简单看法。小生是后端工程师一枚，不是的产品经理，只是简单的出于对这次升级的感谢，以及对产品的一点技术方面的简单思考而写的这篇文章。bug肯定很多，不过我享受调bug这个过程啊，哈哈。&lt;/p&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-06-08-thinking-of-wechat-design.md.jpg&quot; alt=&quot;2015-06-08-thinking-of-wechat-design.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Python 并发编程之一：Gevent</title>
     <link href="/python-gevent"/>
     <updated>2015-05-28T00:00:00+08:00</updated>
     <id>/python-gevent</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 什么是Gevent&lt;/h2&gt;

&lt;p&gt;gevent是一个基于libev的python并发框架,以微线程greenlet为核心，使用了epoll事件监听机制以及诸多其他优化而变得高效.而且其中有个monkey类, 将现有基于Python线程直接转化为greenlet(类似于打patch).&lt;/p&gt;

&lt;p&gt;greenlet 包是 Stackless 的副产品，其将微线程称为 “tasklet” 。tasklet运行在伪并发中，使用channel进行同步数据交换。&lt;/p&gt;

&lt;p&gt;一个”greenlet”，是一个更加原始的微线程的概念，但是没有调度，或者叫做协程。这在你需要控制你的代码时很有用。你可以自己构造微线程的 调度器；也可以使用”greenlet”实现高级的控制流。例如可以重新创建构造器；不同于Python的构造器，我们的构造器可以嵌套的调用函数，而被嵌套的函数也可以 yield 一个值。(另外，你并不需要一个”yield”关键字，参考例子)。&lt;/p&gt;

&lt;h2&gt;2. 什么是 Coroutine&lt;/h2&gt;

&lt;p&gt;要理解Gevent，明白Gevent的执行机制，需要了解另外一个概念：Coroutine，中文叫做协程。第一次看见这个名词，确实很奇怪，进程、线程都了解了，突然冒出个协程，还真有点反应不过来。&lt;/p&gt;

&lt;p&gt;按照 &lt;a href=&quot;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&quot;&gt;进程、线程和协程的理解&lt;/a&gt; 的说法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的说法不是很好理解，后来发现这篇文章 &lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt;, 里面对协程的解释是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用简单的一句话来说Coroutine，就是可以暂时中断，之后再继续执行的程序，
我们来看一个例子，事实上Python就有最基础的Coroutine，也就是generator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，通过上面两篇文章，理解协程已经对比协程、进程、线程的概念就清晰很多了：&lt;/p&gt;

&lt;p&gt;协程就是一种特殊的并发机制，其调度[就是指什么时候调用什么函数]完全由程序员指定，比如说这篇文章里的例子：  &lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# -*- coding: utf8 -*-
def foo():
    for i in range(10):
        # 丢资料并且把主控权交给呼叫者
        yield i
        print u&#39;foo: 主控又回到我手上了，打我阿笨蛋&#39;

bar = foo()
# 执行coroutine
print bar.next()
print u&#39;main: 现在主控权在我们手上，做点杂事&#39;
print &#39;main:hello baby!&#39;
# 回到刚才foo这个coroutine中断的地方继续执行
print bar.next()
print bar.next()


###结果：

0
main: 现在主控权在我们手上，做点杂事
main:hello baby!
foo: 主控又回到我手上了，打我阿笨蛋
1
foo: 主控又回到我手上了，打我阿笨蛋
2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. Gevent适用场景&lt;/h2&gt;

&lt;p&gt;说到Gevent的适用场景，不得不先理解Gevent的优缺点。按照上面我们的说法，还有那两篇文章的理解，Gevent是通过协程的机制来实现并行，即其并行机制并没有利用到多核CPU的优势，所以很明显了，Gevent的优缺如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多进程能够利用多核优势，但是进程间通信比较麻烦，另外，进程数目的增加会使性能下降，进程切换的成本较高。程序流程复杂度相对I/O多路复用要低。&lt;/li&gt;
&lt;li&gt;I/O多路复用是在一个进程内部处理多个逻辑流程，不用进行进程切换，性能较高，另外流程间共享信息简单。但是无法利用多核优势，另外，程序流程被事件处理切割成一个个小块，程序比较复杂，难于理解。&lt;/li&gt;
&lt;li&gt;线程运行在一个进程内部，由操作系统调度，切换成本较低，另外，他们共享进程的虚拟地址空间，线程间共享信息简单。但是线程安全问题导致线程学习曲线陡峭，而且易出错。&lt;/li&gt;
&lt;li&gt;协程有编程语言提供，由程序员控制进行切换，所以没有线程安全问题，可以用来处理状态机，并发请求等。但是无法利用多核优势。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以，协程的适用场景，应该是一些I/O密集型的并行程序，而对应的计算密集型，应当采用传统的多线程、多进程方案。&lt;/p&gt;

&lt;h2&gt;4. Gevent编程模式和思维方法&lt;/h2&gt;

&lt;p&gt;我想从两个例子来介绍Gevent的编程模式，第一个比较简单，可以直接去看这篇文章里的开篇例子，&lt;a href=&quot;http://xlambda.com/gevent-tutorial/#&quot;&gt;gevent程序员指南&lt;/a&gt;。不过这个例子只是简单的解释gevent的执行流程和编程模式，离现实应用还有一定的距离。当看完这篇文章后，可以参考Firefox的一个实例就行了，&lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;总结一下，按照我个人的理解，要想用好gevent，需要先思考下面几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;你的应用是否需要考虑Gevent；&lt;/li&gt;
&lt;li&gt;如何把你的大任务slice成小任务，这些任务之间是否独立；&lt;/li&gt;
&lt;li&gt;如果收集，处理小任务执行的结果；&lt;/li&gt;
&lt;li&gt;理解如何真正利用gevent来实现并行，很多情况下，如果是网络I/O，需要打patch的；比说 &lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;这里接上一点，打patch要小心，比如说打了socket的patch，要先知道会不会影响到本应用中其他用了socket的服务，因为打patch是直接替换了当前运行时环境里的socket，所以在当前运行时环境里使用socket的服务都会受影响；&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;5. Gevent In Action&lt;/h2&gt;

&lt;p&gt;因为Gevent多用于I/O密集型并发程序，而网络请求又是很常见的一种I/O请求，所以在大规模网络并发请求的时候，可以使用Gevent。相信python程序员都应该用过 requests 这个包吧，都应该知道 requests 的作者，kennethreitz，一个货真价实的 python界的大牛。他在写了 requests 的同时，还写了一个包：&lt;a href=&quot;https://github.com/kennethreitz/grequests&quot;&gt;grequest ： gevent + requests &lt;/a&gt;，把requests用gevent包了一下，实现异步的网络请求，下次大家要是有网络方面的并发请求，需要用到gevent的话，就不用重复造轮子了，直接用 &lt;a href=&quot;https://github.com/kennethreitz/grequests&quot;&gt;grequests&lt;/a&gt; 就好了。&lt;/p&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.firefoxbug.com/index.php/archives/2750/&quot;&gt;Python Gevent应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.leiqin.info/2012/12/02/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3.html&quot;&gt;进程、线程和协程的理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/&quot;&gt;浅谈coroutine与gevent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://xlambda.com/gevent-tutorial/#&quot;&gt;gevent程序员指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/77240/&quot;&gt;python greenlet背景介绍与实现机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.elias.cn/Python/PyConcurrency?from=Develop.PyConcurrency&quot;&gt;Python几种并发实现方案的性能比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-05-28-python-gevent.md.jpg&quot; alt=&quot;2015-05-28-python-gevent.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-4. Web 高性能开发参考资料</title>
     <link href="/web-high-performance"/>
     <updated>2015-05-02T00:00:00+08:00</updated>
     <id>/web-high-performance</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;0. 写在前面&lt;/h2&gt;

&lt;p&gt;　　工作一年多了，发现自己还是没什么长进。学技术这件事儿，还是得靠自己啊，所以我准备以专题的形式来提升自己的能力。这篇我总结了一些搜集的比较好的讲web高性能开发的文章和书籍，都是我自己看过的。以后再也不怕别人问到高性能web的经验和知识了，用老话说，就算没吃过猪肉也应该见过猪跑吧，咱就算没经历过高性能web开发实践，也至少了解一些这方面的知识吧。哈哈。&lt;/p&gt;

&lt;h2&gt;1. 模式相关&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2014/09/05/design-pattern-cheatsheet/&quot;&gt;设计模式概览图&lt;/a&gt;  &lt;br/&gt;
　　以图形的形式简单阐述了各种模式的概念，图画得不错，表述也清晰，可以有空翻开看看；
&lt;img src=&quot;../images/design_pattern.png&quot; alt=&quot;design_pattern.png&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/08/software-architecture-patterns/&quot;&gt;软件架构模式&lt;/a&gt; &lt;br/&gt;
　　是作者对这本书的&lt;a href=&quot;http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf&quot;&gt;Software Architecture Patterns&lt;/a&gt; 笔记和总结，写得很详细，可以时常参考，提升架构方面的基础和概念，同时，有时间也推荐读读原书，原书PDF链接在后面。 &lt;br/&gt;
　　这里面提的架构有：分层架构，事件驱动架构，微内核架构，微服务架构，基于空间的架构。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/10/microservice-architecture-a-quick-guide/&quot;&gt;微服务架构快速指南&lt;/a&gt; &lt;br/&gt;
　　不常听说为服务架构，简单的理解，就是介于monolithic和SOA模式之间的一个架构模式，比monolithic灵活，轻便，比SOA有更强的组织性。不必过于在乎三者之间的差别，根据实际情况选择合适自己项目的架构模式。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/24/microservice-design-patterns/&quot;&gt;微服务架构的设计模式&lt;/a&gt; &lt;br/&gt;
　　是&lt;strong&gt;微服务架构快速指南&lt;/strong&gt;的细节篇，里面介绍了一些常用的微服务架构的设计模式，在设计项目架构的时候，如果没有什么思路，这篇文章是很好的参考资料。简单的说，里面提到了常用的微服务设计模式：聚合器，代理，链式服务，分支，数据共享，异步消息。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.admin10000.com/document/5980.html&quot;&gt;大型网站系统架构的演化&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5981.html&quot;&gt;大型网站的灵魂——性能&lt;/a&gt;&lt;br/&gt;
　　非常好的介绍大型网站架构变化的文章，这个网站有一个专门讲大型网站性能的文章系列，都非常值得学习。我把这个系列也列在下面了，写得很细，算是最值得参考和学习的文章了。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5880.html&quot;&gt;关于大型网站技术演进的思考（一）--存储的瓶颈（1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5881.html&quot;&gt;关于大型网站技术演进的思考（二）--存储的瓶颈（2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5882.html&quot;&gt;关于大型网站技术演进的思考（三）--存储的瓶颈（3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5909.html&quot;&gt;关于大型网站技术演进的思考（四）--存储的瓶颈（4）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5910.html&quot;&gt;关于大型网站技术演进的思考（五）--存储的瓶颈（5）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5911.html&quot;&gt;关于大型网站技术演进的思考（六）--存储的瓶颈（6）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5951.html&quot;&gt;关于大型网站技术演进的思考（七）--存储的瓶颈（7）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5952.html&quot;&gt;关于大型网站技术演进的思考（八）--存储的瓶颈终篇（8）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5966.html&quot;&gt;关于大型网站技术演进的思考（九）--网站静态化处理--总述（1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5967.html&quot;&gt;关于大型网站技术演进的思考（十）--网站静态化处理—动静整合方案（2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/5968.html&quot;&gt;关于大型网站技术演进的思考（十一）--网站静态化处理—动静分离策略（3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6020.html&quot;&gt;关于大型网站技术演进的思考（十二）--网站静态化处理—缓存（4）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6021.html&quot;&gt;关于大型网站技术演进的思考（十三）--网站静态化处理—CSI（5）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6022.html&quot;&gt;关于大型网站技术演进的思考（十四）--网站静态化处理—前后端分离—上（6）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6023.html&quot;&gt;关于大型网站技术演进的思考（十五）--网站静态化处理—前后端分离—中（7）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6024.html&quot;&gt;关于大型网站技术演进的思考（十六）--网站静态化处理—前后端分离—下（8）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6025.html&quot;&gt;关于大型网站技术演进的思考（十七）--网站静态化处理—满足静态化的前后端分离（9）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6026.html&quot;&gt;关于大型网站技术演进的思考（十八）--网站静态化处理—反向代理（10）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6027.html&quot;&gt;关于大型网站技术演进的思考（十九）--网站静态化处理—web前端优化—上（11）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6028.html&quot;&gt;关于大型网站技术演进的思考（二十）--网站静态化处理—web前端优化—中（12）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.admin10000.com/document/6029.html&quot;&gt;关于大型网站技术演进的思考（二十一）--网站静态化处理—web前端优化—下【终篇】（13）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. 高性能网站相关&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2015/04/20/how-to-build-a-scalable-website/&quot;&gt;如何构建高扩展性网站&lt;/a&gt; &lt;br/&gt;
　　是一本小册子&lt;a href=&quot;http://book.douban.com/subject/10756899/&quot;&gt;《高扩展性网站的50条原则》&lt;/a&gt;的读书笔记。这本书不错，值得一看，在设计、改进项目架构时都可以拿来翻翻，不错的小册子。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://colobu.com/2014/09/26/best-free-website-speed-testing-tools/&quot;&gt;最佳免费的网站性能测试工具&lt;/a&gt; &lt;br/&gt;
　　这篇博文是我认为最有实际意义的一篇博文之一了，里面提到了12个免费的网站性能测试工具，比如大名鼎鼎的google pagespeed insights。我的建议是，在进行任何优化前，都先简单地用这些工具在线测试一下。不要盲目地进行后台的优化，更不要盲目的去设计一些高端的算法来做所谓的加速。比如说，一个请求后台返回的时间控制在100ms之内，但发起这个请求的js脚本被写在一个很大的js文件里面，导致下载这个js文件需要数百毫秒，那此时应该怎么优化呢？别跟我说你会让你的后台工程师去找一什么高大上的算法来解决这个问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.blogjava.net/BearRui/archive/2010/04/26/web_performance.html&quot;&gt;web高性能开发系列随笔&lt;/a&gt; &lt;br/&gt;
　　算是一篇比较简单，但是完善的web性能优化博客了，里面涉及到前后端的各种优化方法，虽然我只是后台开发，但看这种文章能够让开发人员从全局的视角去设计和优化你的web系统。就跟上一篇 &lt;a href=&quot;http://colobu.com/2014/09/26/best-free-website-speed-testing-tools/&quot;&gt;最佳免费的网站性能测试工具&lt;/a&gt; 文章一样，在优化前，先全局、完整地了解你的web系统，再来说具体怎么优化吧。如果你在优化前，不知道怎么对web系统“全局”地了解，这篇博客可以入门用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. 参考书籍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.oreilly.com/programming/free/files/software-architecture-patterns.pdf&quot;&gt;Software Architecture Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/10756899/&quot;&gt;高扩展性网站的50条原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://book.douban.com/subject/3924175/&quot;&gt;构建高性能Web站点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-05-02-web-high-performance.md.jpg&quot; alt=&quot;2015-05-02-web-high-performance.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Python 技巧总结</title>
     <link href="/python-materials"/>
     <updated>2015-03-17T00:00:00+08:00</updated>
     <id>/python-materials</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 枚举 - enumerate 可以有参数哦&lt;/h2&gt;

&lt;p&gt;之前我们这样操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i = 0
for item in iterable:
    print i, item
    i += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们这样操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i, item in enumerate(iterable):
    print i, item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;enumerate函数还可以接收第二个参数。就像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; list(enumerate(&#39;abc&#39;)) 
[(0, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;c&#39;)] 

&amp;gt;&amp;gt;&amp;gt; list(enumerate(&#39;abc&#39;, 1)) 
[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 字典/集合 解析&lt;/h2&gt;

&lt;p&gt;你也许知道如何进行列表解析，但是可能不知道字典/集合解析。它们简单易用且高效。就像下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my_dict = {i: i * i for i in xrange(100)} 
my_set = {i * 15 for i in xrange(100)}

# There is only a difference of &#39;:&#39; in both

# 两者的区别在于字典推导中有冒号
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 强制浮点除法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;from __future__ import division 
result = 1/2
# print(result)
# 0.5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 对Python表达式求值&lt;/h2&gt;

&lt;p&gt;我们都知道eval函数，但是我们知道literal_eval函数么？也许很多人都不知道吧。可以用这种操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ast 
my_list = ast.literal_eval(expr)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来代替以下这种操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expr = &quot;[1, 2, 3]&quot;
my_list = eval(expr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我相信对于大多数人来说这种形式是第一次看见，但是实际上这个在Python中已经存在很长时间了。&lt;/p&gt;

&lt;h2&gt;5. 字符串/数列 逆序&lt;/h2&gt;

&lt;p&gt;你可以用以下方法快速逆序排列数列：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1,2,3,4]
&amp;gt;&amp;gt;&amp;gt; a[::-1]
[4, 3, 2, 1]
 
# This creates a new reversed list. 
# If you want to reverse a list in place you can do:
 
a.reverse()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这总方式也同样适用于字符串的逆序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; foo = &quot;yasoob&quot;
&amp;gt;&amp;gt;&amp;gt; foo[::-1]
&#39;boosay&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;6. 三元运算&lt;/h2&gt;

&lt;p&gt;三元运算是if-else 语句的快捷操作，也被称为条件运算。这里有几个例子可以供你参考，它们可以让你的代码更加紧凑，更加美观。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[on_true] if [expression] else [on_false]
x, y = 50, 25
small = x if x &amp;lt; y else y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;7. Python里面如何拷贝一个对象&lt;/h2&gt;

&lt;p&gt;标准库中的copy模块提供了两个方法来实现拷贝.一个方法是copy,它返回和参数包含内容一样的对象.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy
new_list = copy.copy(existing_list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有些时候,你希望对象中的属性也被复制,可以使用deepcopy方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy
new_list_of_dicts = copy.deepcopy(existing_list_of_dicts)

copy(x)
Shallow copy operation on arbitrary Python objects.
 
deepcopy(x, memo=None, _nil=[])
Deep copy operation on arbitrary Python objects.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;8. python中如何判断对象相等&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;首先是C#中字符串的==和equal方法。

“==” :
对于内置值类型而言， == 判断两个内存值是否相等。
对于用户自定义的值类型而言(Struct)， == 需要重载，否则不能使用。
对于引用类型而言，默认是同一引用才返回true，但是系统重载了很多引用类型的 == （比如下文提到的string），所以c#中引用类型的比较并不建议使用 ==。

“equals” :
对于值类型而言， 内存相等才返回true。
对于引用类型而言，指向同一个引用才算相等。
但是比较特殊的是字符串String,是一个特殊的引用型类型，在C#语言中，重载了string的equals()方法，使string对象用起来就像是值类型一样。

python中的 ==

python中的对象包含三要素:id, type, value
id 用来标识唯一一个对象，type标识对象的类型，value用来设置对象的值。
is 判断是否是一个对象，使用id来判断的。
== 是判断a对象的值是否是b对象的值，默认调用它的__eq__方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;9. 命名技巧&lt;/h2&gt;

&lt;p&gt;今天阅读代码，发现一个不错的函数命名方式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def request(_argv):  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是把所有的参数前面都加上_下划线，这样你在函数体中，一眼就可以看出那些是局部变量，那些是作为参数传入的，类似把全局变量前面加上g。&lt;/p&gt;

&lt;h2&gt;10. 开发者工具集锦&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;pydoc： 模块可以根据源代码中的docstrings为任何可导入模块生成格式良好的文档。&lt;/li&gt;
&lt;li&gt;doctest模块：该模块可以从源代码或独立文件的例子中抽取出测试用例。&lt;/li&gt;
&lt;li&gt;unittest模块：该模块是一个全功能的自动化测试框架，该框架提供了对测试准备(test fixtures), 预定义测试集(predefined test suite)以及测试发现(test discovery)的支持。&lt;/li&gt;
&lt;li&gt;trace：模块可以监控Python执行程序的方式，同时生成一个报表来显示程序的每一行执行的次数。这些信息可以用来发现未被自动化测试集所覆盖的程序执行路径，也可以用来研究程序调用图，进而发现模块之间的依赖关系。编写并执行测试可以发现绝大多数程序中的问题，Python使得debug工作变得更加简单，这是因为在大部分情况下，Python都能够将未被处理的错误打印到控制台中，我们称这些错误信息为traceback。如果程序不是在文本控制台中运行的，traceback也能够将错误信息输出到日志文件或是消息对话框中。当标准的traceback无法提供足够的信息时，可以使用cgitb 模块来查看各级栈和源代码上下文中的详细信息，比如局部变量。cgitb模块还能够将这些跟踪信息以HTML的形式输出，用来报告web应用中的错误。&lt;/li&gt;
&lt;li&gt;pdb：该模块可以显示出程序在错误产生时的执行路径，同时可以动态地调整对象和代码进行调试。&lt;/li&gt;
&lt;li&gt;profile, timeit: 开发者可以使用profile以及timit模块来测试程序的速度，找出程序中到底是哪里很慢，进而对这部分代码独立出来进行调优的工作。&lt;/li&gt;
&lt;li&gt;compileall: Python程序是通过解释器执行的，解释器的输入是原有程序的字节码编译版本。这个字节码编译版本可以在程序执行时动态地生成，也可以在程序打包的时候就生成。compileall模块可以处理程序打包的事宜，它暴露出了打包相关的接口，该接口能够被安装程序和打包工具用来生成包含模块字节码的文件。同时，在开发环境中，compileall模块也可以用来验证源文件是否包含了语法错误。&lt;/li&gt;
&lt;li&gt;YAPF：Google开源的Python代码格式化工具。&lt;/li&gt;
&lt;li&gt;iPDB: iPDB是一个极好的工具，我已经用它查出了很多匪夷所思的bug。pip install ipdb 安装该工具，然后在你的代码中import ipdb; ipdb.set_trace()，然后你会在你的程序运行时，获得一个很好的交互式提示。它每次执行程序的一行并且检查变量。&lt;/li&gt;
&lt;li&gt;pycallgraph: 在一些场合，我使用pycallgraph来追踪性能问题。它可以创建函数调用时间和次数的图表。&lt;/li&gt;
&lt;li&gt;objgraph: objgraph对于查找内存泄露非常有用。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;../images/pycallgraph.jpg&quot; alt=&quot;pycallgraph.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;11. Python代码微优化之加快查找&lt;/h2&gt;

&lt;p&gt;collections.OrderedDict类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
    if key not in self:
        root = self.__root
        last = root[0]
        last[1] = root[0] = self.__map[key] = [last, root, key]
    return dict_setitem(self, key, value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意最后一个参数：dict_setitem=dict.&lt;strong&gt;setitem&lt;/strong&gt;。如果你仔细想就会感觉有道理。将值关联到键上，你只需要给&lt;strong&gt;setitem&lt;/strong&gt;传递三个参数：要设置的键，与键关联的值，传递给内建dict类的&lt;strong&gt;setitem&lt;/strong&gt;类方法。等会，好吧，也许最后一个参数没什么意义。
最后一个参数其实是将一个函数绑定到局部作用域中的一个函数上。具体是通过将dict.&lt;strong&gt;setitem&lt;/strong&gt;赋值为参数的默认值。这里还有另一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def not_list_or_dict(value):
  return not (isinstance(value, dict) or isinstance(value, list))
 
def not_list_or_dict(value, _isinstance=isinstance, _dict=dict, _list=list):
  return not (_isinstance(value, _dict) or _isinstance(value, _list))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们做同样的事情，把本来将会在内建命名空间中的对象绑定到局部作用域中去。因此，python将会使用LOCAL_FAST而不是LOAD_GLOBAL（全局查找）。那么这到底有多快呢？我们做个简单的测试：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -m timeit -s &#39;def not_list_or_dict(value): return not (isinstance(value, dict) or isinstance(value, list))&#39; &#39;not_list_or_dict(50)&#39;
1000000 loops, best of 3: 0.48 usec per loop
$ python -m timeit -s &#39;def not_list_or_dict(value, _isinstance=isinstance, _dict=dict, _list=list): return not (_isinstance(value, _dict) or _isinstance(value, _list))&#39; &#39;not_list_or_dict(50)&#39;
1000000 loops, best of 3: 0.423 usec per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换句话说，大概有11.9%的提升 [2]。比我在文章开始处承诺的5%还多！&lt;/p&gt;

&lt;h2&gt;12. 包管理&lt;/h2&gt;

&lt;p&gt;Python世界最棒的地方之一，就是大量的第三方程序包。同样，管理这些包也非常容易。按照惯例，会在 requirements.txt 文件中列出项目所需要的包。每个包占一行，通常还包含版本号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pelican==3.3
Markdown
pelican-extended-sitemap==1.0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;13. Python函数参数默认值的陷阱和原理深究&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Python 2.7.9 (default, Dec 19 2014, 06:05:48)
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.56)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; def generate_new_list_with(my_list=[], element=None):
...     my_list.append(element)
...     return my_list
...
&amp;gt;&amp;gt;&amp;gt; list_1 = generate_new_list_with(element=1)
&amp;gt;&amp;gt;&amp;gt; list_1
[1]
&amp;gt;&amp;gt;&amp;gt; list_2 = generate_new_list_with(element=2)
&amp;gt;&amp;gt;&amp;gt; list_2
[1, 2]
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见代码运行结果并不和我们预期的一样。list_2在函数的第二次调用时并没有得到一个新的list并填入2，而是在第一次调用结果的基础上append了一个2。为什么会发生这样在其他编程语言中简直就是设计bug一样的问题呢？ &lt;br/&gt;
可见如果参数默认值是在函数编译compile阶段就已经被确定。之后所有的函数调用时，如果参数不显示的给予赋值，那么所谓的参数默认值不过是一个指向那个在compile阶段就已经存在的对象的指针。如果调用函数时，没有显示指定传入参数值得话。那么所有这种情况下的该参数都会作为编译时创建的那个对象的一种别名存在。如果参数的默认值是一个不可变(Imuttable)数值，那么在函数体内如果修改了该参数，那么参数就会重新指向另一个新的不可变值。而如果参数默认值是和本文最开始的举例一样，是一个可变对象(Muttable)，那么情况就比较糟糕了。所有函数体内对于该参数的修改，实际上都是对compile阶段就已经确定的那个对象的修改。&lt;/p&gt;

&lt;h2&gt;14. 单下划线（_）&lt;/h2&gt;

&lt;p&gt;1、在解释器中：在这种情况下，“_”代表交互式解释器会话中上一条执行的语句的结果。这种用法首先被标准CPython解释器采用，然后其他类型的解释器也先后采用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; _ Traceback (most recent call last): 
File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt; 
NameError: name &#39;_&#39; is not defined 
&amp;gt;&amp;gt;&amp;gt; 42
&amp;gt;&amp;gt;&amp;gt; _ 
42
&amp;gt;&amp;gt;&amp;gt; &#39;alright!&#39; if _ else &#39;:(&#39;
&#39;alright!&#39;
&amp;gt;&amp;gt;&amp;gt; _ 
&#39;alright!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、作为一个名称：这与上面一点稍微有些联系，此时“&lt;em&gt;”作为临时性的名称使用。这样，当其他人阅读你的代码时将会知道，你分配了一个特定的名称，但是并不会在后面再次用到该名称。例如，下面的例子中，你可能对循环计数中的实际值并不感兴趣，此时就可以使用“&lt;/em&gt;”。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = 42
for _ in range(n): 
    do_something()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3、国际化：也许你也曾看到”_“会被作为一个函数来使用。这种情况下，它通常用于实现国际化和本地化字符串之间翻译查找的函数名称，这似乎源自并遵循相应的C约定。例如，在Django文档“转换”章节中，你将能看到如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from django.utils.translation import ugettext as _ 
from django.http import HttpResponse 
def my_view(request): 
    output = _(&quot;Welcome to my site.&quot;) 
    return HttpResponse(output)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现，场景二和场景三中的使用方法可能会相互冲突，所以我们需要避免在使用“&lt;em&gt;”作为国际化查找转换功能的代码块中同时使用“&lt;/em&gt;”作为临时名称。&lt;/p&gt;

&lt;h2&gt;15. 名称前的单下划线（如：_shahriar）&lt;/h2&gt;

&lt;p&gt;程序员使用名称前的单下划线，用于指定该名称属性为“私有”。这有点类似于惯例，为了使其他人（或你自己）使用这些代码时将会知道以“_”开头的名称只供内部使用。正如Python文档中所述：&lt;/p&gt;

&lt;p&gt;以下划线 &lt;em&gt;_ 为前缀的名称（如&lt;/em&gt;pam）应该被视为API中非公开的部分（不管是函数、方法还是数据成员）。此时，应该将它们看作是一种实现细节，在修改它们时无需对外部通知。&lt;/p&gt;

&lt;p&gt;正如上面所说，这确实类似一种惯例，因为它对解释器来说确实有一定的意义，如果你写了代码 &lt;code&gt;from &amp;lt;模块/包名&amp;gt; import *&lt;/code&gt;，那么以 _ 开头的名称都不会被导入，除非模块或包中的 &lt;code&gt;__all__&lt;/code&gt; 列表显式地包含了它们。了解更多请查看 &lt;code&gt;Importing * in Python&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;16. 名称前的双下划线（如：__shahriar）&lt;/h2&gt;

&lt;p&gt;名称（具体为一个方法名）前双下划线 _ 的用法并不是一种惯例，对解释器来说它有特定的意义。Python中的这种用法是为了避免与子类定义的名称冲突。Python文档指出，&lt;strong&gt;spam 这种形式（至少两个前导下划线，最多一个后续下划线）的任何标识符将会被 正如所预料的，“_internal_use”并未改变，而“&lt;/strong&gt;method_name”却被变成了“_ClassName&lt;strong&gt;method_name”。此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法“&lt;/strong&gt;method_name”。spam 这种形式原文取代，在这里 classname 是去掉前导下划线的当前类名。例如下面的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class A(object): 
... def _internal_use(self): 
... pass
... def __method_name(self): 
... pass
... 
&amp;gt;&amp;gt;&amp;gt; dir(A()) 
[&#39;_A__method_name&#39;, ..., &#39;_internal_use&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正如所预料的，“&lt;em&gt;internal_use”并未改变，而“__method_name”却被变成了“&lt;/em&gt;ClassName&lt;strong&gt;method_name”。此时，如果你创建A的一个子类B，那么你将不能轻易地覆写A中的方法“&lt;/strong&gt;method_name”。&lt;/p&gt;

&lt;h2&gt;17. 名称前后的双下划线（如：&lt;strong&gt;init&lt;/strong&gt;）&lt;/h2&gt;

&lt;p&gt;这种用法表示Python中特殊的方法名。其实，这只是一种惯例，对Python系统来说，这将确保不会与用户自定义的名称冲突。通常，你将会覆写这些方法，并在里面实现你所需要的功能，以便Python调用它们。例如，当定义一个类时，你经常会覆写“&lt;strong&gt;init&lt;/strong&gt;”方法。&lt;/p&gt;

&lt;p&gt;虽然你也可以编写自己的特殊方法名，但不要这样做。&lt;/p&gt;

&lt;h2&gt;17. 隐藏特性 1，函数unpack&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;def foo(x, y):
    print x, y

alist = [1, 2]
adict = {&#39;x&#39;: 1, &#39;y&#39;: 2}

foo(*alist)  # 1, 2
foo(**adict)  # 1, 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;18. 隐藏特性 2， 链式比较操作符&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = 3
&amp;gt;&amp;gt;&amp;gt; 1 &amp;lt; x &amp;lt; 5
True
&amp;gt;&amp;gt;&amp;gt; 4 &amp;gt; x &amp;gt;=3
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;19. 隐藏特性 3，函数的默认参数&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def foo(x=[]):
...     x.append(1)
...     print x
...
&amp;gt;&amp;gt;&amp;gt; foo()
[1]
&amp;gt;&amp;gt;&amp;gt; foo()
[1, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更安全的做法是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def foo(x=None):
...     if x is None:
...         x = []
...     x.append(1)
...     print x
...
&amp;gt;&amp;gt;&amp;gt; foo()
[1]
&amp;gt;&amp;gt;&amp;gt; foo()
[1]
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;20. 隐藏特性 4，字典的get方法&lt;/h2&gt;

&lt;h2&gt;21. 隐藏特性 5，带关键字的格式化&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print &quot;Hello %(name)s !&quot; % {&#39;name&#39;: &#39;James&#39;}
Hello James !
&amp;gt;&amp;gt;&amp;gt; print &quot;I am years %(age)i years old&quot; % {&#39;age&#39;: 18}
I am years 18 years old
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新些的格式化:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print &quot;Hello {name} !&quot;.format(name=&quot;James&quot;)
Hello James !
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;22. 隐藏特性 6，切片操作的步长参数&lt;/h2&gt;

&lt;p&gt;可以用步长 -1 来反转链表：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5]
&amp;gt;&amp;gt;&amp;gt; a[::2]
[1, 3, 5]
&amp;gt;&amp;gt;&amp;gt; a[::-1]
[5, 4, 3, 2, 1]
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;23. 隐藏特性 7，嵌套列表推导式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;[(i, j) for i in range(3) for j in range(i)]
[(1, 0), (2, 0), (2, 1)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列表推导构造permutation：&lt;br/&gt;
可以用 itertools.permutations 来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;In[47]: a = &#39;abcd&#39;

In[48]: [i+j+k for i in a for j in a.replace(i,&#39;&#39;) for k in a.replace(i,&#39;&#39;).replace(j,&#39;&#39;)]
Out[48]: 
[&#39;abc&#39;,
 &#39;abd&#39;,
 &#39;acb&#39;,
 &#39;acd&#39;,
 &#39;adb&#39;,
 &#39;adc&#39;,
 &#39;bac&#39;,
 &#39;bad&#39;,
 &#39;bca&#39;,
 &#39;bcd&#39;,
 &#39;bda&#39;,
 &#39;bdc&#39;,
 &#39;cab&#39;,
 &#39;cad&#39;,
 &#39;cba&#39;,
 &#39;cbd&#39;,
 &#39;cda&#39;,
 &#39;cdb&#39;,
 &#39;dab&#39;,
 &#39;dac&#39;,
 &#39;dba&#39;,
 &#39;dbc&#39;,
 &#39;dca&#39;,
 &#39;dcb&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;24. 隐藏特性 8，print 重定向输出到文件&lt;/h2&gt;

&lt;p&gt;注意打开的模式: &quot;w+&quot; 而不能 &quot;w&quot; , 当然 &quot;a&quot; 是可以的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print &amp;gt;&amp;gt; open(&quot;somefile&quot;, &quot;w+&quot;), &quot;Hello World&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;25. 隐藏特性 9， Python3中的元组unpack&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a, b, *rest = range(10)
&amp;gt;&amp;gt;&amp;gt; a
0
&amp;gt;&amp;gt;&amp;gt; b
1
&amp;gt;&amp;gt;&amp;gt; rest
[2, 3, 4, 5, 6, 7, 8, 9]
&amp;gt;&amp;gt;&amp;gt;

&amp;gt;&amp;gt;&amp;gt; first, second, *rest, last = range(10)
&amp;gt;&amp;gt;&amp;gt; first
0
&amp;gt;&amp;gt;&amp;gt; second
1
&amp;gt;&amp;gt;&amp;gt; last
9
&amp;gt;&amp;gt;&amp;gt; rest
[2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;26. 隐藏特性 10，pow的第三个参数&lt;/h2&gt;

&lt;p&gt;其实第三个参数是来求模的: pow(x, y, z) == (x ** y) % z，注意，内置的 pow 和 math.pow 并不是一个函数，后者只接受2个参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; pow(4, 2, 2)
0
&amp;gt;&amp;gt;&amp;gt; pow(4, 2, 3)
1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;27. 隐藏特性 11，enumerate还有第二个参数¶&lt;/h2&gt;

&lt;p&gt;enumerate 很赞，可以给我们索引和序列值的对, 但是它还有第二个参数，这个参数用来: 指明索引的起始值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lst = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
&amp;gt;&amp;gt;&amp;gt; list(enumerate(lst, 1))
[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;28. 隐藏特性 12，显式的声明一个集合&lt;/h2&gt;

&lt;p&gt;在Python 2.7 之后可以这么声明一个集合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; {1,2,3}
set([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;29. 隐藏特性 13，用切片来删除序列的某一段&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6, 7]
&amp;gt;&amp;gt;&amp;gt; a[1:4] = []
&amp;gt;&amp;gt;&amp;gt; a
[1, 5, 6, 7]  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然用 del a[1:4] 也是可以的，去除偶数项(偶数索引的):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [0, 1, 2, 3, 4, 5, 6, 7]
&amp;gt;&amp;gt;&amp;gt; del a[::2]
&amp;gt;&amp;gt;&amp;gt; a
[1, 3, 5, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;30. 隐藏特性 14，isinstance可以接收一个元组&lt;/h2&gt;

&lt;p&gt;这个真的鲜为人知, 我们可以用 isinstance(x, (float, int)) 来判断 x 是不是数，也就是那个元组里面是 或 的关系，只要是其中一个的实例就返回 True。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(1, (float, int))
True
&amp;gt;&amp;gt;&amp;gt; isinstance(1.3, (float, int))
True
&amp;gt;&amp;gt;&amp;gt; isinstance(&quot;1.3&quot;, (float, int))
False
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;31. 让关键代码依赖于外部包&lt;/h2&gt;

&lt;p&gt;虽然Python让许多编程任务变得容易，但它可能并不总能为紧急的任务提供最佳性能。你可以为紧急的任务使用C、C++或机器语言编写的外部包，这样可以提高应用程序的性能。这些包都是不能跨平台的，这意味着你需要根据你正在使用的平台，寻找合适的包。简而言之，这个方案放弃了一些应用程序的可移植性，以换取只有在特定主机上直接编程才能获得的程序性能。这里有一些你应该考虑加入到你的“性能兵工厂”的包：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cython&lt;/li&gt;
&lt;li&gt;PyInlne&lt;/li&gt;
&lt;li&gt;PyPy&lt;/li&gt;
&lt;li&gt;Pyrex&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些包以不同的方式提高性能。例如，Pyrex能够扩展Python所能做的事情，例如使用C的数据类型来让内存任务更加有效或直接。PyInIne让你在Python应用程序中直接使用C代码。程序中的内联代码单独编译，但它在利用C语言所能提供的效率的同时，也让所有的代码都在同一个地方。&lt;/p&gt;

&lt;h2&gt;32. 排序时使用键（key）&lt;/h2&gt;

&lt;p&gt;有很多老的Python排序代码，它们在你创建一个自定义的排序时花费你的时间，但在运行时确实能加速执行排序过程。元素排序的最好方法是尽可能使用键（key）和默认的sort()排序方法。例如，考虑下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import operator
somelist = [(1, 5, 8), (6, 2, 4), (9, 7, 5)]
somelist.sort(key=operator.itemgetter(0))
somelist
#Output = [(1, 5, 8), (6, 2, 4), (9, 7, 5)]
somelist.sort(key=operator.itemgetter(1))
somelist
#Output = [(6, 2, 4), (1, 5, 8), (9, 7, 5)]
somelist.sort(key=operator.itemgetter(2))
somelist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个实例中，根据你选择的作为key参数部分的索引，数组进行了排序。类似于利用数字进行排序，这种方法同样适用于利用字符串排序。&lt;/p&gt;

&lt;h2&gt;33. 优化循环&lt;/h2&gt;

&lt;p&gt;每种编程语言都会强调需要优化循环。当使用Python的时候，你可以依靠大量的技巧使得循环运行得更快。然而，开发者经常漏掉的一个方法是：避免在一个循环中使用点操作。例如，考虑下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lowerlist = [&#39;this&#39;, &#39;is&#39;, &#39;lowercase&#39;]
upper = str.upper
upperlist = []
append = upperlist.append
for word in lowerlist:
    append(upper(word))
    print(upperlist)
    #Output = [&#39;THIS&#39;, &#39;IS&#39;, &#39;LOWERCASE&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一次你调用方法str.upper，Python都会求该方法的值。然而，如果你用一个变量代替求得的值，值就变成了已知的，Python就可以更快地执行任务。优化循环的关键，是要减少Python在循环内部执行的工作量，因为Python原生的解释器在那种情况下，真的会减缓执行的速度。&lt;/p&gt;

&lt;p&gt;（注意：优化循环的方法有很多，这只是其中的一个。例如，许多程序员都会说，列表推导是在循环中提高执行速度的最好方式。这里的关键是，优化循环是程序取得更高的执行速度的更好方式之一。）&lt;/p&gt;

&lt;h2&gt;34. 尝试多种编码方法&lt;/h2&gt;

&lt;p&gt;如果每次你创建一个应用程序都是用相同的编码方法，几乎肯定会导致一些你的应用程序比它能够达到的运行效率慢的情况。作为分析过程的一部分，你可以尝试一些实验。例如，在一个字典中管理一些元素，你可以采用安全的方法确定元素是否已经存在并更新，或者你可以直接添加元素，然后作为异常处理该元素不存在情况。考虑第一个编码的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = 16
myDict = {}
for i in range(0, n):
    char = &#39;abcd&#39;[i%4]
    if char not in myDict:
        myDict[char] = 0
        myDict[char] += 1
        print(myDict)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码通常会在myDict开始为空时运行得更快。然而，当mydict通常被数据填充（或者至少大部分被充填）时，另一种方法效果更好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = 16
myDict = {}
for i in range(0, n):
    char = &#39;abcd&#39;[i%4]
    try:
        myDict[char] += 1
    except KeyError:
        myDict[char] = 1
    print(myDict)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两种情况下具有相同的输出：{‘d’: 4, ‘c’: 4, ‘b’: 4, ‘a’: 4}。唯一的不同是这个输出是如何得到的。跳出固定的思维模式，创造新的编码技巧，能够帮助你利用你的应用程序获得更快的结果。&lt;/p&gt;

&lt;h2&gt;35. 使用列表推导式&lt;/h2&gt;

&lt;p&gt;一个列表推导式包含以下几个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个输入序列&lt;/li&gt;
&lt;li&gt;一个表示输入序列成员的变量&lt;/li&gt;
&lt;li&gt;一个可选的断言表达式&lt;/li&gt;
&lt;li&gt;一个将输入序列中满足断言表达式的成员变换成输出列表成员的输出表达式&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = []
 
for number in num:
    if number &amp;gt; 0:
        filtered_and_squared.append(number ** 2)
print filtered_and_squared
 
# [1, 16, 100, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而如果使用filter、lambda和map函数，则能够将代码大大简化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = map(lambda x: x ** 2, filter(lambda x: x &amp;gt; 0, num))
print filtered_and_squared
 
# [1, 16, 100, 4, 9]

## 更简化的一种写法    
num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = [ x**2 for x in num if x &amp;gt; 0]
print filtered_and_squared
 
# [1, 16, 100, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;../images/comprehension.jpg&quot; alt=&quot;comprehension.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;列表推导也可能会有一些负面效应，那就是整个列表必须一次性加载于内存之中，这对上面举的例子而言不是问题，甚至扩大若干倍之后也都不是问题。但是总会达到极限，内存总会被用完。&lt;/p&gt;

&lt;p&gt;针对上面的问题，生成器(Generator)能够很好的解决。生成器表达式不会一次将整个列表加载到内存之中，而是生成一个生成器对象(Generator objector)，所以一次只加载一个列表元素。&lt;/p&gt;

&lt;p&gt;生成器表达式同列表推导式有着几乎相同的语法结构，区别在于生成器表达式是被圆括号包围，而不是方括号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;num = [1, 4, -5, 10, -7, 2, 3, -1]
filtered_and_squared = ( x**2 for x in num if x &amp;gt; 0 )
print filtered_and_squared
 
# &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x00583E18&amp;gt;
 
for item in filtered_and_squared:
    print item
 
# 1, 16, 100 4,9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这比列表推导效率稍微提高一些，让我们再一次改造一下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;num = [1, 4, -5, 10, -7, 2, 3, -1]
 
def square_generator(optional_parameter):
    return (x ** 2 for x in num if x &amp;gt; optional_parameter)
 
print square_generator(0)
# &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x004E6418&amp;gt;
 
# Option I
for k in square_generator(0):
    print k
# 1, 16, 100, 4, 9
 
# Option II
g = list(square_generator(0))
print g
# [1, 16, 100, 4, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除非特殊的原因，应该经常在代码中使用生成器表达式。但除非是面对非常大的列表，否则是不会看出明显区别的。
再来看一个通过两阶列表推导式遍历目录的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os
def tree(top):
    for path, names, fnames in os.walk(top):
        for fname in fnames:
            yield os.path.join(path, fname)
 
for name in tree(&#39;C:\Users\XXX\Downloads\Test&#39;):
    print name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;36. 装饰器(Decorators)&lt;/h2&gt;

&lt;p&gt;装饰器为我们提供了一个增加已有函数或类的功能的有效方法。听起来是不是很像Java中的面向切面编程(Aspect-Oriented Programming)概念？两者都很简单，并且装饰器有着更为强大的功能。举个例子，假定你希望在一个函数的入口和退出点做一些特别的操作(比如一些安全、追踪以及锁定等操作)就可以使用装饰器。&lt;/p&gt;

&lt;p&gt;装饰器是一个包装了另一个函数的特殊函数：主函数被调用，并且其返回值将会被传给装饰器，接下来装饰器将返回一个包装了主函数的替代函数，程序的其他部分看到的将是这个包装函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time
from functools import wraps
 
def timethis(func):
    &#39;&#39;&#39;
    Decorator that reports the execution time.
    &#39;&#39;&#39;
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(func.__name__, end-start)
        return result
    return wrapper
 
@timethis
def countdown(n):
    while n &amp;gt; 0:
        n -= 1
 
countdown(100000)
 
# (&#39;countdown&#39;, 0.006999969482421875)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;37. 上下文管理库(ContextLib)&lt;/h2&gt;

&lt;p&gt;contextlib模块包含了与上下文管理器和with声明相关的工具。通常如果你想写一个上下文管理器，则你需要定义一个类包含&lt;strong&gt;enter&lt;/strong&gt;方法以及&lt;strong&gt;exit&lt;/strong&gt;方法，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time
class demo:
    def __init__(self, label):
        self.label = label
 
    def __enter__(self):
        self.start = time.time()
 
    def __exit__(self, exc_ty, exc_val, exc_tb):
        end = time.time()
        print(&#39;{}: {}&#39;.format(self.label, end - self.start))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整的例子在此：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time
 
class demo:
    def __init__(self, label):
        self.label = label
 
    def __enter__(self):
        self.start = time.time()
 
    def __exit__(self, exc_ty, exc_val, exc_tb):
        end = time.time()
        print(&#39;{}: {}&#39;.format(self.label, end - self.start))
 
with demo(&#39;counting&#39;):
    n = 10000000
    while n &amp;gt; 0:
        n -= 1
 
# counting: 1.36000013351
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上下文管理器被with声明所激活，这个API涉及到两个方法。
1. &lt;strong&gt;enter&lt;/strong&gt;方法，当执行流进入with代码块时，&lt;strong&gt;enter&lt;/strong&gt;方法将执行。并且它将返回一个可供上下文使用的对象。
2. 当执行流离开with代码块时，&lt;strong&gt;exit&lt;/strong&gt;方法被调用，它将清理被使用的资源。&lt;/p&gt;

&lt;p&gt;利用@contextmanager装饰器改写上面那个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from contextlib import contextmanager
import time
 
@contextmanager
def demo(label):
    start = time.time()
    try:
        yield
    finally:
        end = time.time()
        print(&#39;{}: {}&#39;.format(label, end - start))
 
with demo(&#39;counting&#39;):
    n = 10000000
    while n &amp;gt; 0:
        n -= 1
 
# counting: 1.32399988174
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看上面这个例子，函数中yield之前的所有代码都类似于上下文管理器中&lt;strong&gt;enter&lt;/strong&gt;方法的内容。而yield之后的所有代码都如&lt;strong&gt;exit&lt;/strong&gt;方法的内容。如果执行过程中发生了异常，则会在yield语句触发。&lt;/p&gt;

&lt;h2&gt;38. 描述器(Descriptors)&lt;/h2&gt;

&lt;p&gt;描述器决定了对象属性是如何被访问的。描述器的作用是定制当你想引用一个属性时所发生的操作。&lt;/p&gt;

&lt;p&gt;构建描述器的方法是至少定义以下三个方法中的一个。需要注意，下文中的instance是包含被访问属性的对象实例，而owner则是被描述器修辞的类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;get&lt;/strong&gt;(self, instance, owner) – 这个方法是当属性被通过(value = obj.attr)的方式获取时调用，这个方法的返回值将被赋给请求此属性值的代码部分。
&lt;strong&gt;set&lt;/strong&gt;(self, instance, value) – 这个方法是当希望设置属性的值(obj.attr = ‘value’)时被调用，该方法不会返回任何值。
&lt;strong&gt;delete&lt;/strong&gt;(self, instance) – 当从一个对象中删除一个属性时(del obj.attr)，调用此方法。
译者注：对于instance和owner的理解，考虑以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Celsius(object):
    def __init__(self, value=0.0):
        self.value = float(value)
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, value):
        self.value = float(value)
 
class Temperature(object):
    celsius = Celsius()
 
temp=Temperature()
temp.celsius #calls Celsius.__get__
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;39. Zipping and unzipping lists and iterables&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&amp;gt;&amp;gt;&amp;gt; z = zip(a, b)
&amp;gt;&amp;gt;&amp;gt; z
[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]
&amp;gt;&amp;gt;&amp;gt; zip(*z)
[(1, 2, 3), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;40. Grouping adjacent list items using zip&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; # Using iterators
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*([iter(a)] * k))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]


&amp;gt;&amp;gt;&amp;gt; # Using slices
&amp;gt;&amp;gt;&amp;gt; from itertools import islice
&amp;gt;&amp;gt;&amp;gt; group_adjacent = lambda a, k: zip(*(islice(a, i, None, k) for i in range(k)))
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 3)
[(1, 2, 3), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 2)
[(1, 2), (3, 4), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; group_adjacent(a, 1)
[(1,), (2,), (3,), (4,), (5,), (6,)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;41. Sliding windows (n-grams) using zip and iterators&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from itertools import islice
&amp;gt;&amp;gt;&amp;gt; def n_grams(a, n):
...     z = (islice(a, i, None) for i in range(n))
...     return zip(*z)
...
&amp;gt;&amp;gt;&amp;gt; a = [1, 2, 3, 4, 5, 6]
&amp;gt;&amp;gt;&amp;gt; n_grams(a, 3)
[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]
&amp;gt;&amp;gt;&amp;gt; n_grams(a, 2)
[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]
&amp;gt;&amp;gt;&amp;gt; n_grams(a, 4)
[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;42. Inverting a dictionary using zip&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}
&amp;gt;&amp;gt;&amp;gt; m.items()
[(&#39;a&#39;, 1), (&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]
&amp;gt;&amp;gt;&amp;gt; zip(m.values(), m.keys())
[(1, &#39;a&#39;), (3, &#39;c&#39;), (2, &#39;b&#39;), (4, &#39;d&#39;)]
&amp;gt;&amp;gt;&amp;gt; mi = dict(zip(m.values(), m.keys()))
&amp;gt;&amp;gt;&amp;gt; mi
{1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;43. Flattening lists&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = [[1, 2], [3, 4], [5, 6]]
&amp;gt;&amp;gt;&amp;gt; list(itertools.chain.from_iterable(a))
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; sum(a, [])
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; [x for l in a for x in l]
[1, 2, 3, 4, 5, 6]

&amp;gt;&amp;gt;&amp;gt; a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; [x for l1 in a for l2 in l1 for x in l2]
[1, 2, 3, 4, 5, 6, 7, 8]

&amp;gt;&amp;gt;&amp;gt; a = [1, 2, [3, 4], [[5, 6], [7, 8]]]
&amp;gt;&amp;gt;&amp;gt; flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]
&amp;gt;&amp;gt;&amp;gt; flatten(a)
[1, 2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;44. Dictionary comprehensions&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; m = {x: x ** 2 for x in range(5)}
&amp;gt;&amp;gt;&amp;gt; m
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

&amp;gt;&amp;gt;&amp;gt; m = {x: &#39;A&#39; + str(x) for x in range(10)}
&amp;gt;&amp;gt;&amp;gt; m
{0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;45. 常犯错误，滥用表达式作为函数参数默认值&lt;/h2&gt;

&lt;p&gt;Python允许开发者指定一个默认值给函数参数，虽然这是该语言的一个特征，但当参数可变时，很容易导致混乱，例如，下面这段函数定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def foo(bar=[]):        # bar is optional and defaults to [] if not specified
...    bar.append(&quot;baz&quot;)    # but this line could be problematic, as we&#39;ll see...
...    return bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面这段代码里，一旦重复调用foo()函数（没有指定一个bar参数），那么将一直返回&#39;bar&#39;，因为没有指定参数，那么foo()每次被调用的时候，都会赋予[]。下面来看看，这样做的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;]
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;, &quot;baz&quot;]
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;, &quot;baz&quot;, &quot;baz&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def foo(bar=None):
...    if bar is None:      # or if not bar:
...        bar = []
...    bar.append(&quot;baz&quot;)
...    return bar
...
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;]
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;]
&amp;gt;&amp;gt;&amp;gt; foo()
[&quot;baz&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;46. 误解Python规则范围&lt;/h2&gt;

&lt;p&gt;Python的作用域解析是基于LEGB规则，分别是Local、Enclosing、Global、Built-in。实际上，这种解析方法也有一些玄机，看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = 10
&amp;gt;&amp;gt;&amp;gt; def foo():
...     x += 1
...     print x
...
&amp;gt;&amp;gt;&amp;gt; foo()
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in foo
UnboundLocalError: local variable &#39;x&#39; referenced before assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;许多人会感动惊讶，当他们在工作的函数体里添加一个参数语句，会在先前工作的代码里报UnboundLocalError错误（ 点击这里查看更详细描述）。
在使用列表时，开发者是很容易犯这种错误的，看看下面这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; lst = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; def foo1():
...     lst.append(5)   # This works ok...
...
&amp;gt;&amp;gt;&amp;gt; foo1()
&amp;gt;&amp;gt;&amp;gt; lst
[1, 2, 3, 5]

&amp;gt;&amp;gt;&amp;gt; lst = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; def foo2():
...     lst += [5]      # ... but this bombs!
...
&amp;gt;&amp;gt;&amp;gt; foo2()
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in foo
UnboundLocalError: local variable &#39;lst&#39; referenced before assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么foo2失败而foo1运行正常？
答案与前面那个例子是一样的，但又有一些微妙之处。foo1没有赋值给lst，而foo2赋值了。lst += [5]实际上就是lst = lst + [5]，试图给lst赋值（因此，假设Python是在局部作用域里）。然而，我们正在寻找指定给lst的值是基于lst本身，其实尚未确定。&lt;/p&gt;

&lt;h2&gt;47. 修改遍历列表&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; odd = lambda x : bool(x % 2)
&amp;gt;&amp;gt;&amp;gt; numbers = [n for n in range(10)]
&amp;gt;&amp;gt;&amp;gt; for i in range(len(numbers)):
...     if odd(numbers[i]):
...         del numbers[i]  # BAD: Deleting item from a list while iterating over it
...
Traceback (most recent call last):
      File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在遍历的时候，对列表进行删除操作，这是很低级的错误。稍微有点经验的人都不会犯。
对上面的代码进行修改，正确地执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; odd = lambda x : bool(x % 2)
&amp;gt;&amp;gt;&amp;gt; numbers = [n for n in range(10)]
&amp;gt;&amp;gt;&amp;gt; numbers[:] = [n for n in numbers if not odd(n)]  # ahh, the beauty of it all
&amp;gt;&amp;gt;&amp;gt; numbers
[0, 2, 4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;48. 合理使用copy与deepcopy&lt;/h2&gt;

&lt;p&gt;对于dict和list等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用copy包里的copy和deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在ipython中运行）&lt;/p&gt;

&lt;p&gt;timeit后面的-n表示运行的次数，后两行对应的是两个timeit的输出，下同。由此可见后者慢一个数量级。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import copy
a = range(100000)
%timeit -n 10 copy.copy(a) # 运行10次 copy.copy(a)
%timeit -n 10 copy.deepcopy(a)
10 loops, best of 3: 1.55 ms per loop
10 loops, best of 3: 151 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;49. 合理使用生成器（generator）和yield&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%timeit -n 100 a = (i for i in range(100000))
%timeit -n 100 b = [i for i in range(100000)]
100 loops, best of 3: 1.54 ms per loop
100 loops, best of 3: 4.56 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用()得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如set(i for i in range(100000))会比set([i for i in range(100000)])快。&lt;/p&gt;

&lt;p&gt;但是对于需要循环遍历的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%timeit -n 10 for x in (i for i in range(100000)): pass
%timeit -n 10 for x in [i for i in range(100000)]: pass
10 loops, best of 3: 6.51 ms per loop
10 loops, best of 3: 5.54 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后者的效率反而更高，但是如果循环里有break,用generator的好处是显而易见的。yield也是用于创建generator：&lt;/p&gt;

&lt;h2&gt;50. 使用级联比较x &amp;lt; y &amp;lt; z&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;x, y, z = 1,2,3
%timeit -n 1000000 if x &amp;lt; y &amp;lt; z:pass
%timeit -n 1000000 if x &amp;lt; y and y &amp;lt; z:pass
1000000 loops, best of 3: 101 ns per loop
1000000 loops, best of 3: 121 ns per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x &amp;lt; y &amp;lt; z效率略高，而且可读性更好。&lt;/p&gt;

&lt;h2&gt;51. while 1 比 while True 更快&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;def while_1():
    n = 100000
    while 1:
        n -= 1
        if n &amp;lt;= 0: break
def while_true():
    n = 100000
    while True:
        n -= 1
        if n &amp;lt;= 0: break    

m, n = 1000000, 1000000 
%timeit -n 100 while_1()
%timeit -n 100 while_true()
100 loops, best of 3: 3.69 ms per loop
100 loops, best of 3: 5.61 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while 1 比 while true快很多，原因是在python2.x中，True是一个全局变量，而非关键字。&lt;/p&gt;

&lt;h2&gt;52. 使用**而不是pow&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;%timeit -n 10000 c = pow(2,20)
%timeit -n 10000 c = 2**20
10000 loops, best of 3: 284 ns per loop
10000 loops, best of 3: 16.9 ns per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;53. 使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;import cPickle
import pickle
a = range(10000)
%timeit -n 100 x = cPickle.dumps(a)
%timeit -n 100 x = pickle.dumps(a)
100 loops, best of 3: 1.58 ms per loop
100 loops, best of 3: 17 ms per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由c实现的包，速度快10倍以上！&lt;/p&gt;

&lt;h2&gt;54. 使用最佳的反序列化方式&lt;/h2&gt;

&lt;p&gt;下面比较了eval, cPickle, json方式三种对相应字符串反序列化的效率，可见json比cPickle快近3倍，比eval快20多倍。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import json
import cPickle
a = range(10000)
s1 = str(a)
s2 = cPickle.dumps(a)
s3 = json.dumps(a)
%timeit -n 100 x = eval(s1)
%timeit -n 100 x = cPickle.loads(s2)
%timeit -n 100 x = json.loads(s3)
100 loops, best of 3: 16.8 ms per loop
100 loops, best of 3: 2.02 ms per loop
100 loops, best of 3: 798 µs per loop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;55. 怎么才算精通python&lt;/h2&gt;

&lt;p&gt;这个问题比较难回答，我是看 &lt;a href=&quot;http://www.zhihu.com/question/19794855&quot;&gt;怎么样才算是精通 Python&lt;/a&gt; 这个知乎问答，按照自己的看法整理了一些观点。不要问我是按什么标准整理的，我只能说，整理的这些点，第一，在我看来都说得不错；第二，我自己都会去按照这些点来看看自己离 “精通” python还有多远。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;熟悉语法以及原声数据结构&lt;/li&gt;
&lt;li&gt;熟悉基本实现中的性能特点，就是知道什么操作会慢&lt;/li&gt;
&lt;li&gt;会使用profile以及基于profile的性能分析工具&lt;/li&gt;
&lt;li&gt;会使用运行时编译和静态编译的工具。pypy，numba，cython，ctypes，original C/C++ extension&lt;/li&gt;
&lt;li&gt;熟悉你所在领域的拓展库，比如我，科学计算方面的库不要太多，numpy衍生出来的一大堆大堆&lt;/li&gt;
&lt;li&gt;了解基本的编译过程，基本的操作系统知识（只要你C、C++学的还行就可以了）&lt;/li&gt;
&lt;li&gt;要想精通python，写的代码首先得pythonic&lt;/li&gt;
&lt;li&gt;研读牛B的开源代码，在这过程中会遇到python的许多高阶用法&lt;/li&gt;
&lt;li&gt;理解装饰器，生成器，描述符，元类&lt;/li&gt;
&lt;li&gt;掌握list comprehension，&lt;/li&gt;
&lt;li&gt;多用内置函数：map，reduce，filter，iter，range，divmod，round，chr，enumerate，all，any，slice，zip+&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;56. python 猴子补丁相关&lt;/h2&gt;

&lt;p&gt;python里有一个很奇妙的monkey patch，中文叫做猴子补丁，是指的是在运行时动态替换某些已加载的模块的实现。第一次了解这个概念是在使用gevent的时候，需要把python自带的socket，os等相关模块的实现改变成异步形式，但同时不改动python的源代码。&lt;/p&gt;

&lt;h2&gt;57. 了解 functools.partial&lt;/h2&gt;

&lt;p&gt;先参考 &lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/9712125&quot;&gt;飘逸的python - 偏函数functools.partial&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81393/&quot;&gt;初学者必知的Python中优雅的用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81233/&quot;&gt;Python基础技术问题总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/58226/&quot;&gt;Python程序员必知必会的开发者工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81210/&quot;&gt;Python代码微优化之加快查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/79197/&quot;&gt;写给已有编程经验的 Python 初学者的总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81187/&quot;&gt;Python中导入模块或包语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cenalulu.github.io/python/default-mutable-arguments/&quot;&gt;Python函数参数默认值的陷阱和原理深究&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81132/&quot;&gt;关于Python日志系统的几点建议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81129/&quot;&gt;详解Python中的下划线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pyzh.readthedocs.org/en/latest/python-hidden-features.html&quot;&gt;9. (译)Python的隐藏特性(StackOverflow)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/81035/&quot;&gt;提升 Python 程序性能的 6 个技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/80939/&quot;&gt;在Python中正确使用Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/61171/&quot;&gt;Python高级编程技巧 - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/65218/&quot;&gt;Python中的高级数据结构 - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sahandsaba.com/thirty-python-language-features-and-tricks-you-may-not-know.html&quot;&gt;30 Python Language Features and Tricks You May Not Know About&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.csdn.net/article/2014-05-12/2819716-Top-10-Mistakes-that-Python-Programmers-Make&quot;&gt;Python开发者最常犯的10个错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.toptal.com/python#hiring-guide&quot;&gt;The Insider&#39;s Guide to Python Interviewing - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000000666603&quot;&gt;Python性能优化的20条建议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/51062/&quot;&gt;我常用的 Python 调试工具 - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/19794855&quot;&gt;怎么样才算是精通 Python - 赞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jianfeihit.iteye.com/blog/1835272&quot;&gt;python内置函数大全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/40297775&quot;&gt;什么是猴子补丁(monkey patch)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5626193/what-is-monkey-patch&quot;&gt;What is monkey patch?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.tryolabs.com/2013/07/05/run-time-method-patching-python/&quot;&gt;RUN-TIME METHOD PATCHING IN PYTHON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/9712125&quot;&gt;飘逸的python - 偏函数functools.partial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jeffknupp.com/blog/2013/02/14/drastically-improve-your-python-understanding-pythons-execution-model/&quot;&gt;Drastically Improve Your Python: Understanding Python&#39;s Execution Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/39895871&quot;&gt;飘逸的python - descriptor(描述器)就是这么回事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pyzh.readthedocs.org/en/latest/Descriptor-HOW-TO-Guide.html&quot;&gt;Python描述器引导(翻译)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://wklken.me/posts/2013/08/20/python-extra-itertools.html&quot;&gt;PYTHON-进阶-ITERTOOLS模块小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;参考网站&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://py.memect.com/&quot;&gt;python 日报&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://python.jobbole.com/category/python/&quot;&gt;伯乐在线-python文章集锦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.freebuf.com/&quot;&gt;黑客与极客的python文章集锦&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-17-python-materials.md.jpg&quot; alt=&quot;2015-03-17-python-materials.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结之结构型模式</title>
     <link href="/design-pattern-structural-pattern"/>
     <updated>2015-03-13T00:00:00+08:00</updated>
     <id>/design-pattern-structural-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 适配器模式&lt;/h2&gt;

&lt;p&gt;　　在设计模式中，适配器模式（英语：adapter pattern）有时候也称包装样式或者包装。将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类别自己的接口包裹在一个已存在的类中。&lt;/p&gt;

&lt;h3&gt;1.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2008/11/06/generic-adapter-class-in-python/&quot;&quot;&quot;

import os

class Dog(object):
    def __init__(self):
        self.name = &quot;Dog&quot;
    def bark(self):
        return &quot;woof!&quot;

class Cat(object):
    def __init__(self):
        self.name = &quot;Cat&quot;
    def meow(self):
        return &quot;meow!&quot;

class Human(object):
    def __init__(self):
        self.name = &quot;Human&quot;
    def speak(self):
        return &quot;&#39;hello&#39;&quot;


class Car(object):
    def __init__(self):
        self.name = &quot;Car&quot;
    def make_noise(self, octane_level):
        return &quot;vroom{0}&quot;.format(&quot;!&quot; * octane_level)


class Adapter(object):

    &quot;&quot;&quot;
    Adapts an object by replacing methods.
    Usage:
    dog = Dog
    dog = Adapter(dog, dict(make_noise=dog.bark))
    &amp;gt;&amp;gt;&amp;gt; objects = []
    &amp;gt;&amp;gt;&amp;gt; dog = Dog()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(dog, make_noise=dog.bark))
    &amp;gt;&amp;gt;&amp;gt; cat = Cat()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(cat, make_noise=cat.meow))
    &amp;gt;&amp;gt;&amp;gt; human = Human()
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(human, make_noise=human.speak))
    &amp;gt;&amp;gt;&amp;gt; car = Car()
    &amp;gt;&amp;gt;&amp;gt; car_noise = lambda: car.make_noise(3)
    &amp;gt;&amp;gt;&amp;gt; objects.append(Adapter(car, make_noise=car_noise))
    &amp;gt;&amp;gt;&amp;gt; for obj in objects:
    ...     print(&#39;A {} goes {}&#39;.format(obj.name, obj.make_noise()))
    A Dog goes woof!
    A Cat goes meow!
    A Human goes &#39;hello&#39;
    A Car goes vroom!!!
    &quot;&quot;&quot;

    def __init__(self, obj, **adapted_methods):
        &quot;&quot;&quot;We set the adapted methods in the object&#39;s dict&quot;&quot;&quot;
        self.obj = obj
        self.__dict__.update(adapted_methods)

    def __getattr__(self, attr):
        &quot;&quot;&quot;All non-adapted calls are passed to the object&quot;&quot;&quot;
        return getattr(self.obj, attr)


def main():
    objects = []
    dog = Dog()
    objects.append(Adapter(dog, make_noise=dog.bark))
    cat = Cat()
    objects.append(Adapter(cat, make_noise=cat.meow))
    human = Human()
    objects.append(Adapter(human, make_noise=human.speak))
    car = Car()
    objects.append(Adapter(car, make_noise=lambda: car.make_noise(3)))

    for obj in objects:
        print(&quot;A {0} goes {1}&quot;.format(obj.name, obj.make_noise()))


if __name__ == &quot;__main__&quot;:
    main()

### OUTPUT ###
# A Dog goes woof!
# A Cat goes meow!
# A Human goes &#39;hello&#39;
# A Car goes vroom!!!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 桥接模式&lt;/h2&gt;

&lt;p&gt;　　桥接模式是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。&lt;/p&gt;

&lt;h3&gt;2.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://en.wikibooks.org/wiki/Computer_Science_Design_Patterns/Bridge_Pattern#Python&quot;&quot;&quot;


# ConcreteImplementor 1/2
class DrawingAPI1(object):

    def draw_circle(self, x, y, radius):
        print(&#39;API1.circle at {}:{} radius {}&#39;.format(x, y, radius))


# ConcreteImplementor 2/2
class DrawingAPI2(object):

    def draw_circle(self, x, y, radius):
        print(&#39;API2.circle at {}:{} radius {}&#39;.format(x, y, radius))


# Refined Abstraction
class CircleShape(object):

    def __init__(self, x, y, radius, drawing_api):
        self._x = x
        self._y = y
        self._radius = radius
        self._drawing_api = drawing_api

    # low-level i.e. Implementation specific
    def draw(self):
        self._drawing_api.draw_circle(self._x, self._y, self._radius)

    # high-level i.e. Abstraction specific
    def scale(self, pct):
        self._radius *= pct


def main():
    shapes = (
        CircleShape(1, 2, 3, DrawingAPI1()),
        CircleShape(5, 7, 11, DrawingAPI2())
    )

    for shape in shapes:
        shape.scale(2.5)
        shape.draw()


if __name__ == &#39;__main__&#39;:
    main()

### OUTPUT ###
# API1.circle at 1:2 radius 7.5
# API2.circle at 5:7 radius 27.5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 组合模式&lt;/h2&gt;

&lt;p&gt;　　针对“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;

&lt;h3&gt;3.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;
A class which defines a composite object which can store
hieararchical dictionaries with names.
This class is same as a hiearchical dictionary, but it
provides methods to add/access/modify children by name,
like a Composite.
Created Anand B Pillai     &amp;lt;abpillai@gmail.com&amp;gt;
&quot;&quot;&quot;
__author__ = &quot;Anand B Pillai&quot;
__maintainer__ = &quot;Anand B Pillai&quot;
__version__ = &quot;0.2&quot;


def normalize(val):
    &quot;&quot;&quot; Normalize a string so that it can be used as an attribute
    to a Python object &quot;&quot;&quot;

    if val.find(&#39;-&#39;) != -1:
        val = val.replace(&#39;-&#39;, &#39;_&#39;)

    return val


def denormalize(val):
    &quot;&quot;&quot; De-normalize a string &quot;&quot;&quot;

    if val.find(&#39;_&#39;) != -1:
        val = val.replace(&#39;_&#39;, &#39;-&#39;)

    return val


class SpecialDict(dict):

    &quot;&quot;&quot; A dictionary type which allows direct attribute
    access to its keys &quot;&quot;&quot;

    def __getattr__(self, name):

        if name in self.__dict__:
            return self.__dict__[name]
        elif name in self:
            return self.get(name)
        else:
            # Check for denormalized name
            name = denormalize(name)
            if name in self:
                return self.get(name)
            else:
                raise AttributeError(&#39;no attribute named %s&#39; % name)

    def __setattr__(self, name, value):

        if name in self.__dict__:
            self.__dict__[name] = value
        elif name in self:
            self[name] = value
        else:
            # Check for denormalized name
            name2 = denormalize(name)
            if name2 in self:
                self[name2] = value
            else:
                # New attribute
                self[name] = value


class CompositeDict(SpecialDict):

    &quot;&quot;&quot; A class which works like a hierarchical dictionary.
    This class is based on the Composite design-pattern &quot;&quot;&quot;

    ID = 0

    def __init__(self, name=&#39;&#39;):

        if name:
            self._name = name
        else:
            self._name = &#39;&#39;.join((&#39;id#&#39;, str(self.__class__.ID)))
            self.__class__.ID += 1

        self._children = []
        # Link  back to father
        self._father = None
        self[self._name] = SpecialDict()

    def __getattr__(self, name):

        if name in self.__dict__:
            return self.__dict__[name]
        elif name in self:
            return self.get(name)
        else:
            # Check for denormalized name
            name = denormalize(name)
            if name in self:
                return self.get(name)
            else:
                # Look in children list
                child = self.findChild(name)
                if child:
                    return child
                else:
                    attr = getattr(self[self._name], name)
                    if attr:
                        return attr

                    raise AttributeError(&#39;no attribute named %s&#39; % name)

    def isRoot(self):
        &quot;&quot;&quot; Return whether I am a root component or not &quot;&quot;&quot;

        # If I don&#39;t have a parent, I am root
        return not self._father

    def isLeaf(self):
        &quot;&quot;&quot; Return whether I am a leaf component or not &quot;&quot;&quot;

        # I am a leaf if I have no children
        return not self._children

    def getName(self):
        &quot;&quot;&quot; Return the name of this ConfigInfo object &quot;&quot;&quot;

        return self._name

    def getIndex(self, child):
        &quot;&quot;&quot; Return the index of the child ConfigInfo object &#39;child&#39; &quot;&quot;&quot;

        if child in self._children:
            return self._children.index(child)
        else:
            return -1

    def getDict(self):
        &quot;&quot;&quot; Return the contained dictionary &quot;&quot;&quot;

        return self[self._name]

    def getProperty(self, child, key):
        &quot;&quot;&quot; Return the value for the property for child
        &#39;child&#39; with key &#39;key&#39; &quot;&quot;&quot;

        # First get the child&#39;s dictionary
        childDict = self.getInfoDict(child)
        if childDict:
            return childDict.get(key, None)

    def setProperty(self, child, key, value):
        &quot;&quot;&quot; Set the value for the property &#39;key&#39; for
        the child &#39;child&#39; to &#39;value&#39; &quot;&quot;&quot;

        # First get the child&#39;s dictionary
        childDict = self.getInfoDict(child)
        if childDict:
            childDict[key] = value

    def getChildren(self):
        &quot;&quot;&quot; Return the list of immediate children of this object &quot;&quot;&quot;

        return self._children

    def getAllChildren(self):
        &quot;&quot;&quot; Return the list of all children of this object &quot;&quot;&quot;

        l = []
        for child in self._children:
            l.append(child)
            l.extend(child.getAllChildren())

        return l

    def getChild(self, name):
        &quot;&quot;&quot; Return the immediate child object with the given name &quot;&quot;&quot;

        for child in self._children:
            if child.getName() == name:
                return child

    def findChild(self, name):
        &quot;&quot;&quot; Return the child with the given name from the tree &quot;&quot;&quot;

        # Note - this returns the first child of the given name
        # any other children with similar names down the tree
        # is not considered.

        for child in self.getAllChildren():
            if child.getName() == name:
                return child

    def findChildren(self, name):
        &quot;&quot;&quot; Return a list of children with the given name from the tree &quot;&quot;&quot;

        # Note: this returns a list of all the children of a given
        # name, irrespective of the depth of look-up.

        children = []

        for child in self.getAllChildren():
            if child.getName() == name:
                children.append(child)

        return children

    def getPropertyDict(self):
        &quot;&quot;&quot; Return the property dictionary &quot;&quot;&quot;

        d = self.getChild(&#39;__properties&#39;)
        if d:
            return d.getDict()
        else:
            return {}

    def getParent(self):
        &quot;&quot;&quot; Return the person who created me &quot;&quot;&quot;

        return self._father

    def __setChildDict(self, child):
        &quot;&quot;&quot; Private method to set the dictionary of the child
        object &#39;child&#39; in the internal dictionary &quot;&quot;&quot;

        d = self[self._name]
        d[child.getName()] = child.getDict()

    def setParent(self, father):
        &quot;&quot;&quot; Set the parent object of myself &quot;&quot;&quot;

        # This should be ideally called only once
        # by the father when creating the child :-)
        # though it is possible to change parenthood
        # when a new child is adopted in the place
        # of an existing one - in that case the existing
        # child is orphaned - see addChild and addChild2
        # methods !
        self._father = father

    def setName(self, name):
        &quot;&quot;&quot; Set the name of this ConfigInfo object to &#39;name&#39; &quot;&quot;&quot;

        self._name = name

    def setDict(self, d):
        &quot;&quot;&quot; Set the contained dictionary &quot;&quot;&quot;

        self[self._name] = d.copy()

    def setAttribute(self, name, value):
        &quot;&quot;&quot; Set a name value pair in the contained dictionary &quot;&quot;&quot;

        self[self._name][name] = value

    def getAttribute(self, name):
        &quot;&quot;&quot; Return value of an attribute from the contained dictionary &quot;&quot;&quot;

        return self[self._name][name]

    def addChild(self, name, force=False):
        &quot;&quot;&quot; Add a new child &#39;child&#39; with the name &#39;name&#39;.
        If the optional flag &#39;force&#39; is set to True, the
        child object is overwritten if it is already there.
        This function returns the child object, whether
        new or existing &quot;&quot;&quot;

        if type(name) != str:
            raise ValueError(&#39;Argument should be a string!&#39;)

        child = self.getChild(name)
        if child:
            # print(&#39;Child %s present!&#39; % name)
            # Replace it if force==True
            if force:
                index = self.getIndex(child)
                if index != -1:
                    child = self.__class__(name)
                    self._children[index] = child
                    child.setParent(self)

                    self.__setChildDict(child)
            return child
        else:
            child = self.__class__(name)
            child.setParent(self)

            self._children.append(child)
            self.__setChildDict(child)

            return child

    def addChild2(self, child):
        &quot;&quot;&quot; Add the child object &#39;child&#39;. If it is already present,
        it is overwritten by default &quot;&quot;&quot;

        currChild = self.getChild(child.getName())
        if currChild:
            index = self.getIndex(currChild)
            if index != -1:
                self._children[index] = child
                child.setParent(self)
                # Unset the existing child&#39;s parent
                currChild.setParent(None)
                del currChild

                self.__setChildDict(child)
        else:
            child.setParent(self)
            self._children.append(child)
            self.__setChildDict(child)


if __name__ == &quot;__main__&quot;:
    window = CompositeDict(&#39;Window&#39;)
    frame = window.addChild(&#39;Frame&#39;)
    tfield = frame.addChild(&#39;Text Field&#39;)
    tfield.setAttribute(&#39;size&#39;, &#39;20&#39;)

    btn = frame.addChild(&#39;Button1&#39;)
    btn.setAttribute(&#39;label&#39;, &#39;Submit&#39;)

    btn = frame.addChild(&#39;Button2&#39;)
    btn.setAttribute(&#39;label&#39;, &#39;Browse&#39;)

    # print(window)
    # print(window.Frame)
    # print(window.Frame.Button1)
    # print(window.Frame.Button2)
    print(window.Frame.Button1.label)
    print(window.Frame.Button2.label)

### OUTPUT ###
# Submit
# Browse
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 修饰模式&lt;/h2&gt;

&lt;p&gt;　　修饰模式，是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。修饰模式是类继承的另外一种选择。类继承在编译时候增加行为，而装饰模式是在运行时增加行为。&lt;/p&gt;

&lt;h3&gt;4.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;https://docs.python.org/2/library/functools.html#functools.wraps&quot;&quot;&quot;
&quot;&quot;&quot;https://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/739665#739665&quot;&quot;&quot;

from functools import wraps


def makebold(fn):
    @wraps(fn)
    def wrapped():
        return &quot;&amp;lt;b&amp;gt;&quot; + fn() + &quot;&amp;lt;/b&amp;gt;&quot;
    return wrapped


def makeitalic(fn):
    @wraps(fn)
    def wrapped():
        return &quot;&amp;lt;i&amp;gt;&quot; + fn() + &quot;&amp;lt;/i&amp;gt;&quot;
    return wrapped


@makebold
@makeitalic
def hello():
    &quot;&quot;&quot;a decorated hello world&quot;&quot;&quot;
    return &quot;hello world&quot;

if __name__ == &#39;__main__&#39;:
    print(&#39;result:{}   name:{}   doc:{}&#39;.format(hello(), hello.__name__, hello.__doc__))

### OUTPUT ###
# result:&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;hello world&amp;lt;/i&amp;gt;&amp;lt;/b&amp;gt;   name:hello   doc:a decorated hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. 外观模式&lt;/h2&gt;

&lt;p&gt;　　外观模式（Facade pattern），是软件工程中常用的一种软件设计模式，它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。&lt;/p&gt;

&lt;h3&gt;5.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time

SLEEP = 0.5


# Complex Parts
class TC1:

    def run(self):
        print(&quot;###### In Test 1 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


class TC2:

    def run(self):
        print(&quot;###### In Test 2 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


class TC3:

    def run(self):
        print(&quot;###### In Test 3 ######&quot;)
        time.sleep(SLEEP)
        print(&quot;Setting up&quot;)
        time.sleep(SLEEP)
        print(&quot;Running test&quot;)
        time.sleep(SLEEP)
        print(&quot;Tearing down&quot;)
        time.sleep(SLEEP)
        print(&quot;Test Finished\n&quot;)


# Facade
class TestRunner:

    def __init__(self):
        self.tc1 = TC1()
        self.tc2 = TC2()
        self.tc3 = TC3()
        self.tests = [i for i in (self.tc1, self.tc2, self.tc3)]

    def runAll(self):
        [i.run() for i in self.tests]


# Client
if __name__ == &#39;__main__&#39;:
    testrunner = TestRunner()
    testrunner.runAll()

### OUTPUT ###
# ###### In Test 1 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
# ###### In Test 2 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
# ###### In Test 3 ######
# Setting up
# Running test
# Tearing down
# Test Finished
#
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-13-design-pattern-structural-pattern.md.jpg&quot; alt=&quot;2015-03-13-design-pattern-structural-pattern.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结之行为型模式</title>
     <link href="/design-pattern-behavior-pattern"/>
     <updated>2015-03-12T00:00:00+08:00</updated>
     <id>/design-pattern-behavior-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 迭代器模式&lt;/h2&gt;

&lt;p&gt;　　提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。迭代器模式的结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。&lt;/li&gt;
&lt;li&gt;具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。&lt;/li&gt;
&lt;li&gt;抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(),&lt;/li&gt;
&lt;li&gt;迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;1.1 Python源码实例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/
Implementation of the iterator pattern with a generator&quot;&quot;&quot;


def count_to(count):
    &quot;&quot;&quot;Counts by word numbers, up to a maximum of five&quot;&quot;&quot;
    numbers = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]
    # enumerate() returns a tuple containing a count (from start which
    # defaults to 0) and the values obtained from iterating over sequence
    for pos, number in zip(range(count), numbers):
        yield number

# Test the generator
count_to_two = lambda: count_to(2)
count_to_five = lambda: count_to(5)

print(&#39;Counting to two...&#39;)
for number in count_to_two():
    print(number, end=&#39; &#39;)

print()

print(&#39;Counting to five...&#39;)
for number in count_to_five():
    print(number, end=&#39; &#39;)

print()

### OUTPUT ###
# Counting to two...
# one two
# Counting to five...
# one two three four five
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 观察者模式&lt;/h2&gt;

&lt;p&gt;　　观察者模式（有时又被称为发布/订阅模式）是软件设计模式的一种。在此种模式中，一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。&lt;/p&gt;

&lt;h3&gt;2.1 Python源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;
Reference: http://www.slideshare.net/ishraqabd/publish-subscribe-model-overview-13368808
Author: https://github.com/HanWenfang
&quot;&quot;&quot;


class Provider:

    def __init__(self):
        self.msg_queue = []
        self.subscribers = {}

    def notify(self, msg):
        self.msg_queue.append(msg)

    def subscribe(self, msg, subscriber):
        if msg not in self.subscribers:
            self.subscribers[msg] = []
            self.subscribers[msg].append(subscriber)  # unfair
        else:
            self.subscribers[msg].append(subscriber)

    def unsubscribe(self, msg, subscriber):
        self.subscribers[msg].remove(subscriber)

    def update(self):
        for msg in self.msg_queue:
            if msg in self.subscribers:
                for sub in self.subscribers[msg]:
                    sub.run(msg)
        self.msg_queue = []


class Publisher:

    def __init__(self, msg_center):
        self.provider = msg_center

    def publish(self, msg):
        self.provider.notify(msg)


class Subscriber:

    def __init__(self, name, msg_center):
        self.name = name
        self.provider = msg_center

    def subscribe(self, msg):
        self.provider.subscribe(msg, self)

    def run(self, msg):
        print(&quot;{} got {}&quot;.format(self.name, msg))


def main():
    message_center = Provider()

    fftv = Publisher(message_center)

    jim = Subscriber(&quot;jim&quot;, message_center)
    jim.subscribe(&quot;cartoon&quot;)
    jack = Subscriber(&quot;jack&quot;, message_center)
    jack.subscribe(&quot;music&quot;)
    gee = Subscriber(&quot;gee&quot;, message_center)
    gee.subscribe(&quot;movie&quot;)

    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;music&quot;)
    fftv.publish(&quot;ads&quot;)
    fftv.publish(&quot;movie&quot;)
    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;cartoon&quot;)
    fftv.publish(&quot;movie&quot;)
    fftv.publish(&quot;blank&quot;)

    message_center.update()


if __name__ == &quot;__main__&quot;:
    main()

### OUTPUT ###
# jim got cartoon
# jack got music
# gee got movie
# jim got cartoon
# jim got cartoon
# gee got movie
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 策略模式&lt;/h2&gt;

&lt;p&gt;　　策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。主要是应对：在软件构建过程中，某些对象使用的算法可能多种多样，经常发生变化。如果在对象内部实现这些算法，将会使对象变得异常复杂，甚至会造成性能上的负担。GoF《设计模式》中说道：定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。该模式使得算法可独立于它们的客户变化。&lt;/p&gt;

&lt;h3&gt;3.1 Python 源码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class Duck(object):
    # 上面使用继承，这里通用的使用参数方式，传入的就是操作工厂的类
    def __init__(self, strategy=None):
        self.action = None
        self.count = 0
        if strategy:
            # 指定策略，那么执行action就是用这个类的实例
            self.action = strategy()

    def fly(self, kind):
        if self.action:
            self.count += 1
            # 这里的第二个参数self，算是炫技吧，就是为了让操作的方法获得这里计算好的count
            return self.action.fly(kind, self)

        else:
            raise UnboundLocalError(&#39;Exception raised, no strategyClass supplied to Duck!&#39;)

# 注意这里没有继承Duck，因为是以参数的方式传入类名
class Duck1(object):

    def fly(self, kind, instance):
        return &#39;Duck1 fly kind: &#39; + kind + &#39;#&#39; + str(instance.count)


class Duck2(object):

    def fly(self, kind, instance):
        return &#39;Duck2 fly kind: &#39; + kind + &#39;#&#39; + str(instance.count)


if __name__ == &#39;__main__&#39;:
    duckfly = Duck()
    duck1fly = Duck(strategy=Duck1)
    duck2fly = Duck(strategy=Duck2)

    try:
        print duckfly.fly(&#39;yes&#39;)
    except Exception as e:
        print &quot;The following exception was expected:&quot;
        print e

    print duck1fly.fly(&#39;yes&#39;)
    print duck1fly.fly(&#39;no&#39;)
    print duck1fly.fly(&#39;yes&#39;)
    print duck2fly.fly(&#39;yes&#39;)
    print duck2fly.fly(&#39;no&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 模板方法模式&lt;/h2&gt;

&lt;p&gt;　　模板方法模式定义了一个算法的步骤，并允许次类别为一个或多个步骤提供其实践方式。让次类别在不改变算法架构的情况下，重新定义算法中的某些步骤。在软件工程中，它是一种软件设计模式，和C++模板没有关连。也可以理解为定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。因此模板方法使得子类可以在不改变一个算法的结构的情况下重新定义该算法的某些特定变量。优点是把不变行为搬移到超类，去除子类中的重复代码。&lt;/p&gt;

&lt;h3&gt;4.1 Python源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;http://blog.csdn.net/five3/article/details/7564578&quot;&gt;csdn.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python  
#encoding: utf-8  

class template:
    def __init__(self):
        pass

    def logic(self):
        print &#39;do something before ....&#39;
        print self.do_something_now()
        print &#39;do something after ....&#39;

    def do_something_now(self):
        return None      

class apply_temp1(template):
    def __init__(self):
        pass

    def do_something_now(self):
        return &#39;apply 1&#39;  

class apply_temp2(template):
    def __init__(self):
        pass

    def do_something_now(self):
        return &#39;apply 2&#39;  


if &#39;__main__&#39; == __name__:  
    obj1 = apply_temp1()
    obj2 = apply_temp2()
    obj1.logic()
    obj2.logic()
    print obj1.__class__
    print obj2.__class__
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-12-design-pattern-behavior-pattern.md.jpg&quot; alt=&quot;2015-03-12-design-pattern-behavior-pattern.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结之创建型模式</title>
     <link href="/design-pattern-create-pattern"/>
     <updated>2015-03-11T00:00:00+08:00</updated>
     <id>/design-pattern-create-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 抽象工厂模式&lt;/h2&gt;

&lt;p&gt;　　抽象工厂模式（英语：Abstract factory pattern）是一种软件开发设计模式。抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。&lt;/p&gt;

&lt;p&gt;　　举个例子来说，比如一个抽象工厂类叫做DocumentCreator（文档创建器），此类提供创建若干种产品的接口，包括createLetter()（创建邮件）和createResume()（创建简历）。其中，createLetter()返回一个Letter（邮件），createResume()返回一个Resume（简历）。系统中还有一些DocumentCreator的具体实现类，包括FancyDocumentCreator和ModernDocumentCreator。这两个类对DocumentCreator的两个方法分别有不同的实现，用来创建不同的“邮件”和“简历”（用FancyDocumentCreator的实例可以创建FancyLetter和FancyResume，用ModernDocumentCreator的实例可以创建ModernLetter和ModernResume）。这些具体的“邮件”和“简历”类均继承自抽象类，即Letter和Resume类。客户端需要创建“邮件”或“简历”时，先要得到一个合适的DocumentCreator实例，然后调用它的方法。一个工厂中创建的每个对象都是同一个主题的（“fancy”或者“modern”）。客户端程序只需要知道得到的对象是“邮件”或者“简历”，而不需要知道具体的主题，因此客户端程序从抽象工厂DocumentCreator中得到了Letter或Resume类的引用，而不是具体类的对象引用。&lt;/p&gt;

&lt;p&gt;　　“工厂”是创建产品（对象）的地方，其目的是将产品的创建与产品的使用分离。抽象工厂模式的目的，是将若干抽象产品的接口与不同主题产品的具体实现分离开。这样就能在增加新的具体工厂的时候，不用修改引用抽象工厂的客户端代码。&lt;/p&gt;

&lt;p&gt;　　使用抽象工厂模式，能够在具体工厂变化的时候，不用修改使用工厂的客户端代码，甚至是在运行时。然而，使用这种模式或者相似的设计模式，可能给编写代码带来不必要的复杂性和额外的工作。正确使用设计模式能够抵消这样的“额外工作”。&lt;/p&gt;

&lt;h3&gt;1.1 Python 源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;https://github.com/faif/python-patterns/&quot;&gt;github:python-patterns&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

# http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/

&quot;&quot;&quot;Implementation of the abstract factory pattern&quot;&quot;&quot;

import random

class PetShop:

    &quot;&quot;&quot;A pet shop&quot;&quot;&quot;

    def __init__(self, animal_factory=None):
        &quot;&quot;&quot;pet_factory is our abstract factory.  We can set it at will.&quot;&quot;&quot;

        self.pet_factory = animal_factory

    def show_pet(self):
        &quot;&quot;&quot;Creates and shows a pet using the abstract factory&quot;&quot;&quot;

        pet = self.pet_factory.get_pet()
        print(&quot;We have a lovely {}&quot;.format(pet))
        print(&quot;It says {}&quot;.format(pet.speak()))
        print(&quot;We also have {}&quot;.format(self.pet_factory.get_food()))


# Stuff that our factory makes

class Dog:

    def speak(self):
        return &quot;woof&quot;

    def __str__(self):
        return &quot;Dog&quot;


class Cat:

    def speak(self):
        return &quot;meow&quot;

    def __str__(self):
        return &quot;Cat&quot;


# Factory classes

class DogFactory:

    def get_pet(self):
        return Dog()

    def get_food(self):
        return &quot;dog food&quot;


class CatFactory:

    def get_pet(self):
        return Cat()

    def get_food(self):
        return &quot;cat food&quot;

# Create the proper family
def get_factory():
    &quot;&quot;&quot;Let&#39;s be dynamic!&quot;&quot;&quot;
    return random.choice([DogFactory, CatFactory])()


# Show pets with various factories
if __name__ == &quot;__main__&quot;:
    for i in range(3):
        shop = PetShop(get_factory())
        shop.show_pet()
        print(&quot;=&quot; * 20)

### OUTPUT ###
# We have a lovely Dog
# It says woof
# We also have dog food
# ====================
# We have a lovely Dog
# It says woof
# We also have dog food
# ====================
# We have a lovely Cat
# It says meow
# We also have cat food
# ====================
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2.工厂方法模式&lt;/h2&gt;

&lt;p&gt;　　工厂方法模式（英语：Factory method pattern）是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”&lt;/p&gt;

&lt;p&gt;　　创建一个对象常常需要复杂的过程，所以不适合包含在一个复合对象中。创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类型的对象。&lt;/p&gt;

&lt;p&gt;　　对象创建中的有些过程包括决定创建哪个对象、管理对象的生命周期，以及管理特定对象的创建和销毁的概念。&lt;/p&gt;

&lt;p&gt;　　如果抛开设计模式的范畴，“工厂方法”这个词也可以指作为“工厂”的方法，这个方法的主要目的就是创建对象，而这个方法不一定在单独的工厂类中。这些方法通常作为静态方法，定义在方法所实例化的类中。&lt;/p&gt;

&lt;p&gt;　　每个工厂方法都有特定的名称。在许多面向对象的编程语言中，构造方法必须和它所在的类具有相同的名称，这样的话，如果有多种创建对象的方式（重载）就可能导致歧义。工厂方法没有这种限制，所以可以具有描述性的名称。举例来说，根据两个实数创建一个复数，而这两个实数表示直角坐标或极坐标，如果使用工厂方法，方法的含义就非常清晰了。当工厂方法起到这种消除歧义的作用时，构造方法常常被设置为私有方法，从而强制客户端代码使用工厂方法创建对象。&lt;/p&gt;

&lt;h3&gt;2.1 Python 源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;https://github.com/faif/python-patterns/&quot;&gt;github:python-patterns&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/&quot;&quot;&quot;


class GreekGetter:

    &quot;&quot;&quot;A simple localizer a la gettext&quot;&quot;&quot;

    def __init__(self):
        self.trans = dict(dog=&quot;σκύλος&quot;, cat=&quot;γάτα&quot;)

    def get(self, msgid):
        &quot;&quot;&quot;We&#39;ll punt if we don&#39;t have a translation&quot;&quot;&quot;
        try:
            return self.trans[msgid]
        except KeyError:
            return str(msgid)


class EnglishGetter:

    &quot;&quot;&quot;Simply echoes the msg ids&quot;&quot;&quot;

    def get(self, msgid):
        return str(msgid)


def get_localizer(language=&quot;English&quot;):
    &quot;&quot;&quot;The factory method&quot;&quot;&quot;
    languages = dict(English=EnglishGetter, Greek=GreekGetter)
    return languages[language]()

# Create our localizers
e, g = get_localizer(language=&quot;English&quot;), get_localizer(language=&quot;Greek&quot;)
# Localize some text
for msgid in &quot;dog parrot cat bear&quot;.split():
    print(e.get(msgid), g.get(msgid))

### OUTPUT ###
# dog σκύλος
# parrot parrot
# cat γάτα
# bear bear
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 单例模式&lt;/h2&gt;

&lt;p&gt;　　单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。&lt;/p&gt;

&lt;p&gt;　　实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。&lt;/p&gt;

&lt;p&gt;　　单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。&lt;/p&gt;

&lt;h3&gt;3.1 Python源码示例&lt;/h3&gt;

&lt;p&gt;　　源码来自&lt;a href=&quot;http://blog.csdn.net/ghostfromheaven/article/details/7671853&quot;&gt;csdn.net&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#-*- encoding=utf-8 -*-
print &#39;----------------------方法1--------------------------&#39;
#方法1,实现__new__方法
#并在将一个类的实例绑定到类变量_instance上,
#如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回
#如果cls._instance不为None,直接返回cls._instance
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, &#39;_instance&#39;):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1

one = MyClass()
two = MyClass()

two.a = 3
print one.a
#3
#one和two完全相同,可以用id(), ==, is检测
print id(one)
#29097904
print id(two)
#29097904
print one == two
#True
print one is two
#True

print &#39;----------------------方法2--------------------------&#39;
#方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)
#同一个类的所有实例天然拥有相同的行为(方法),
#只需要保证同一个类的所有实例具有相同的状态(属性)即可
#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)
#可参看:http://code.activestate.com/recipes/66531/
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1

one = MyClass2()
two = MyClass2()

#one和two是两个不同的对象,id, ==, is对比结果可看出
two.a = 3
print one.a
#3
print id(one)
#28873680
print id(two)
#28873712
print one == two
#False
print one is two
#False
#但是one和two具有相同的（同一个__dict__属性）,见:
print id(one.__dict__)
#30104000
print id(two.__dict__)
#30104000

print &#39;----------------------方法3--------------------------&#39;
#方法3:本质上是方法1的升级（或者说高级）版
#使用__metaclass__（元类）的高级python用法
class Singleton2(type):
    def __init__(cls, name, bases, dict):
        super(Singleton2, cls).__init__(name, bases, dict)
        cls._instance = None
    def __call__(cls, *args, **kw):
        if cls._instance is None:
            cls._instance = super(Singleton2, cls).__call__(*args, **kw)
        return cls._instance

class MyClass3(object):
    __metaclass__ = Singleton2

one = MyClass3()
two = MyClass3()

two.a = 3
print one.a
#3
print id(one)
#31495472
print id(two)
#31495472
print one == two
#True
print one is two
#True

print &#39;----------------------方法4--------------------------&#39;
#方法4:也是方法1的升级（高级）版本,
#使用装饰器(decorator),
#这是一种更pythonic,更elegant的方法,
#单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的
def singleton(cls, *args, **kw):
    instances = {}
    def _singleton():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return _singleton

@singleton
class MyClass4(object):
    a = 1
    def __init__(self, x=0):
        self.x = x

one = MyClass4()
two = MyClass4()

two.a = 3
print one.a
#3
print id(one)
#29660784
print id(two)
#29660784
print one == two
#True
print one is two
#True
one.x = 1
print one.x
#1
print two.x
#1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-11-design-pattern-create-pattern.md.jpg&quot; alt=&quot;2015-03-11-design-pattern-create-pattern.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>IPython 学习</title>
     <link href="/ipython-learning"/>
     <updated>2015-03-10T00:00:00+08:00</updated>
     <id>/ipython-learning</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;　　最近一直在学习spark，延伸到学习IPython，发现IPython这东西还真是不一般啊，所以决定还是应该坐下了认真学习一下。下面都是我在官网上学习时的笔记了。&lt;/p&gt;

&lt;h2&gt;2. 前言&lt;/h2&gt;

&lt;p&gt;　　IPython provides a rich architecture for interactive computing with:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Powerful interactive shells (terminal and Qt-based).&lt;/li&gt;
&lt;li&gt;A browser-based notebook with support for code, text, mathematical expressions, inline plots and other rich media.&lt;/li&gt;
&lt;li&gt;Support for interactive data visualization and use of GUI toolkits.&lt;/li&gt;
&lt;li&gt;Flexible, embeddable interpreters to load into your own projects.&lt;/li&gt;
&lt;li&gt;Easy to use, high performance tools for parallel computing.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　IPython 3.x will be the last monolithic release of IPython, containing the notebook server, qtconsole, etc. The language-agnostic parts of the project: the notebook format, message protocol, qtconsole, notebook web application, etc. will move to new projects under the name Jupyter. IPython itself will return to being focused on interactive Python, part of which will be providing a Python kernel for Jupyter.&lt;/p&gt;

&lt;h2&gt;3. 介绍&lt;/h2&gt;

&lt;p&gt;　　The goal of IPython is to create a comprehensive environment for interactive and exploratory computing. To support this goal, IPython has three main components:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An enhanced interactive Python shell.&lt;/li&gt;
&lt;li&gt;A decoupled two-process communication model, which allows for multiple clients to connect to a computation kernel, most notably the web-based notebook&lt;/li&gt;
&lt;li&gt;An architecture for interactive parallel computing.&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.1 Enhanced interactive Python shell&lt;/h3&gt;

&lt;p&gt;　　看官网。&lt;a href=&quot;http://ipython.org/ipython-doc/stable/overview.html#ipythonzmq&quot;&gt;link&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3.2 Decoupled two-process model&lt;/h3&gt;

&lt;p&gt;　　IPython has abstracted and extended the notion of a traditional Read-Evaluate-Print Loop (REPL) environment by decoupling the evaluation into its own process. We call this process a kernel: it receives execution instructions from clients and communicates the results back to them.&lt;/p&gt;

&lt;p&gt;　　This decoupling allows us to have several clients connected to the same kernel, and even allows clients and kernels to live on different machines. With the exclusion of the traditional single process terminal-based IPython (what you start if you run ipython without any subcommands), all other IPython machinery uses this two-process model. This includes ipython console, ipython qtconsole, and ipython notebook.&lt;/p&gt;

&lt;p&gt;　　As an example, this means that when you start ipython qtconsole, you’re really starting two processes, a kernel and a Qt-based client can send commands to and receive results from that kernel. If there is already a kernel running that you want to connect to, you can pass the --existing flag which will skip initiating a new kernel and connect to the most recent kernel, instead. To connect to a specific kernel once you have several kernels running, use the %connect_info magic to get the unique connection file, which will be something like --existing kernel-19732.json but with different numbers which correspond to the Process ID of the kernel.&lt;/p&gt;

&lt;p&gt;　　You can read more about using ipython qtconsole, and ipython notebook. There is also a message spec which documents the protocol for communication between kernels and clients.&lt;/p&gt;

&lt;p&gt;　　zeppelin也是用了这样的机制的，看来databricks也是这样搞的。关于这个机制，这篇notebook有简单的&lt;a href=&quot;http://nbviewer.ipython.org/github/ipython/ipython/blob/1.x/examples/notebooks/Frontend-Kernel%20Model.ipynb&quot;&gt;描述&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;3.3 Interactive parallel computing&lt;/h3&gt;

&lt;p&gt;　　看官网。&lt;/p&gt;

&lt;h2&gt;4. 安装&lt;/h2&gt;

&lt;p&gt;　　还是看&lt;a href=&quot;../http://ipython.org/ipython-doc/stable/install/install.html&quot;&gt;官网&lt;/a&gt;有用，主要还是要解决依赖的问题，最好的方法就是 pip install &quot;ipython[all]&quot;。&lt;/p&gt;

&lt;h2&gt;5. Using IPython for interactive work&lt;/h2&gt;

&lt;h3&gt;5.1 Introducing IPython&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;常用的四个帮助方法：

&lt;ul&gt;
&lt;li&gt;? ：  Introduction and overview of IPython’s features.&lt;/li&gt;
&lt;li&gt;%quickref ：  Quick reference.&lt;/li&gt;
&lt;li&gt;help ：   Python’s own help system.&lt;/li&gt;
&lt;li&gt;object? ： Details about ‘object’, use ‘object??’ for extra details.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;　　Typing object_name? will print all sorts of details about any object, including docstrings, function definition lines (for call arguments) and constructor details for classes. To get specific information on an object, you can use the magic commands %pdoc, %pdef, %psource and %pfile&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configuration&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Much of IPython can be tweaked through configuration. To get started, use the command ipython profile create to produce the default config files. These will be placed in ~/.ipython/profile_default, and contain comments explaining what the various options do.&lt;/p&gt;

&lt;p&gt;Profiles allow you to use IPython for different tasks, keeping separate config files and history for each one. More details in the profiles section.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Startup Files&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If you want some code to be run at the beginning of every IPython session, the easiest way is to add Python (.py) or IPython (.ipy) scripts to your profile_default/startup/ directory. Files here will be executed as soon as the IPython shell is constructed, before any other code or scripts you have specified. The files will be run in order of their names, so you can control the ordering with prefixes, like 10-myimports.py.&lt;/p&gt;

&lt;h3&gt;5.2 IPython reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Command-line usage&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;You start IPython with the command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ipython [options] files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If invoked with no options, it executes all the files listed in sequence and drops you into the interpreter while still acknowledging any options you may have set in your ipython_config.py. This behavior is different from standard Python, which when called as python -i will only execute one file and ignore your configuration setup.&lt;/p&gt;

&lt;p&gt;Please note that some of the configuration options are not available at the command line, simply because they are not practical here. Look into your configuration files for details on those. There are separate configuration files for each profile, and the files look like ipython_config.py or ipython_config_frontendname.py. Profile directories look like profile_profilename and are typically installed in the IPYTHONDIR directory, which defaults to $HOME/.ipython. For Windows users, HOME resolves to C:\Users\YourUserName in most instances.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IPython as your default Python environment&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Python honors the environment variable PYTHONSTARTUP and will execute at startup the file referenced by this variable. If you put the following code at the end of that file, then IPython will be your working environment anytime you start Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import os, IPython
os.environ[&#39;PYTHONSTARTUP&#39;] = &#39;&#39;  # Prevent running this again
IPython.start_ipython()
raise SystemExit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The raise SystemExit is needed to exit Python when it finishes, otherwise you’ll be back at the normal Python &gt;&gt;&gt; prompt.&lt;/p&gt;

&lt;p&gt;This is probably useful to developers who manage multiple Python versions and don’t want to have correspondingly multiple IPython versions. Note that in this mode, there is no way to pass IPython any command-line options, as those are trapped first by Python itself.&lt;/p&gt;

&lt;h2&gt;6. The IPython notebook&lt;/h2&gt;

&lt;h3&gt;6.1 Running a notebook server&lt;/h3&gt;

&lt;p&gt;The IPython notebook web-application is based on a server-client structure. This server uses a &lt;strong&gt;&lt;em&gt;two-process kernel architecture&lt;/em&gt;&lt;/strong&gt; based on &lt;strong&gt;&lt;em&gt;ZeroMQ&lt;/em&gt;&lt;/strong&gt;, as well as &lt;strong&gt;&lt;em&gt;Tornado&lt;/em&gt;&lt;/strong&gt; for serving HTTP requests. By default, a notebook server runs on http://127.0.0.1:8888/ and is accessible only from localhost. This document describes how you can secure a notebook server and how to run it on a public interface.&lt;/p&gt;

&lt;h2&gt;7. Using IPython for parallel computing&lt;/h2&gt;

&lt;p&gt;目前研究的方向和IPython自身的parallel关联不大，暂时不看这块。&lt;/p&gt;

&lt;h2&gt;8. Configuration and customization&lt;/h2&gt;

&lt;h3&gt;8.1 Serveral config methods&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Config files&lt;/li&gt;
&lt;li&gt;Command line arguments&lt;/li&gt;
&lt;li&gt;The config magics&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;8.2 IPython options&lt;/h3&gt;

&lt;p&gt;重点研究notebook options和kernel options，细节用到时再仔细看。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Terminal IPython options&lt;/li&gt;
&lt;li&gt;IPython kernel options&lt;/li&gt;
&lt;li&gt;IPython notebook options&lt;/li&gt;
&lt;li&gt;IPython Qt console options&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;8.3 IPython extensions&lt;/h3&gt;

&lt;p&gt;A level above configuration are IPython extensions, Python modules which modify the behaviour of the shell. They are referred to by an importable module name, and can be placed anywhere you’d normally import from, or in .ipython/extensions/.&lt;/p&gt;

&lt;p&gt;Getting extensions
A few important extensions are bundled with IPython. Others can be found on the extensions index on the wiki, and the Framework :: IPython tag on PyPI.&lt;/p&gt;

&lt;p&gt;Extensions on PyPI can be installed using pip, like any other Python package. Other simple extensions can be installed with the %install_ext magic. The latter does no validation, so be careful using it on untrusted networks like public wifi.&lt;/p&gt;

&lt;p&gt;Using extensions
To load an extension while IPython is running, use the %load_ext magic:
&lt;code&gt;
In [1]: %load_ext myextension
&lt;/code&gt;
To load it each time IPython starts, list it in your configuration file:
&lt;code&gt;
c.InteractiveShellApp.extensions = [
    &#39;myextension&#39;
]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Writing extensions
An IPython extension is an importable Python module that has a couple of special functions to load and unload it. Here is a template:
```&lt;/p&gt;

&lt;h1&gt;myextension.py&lt;/h1&gt;

&lt;p&gt;def load_ipython_extension(ipython):
    # The &lt;code&gt;ipython&lt;/code&gt; argument is the currently active &lt;code&gt;InteractiveShell&lt;/code&gt;
    # instance, which can be used in any way. This allows you to register
    # new magics or aliases, for example.&lt;/p&gt;

&lt;p&gt;def unload_ipython_extension(ipython):
    # If you want your extension to be unloadable, put that logic here.
```
This load_ipython_extension() function is called after your extension is imported, and the currently active InteractiveShell instance is passed as the only argument. You can do anything you want with IPython at that point.&lt;/p&gt;

&lt;p&gt;load_ipython_extension() will be called again if you load or reload the extension again. It is up to the extension author to add code to manage that.&lt;/p&gt;

&lt;p&gt;Useful InteractiveShell methods include register_magic_function(), push() (to add variables to the user namespace) and drop_by_id() (to remove variables on unloading).&lt;/p&gt;

&lt;p&gt;My extensions dir:
/root/anaconda/lib/python2.7/site-packages/IPython/entensions/&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Defining custom magics&lt;/strong&gt;
There are two main ways to define your own magic functions: from standalone functions and by inheriting from a base class provided by IPython: IPython.core.magic.Magics. Below we show code you can place in a file that you load from your configuration, such as any file in the startup subdirectory of your default IPython profile.&lt;/p&gt;

&lt;p&gt;First, let us see the simplest case. The following shows how to create a line magic, a cell one and one that works in both modes, using just plain functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from IPython.core.magic import (register_line_magic, register_cell_magic,
                                register_line_cell_magic)

@register_line_magic
def lmagic(line):
    &quot;my line magic&quot;
    return line

@register_cell_magic
def cmagic(line, cell):
    &quot;my cell magic&quot;
    return line, cell

@register_line_cell_magic
def lcmagic(line, cell=None):
    &quot;Magic that works both as %lcmagic and as %%lcmagic&quot;
    if cell is None:
        print(&quot;Called as line magic&quot;)
        return line
    else:
        print(&quot;Called as cell magic&quot;)
        return line, cell

# We delete these to avoid name conflicts for automagic to work
del lmagic, lcmagic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also create magics of all three kinds by inheriting from the IPython.core.magic.Magics class. This lets you create magics that can potentially hold state in between calls, and that have full access to the main IPython object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This code can be put in any Python module, it does not require IPython
# itself to be running already.  It only creates the magics subclass but
# doesn&#39;t instantiate it yet.
from __future__ import print_function
from IPython.core.magic import (Magics, magics_class, line_magic,
                                cell_magic, line_cell_magic)

# The class MUST call this class decorator at creation time
@magics_class
class MyMagics(Magics):

    @line_magic
    def lmagic(self, line):
        &quot;my line magic&quot;
        print(&quot;Full access to the main IPython object:&quot;, self.shell)
        print(&quot;Variables in the user namespace:&quot;, list(self.shell.user_ns.keys()))
        return line

    @cell_magic
    def cmagic(self, line, cell):
        &quot;my cell magic&quot;
        return line, cell

    @line_cell_magic
    def lcmagic(self, line, cell=None):
        &quot;Magic that works both as %lcmagic and as %%lcmagic&quot;
        if cell is None:
            print(&quot;Called as line magic&quot;)
            return line
        else:
            print(&quot;Called as cell magic&quot;)
            return line, cell


# In order to actually use these magics, you must register them with a
# running IPython.  This code must be placed in a file that is loaded once
# IPython is up and running:
ip = get_ipython()
# You can register the class itself without instantiating it.  IPython will
# call the default constructor on it.
ip.register_magics(MyMagics)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to create a class with a different constructor that holds additional state, then you should always call the parent constructor and instantiate the class yourself before registration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@magics_class
class StatefulMagics(Magics):
    &quot;Magics that hold additional state&quot;

    def __init__(self, shell, data):
        # You must call the parent constructor
        super(StatefulMagics, self).__init__(shell)
        self.data = data

    # etc...

# This class must then be registered with a manually created instance,
# since its constructor has different arguments from the default:
ip = get_ipython()
magics = StatefulMagics(ip, some_data)
ip.register_magics(magics)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In earlier versions, IPython had an API for the creation of line magics (cell magics did not exist at the time) that required you to create functions with a method-looking signature and to manually pass both the function and the name. While this API is no longer recommended, it remains indefinitely supported for backwards compatibility purposes. With the old API, you’d create a magic as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def func(self, line):
    print(&quot;Line magic called with line:&quot;, line)
    print(&quot;IPython object:&quot;, self.shell)

ip = get_ipython()
# Declare this function as the magic %mycommand
ip.define_magic(&#39;mycommand&#39;, func)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;9. IPython developer’s guide&lt;/h2&gt;

&lt;p&gt;This are two categories of developer focused documentation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Documentation for developers of IPython itself.&lt;/li&gt;
&lt;li&gt;Documentation for developers of third party tools and libraries that use IPython.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This part of our documentation only contains information in the second category.&lt;/p&gt;

&lt;p&gt;Developers interested in working on IPython itself should consult our developer information on the IPython GitHub wiki.&lt;/p&gt;

&lt;h2&gt;10 How IPython works&lt;/h2&gt;

&lt;h3&gt;10.1 Terminal IPython&lt;/h3&gt;

&lt;p&gt;When you type ipython, you get the original IPython interface, running in the terminal. It does something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while True:
    code = input(&quot;&amp;gt;&amp;gt;&amp;gt; &quot;)
    exec(code)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, it’s much more complex, because it has to deal with multi-line code, tab completion using readline, magic commands, and so on. But the model is like that: prompt the user for some code, and when they’ve entered it, exec it in the same process. This model is often called a REPL, or Read-Eval-Print-Loop.&lt;/p&gt;

&lt;h3&gt;10.2 The IPython Kernel&lt;/h3&gt;

&lt;p&gt;All the other interfaces—the Notebook, the Qt console, ipython console in the terminal, and third party interfaces—use the IPython Kernel. This is a separate process which is responsible for running user code, and things like computing possible completions. Frontends communicate with it using JSON messages sent over ZeroMQ sockets; the protocol they use is described in Messaging in IPython.&lt;/p&gt;

&lt;p&gt;The core execution machinery for the kernel is shared with terminal IPython:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/ipy_kernel_and_terminal.png&quot; alt=&quot;ipy_kernel_and_terminal.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A kernel process can be connected to more than one frontend simultaneously. In this case, the different frontends will have access to the same variables.&lt;/p&gt;

&lt;p&gt;This design was intended to allow easy development of different frontends based on the same kernel, but it also made it possible to support new languages in the same frontends, by developing kernels in those languages, and we are refining IPython to make that more practical.&lt;/p&gt;

&lt;p&gt;Today, there are two ways to develop a kernel for another language. Wrapper kernels reuse the communications machinery from IPython, and implement only the core execution part. Native kernels implement execution and communications in the target language:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/other_kernels.png&quot; alt=&quot;other_kernels.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Wrapper kernels are easier to write quickly for languages that have good Python wrappers, like octave_kernel, or languages where it’s impractical to implement the communications machinery, like bash_kernel. Native kernels are likely to be better maintained by the community using them, like IJulia or IHaskell.&lt;/p&gt;

&lt;h3&gt;10.3 Notebook&lt;/h3&gt;

&lt;p&gt;The Notebook frontend does something extra. In addition to running your code, it stores code and output, together with markdown notes, in an editable document called a notebook. When you save it, this is sent from your browser to the notebook server, which saves it on disk as a JSON file with a .ipynb extension.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/notebook_components.png&quot; alt=&quot;notebook_components.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The notebook server, not the kernel, is responsible for saving and loading notebooks, so you can edit notebooks even if you don’t have the kernel for that language—you just won’t be able to run code. The kernel doesn’t know anything about the notebook document: it just gets sent cells of code to execute when the user runs them.&lt;/p&gt;

&lt;p&gt;The Nbconvert tool in IPython converts notebook files to other formats, such as HTML, LaTeX, or reStructuredText. This conversion goes through a series of steps:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/nbconvert.png&quot; alt=&quot;nbconvert.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preprocessors modify the notebook in memory. E.g. ExecutePreprocessor runs the code in the notebook and updates the output.&lt;/li&gt;
&lt;li&gt;An exporter converts the notebook to another file format. Most of the exporters use templates for this.&lt;/li&gt;
&lt;li&gt;Postprocessors work on the file produced by exporting.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The nbviewer website uses nbconvert with the HTML exporter. When you give it a URL, it fetches the notebook from that URL, converts it to HTML, and serves that HTML to you.&lt;/p&gt;

&lt;h2&gt;11. Messaging in IPython&lt;/h2&gt;

&lt;p&gt;The IPython message specification is versioned independently of IPython. The current version of the specification is 5.0.&lt;/p&gt;

&lt;h3&gt;11.1 Introduction&lt;/h3&gt;

&lt;p&gt;This document explains the basic communications design and messaging specification for how the various IPython objects interact over a network transport. The current implementation uses the ZeroMQ library for messaging within and between hosts.&lt;/p&gt;

&lt;p&gt;The basic design is explained in the following diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/frontend-kernel.png&quot; alt=&quot;frontend-kernel.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A single kernel can be simultaneously connected to one or more frontends. The kernel has three sockets that serve the following functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Shell: this single ROUTER socket allows multiple incoming connections from frontends, and this is the socket where requests for code execution, object information, prompts, etc. are made to the kernel by any frontend. The communication on this socket is a sequence of request/reply actions from each frontend and the kernel.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IOPub: this socket is the ‘broadcast channel’ where the kernel publishes all side effects (stdout, stderr, etc.) as well as the requests coming from any client over the shell socket and its own requests on the stdin socket. There are a number of actions in Python which generate side effects: print() writes to sys.stdout, errors generate tracebacks, etc. Additionally, in a multi-client scenario, we want all frontends to be able to know what each other has sent to the kernel (this can be useful in collaborative scenarios, for example). This socket allows both side effects and the information about communications taking place with one client over the shell channel to be made available to all clients in a uniform manner.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stdin: this ROUTER socket is connected to all frontends, and it allows the kernel to request input from the active frontend when raw_input() is called. The frontend that executed the code has a DEALER socket that acts as a ‘virtual keyboard’ for the kernel while this communication is happening (illustrated in the figure by the black outline around the central keyboard). In practice, frontends may display such kernel requests using a special input widget or otherwise indicating that the user is to type input for the kernel instead of normal commands in the frontend. &lt;br/&gt;
All messages are tagged with enough information (details below) for clients to know which messages come from their own interaction with the kernel and which ones are from other clients, so they can display each type appropriately.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Control: This channel is identical to Shell, but operates on a separate socket, to allow important messages to avoid queueing behind execution requests (e.g. shutdown or abort).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The actual format of the messages allowed on each of these channels is specified below. Messages are dicts of dicts with string keys and values that are reasonably representable in JSON. Our current implementation uses JSON explicitly as its message format, but this shouldn’t be considered a permanent feature. As we’ve discovered that JSON has non-trivial performance issues due to excessive copying, we may in the future move to a pure pickle-based raw message format. However, it should be possible to easily convert from the raw objects to JSON, since we may have non-python clients (e.g. a web frontend). As long as it’s easy to make a JSON version of the objects that is a faithful representation of all the data, we can communicate with such clients.&lt;/p&gt;

&lt;h3&gt;11.2 General Message Format&lt;/h3&gt;

&lt;p&gt;A message is defined by the following four-dictionary structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  # The message header contains a pair of unique identifiers for the
  # originating session and the actual message id, in addition to the
  # username for the process that generated the message.  This is useful in
  # collaborative settings where multiple users may be interacting with the
  # same kernel simultaneously, so that frontends can label the various
  # messages in a meaningful way.
  &#39;header&#39; : {
                &#39;msg_id&#39; : uuid,
                &#39;username&#39; : str,
                &#39;session&#39; : uuid,
                # All recognized message type strings are listed below.
                &#39;msg_type&#39; : str,
                # the message protocol version
                &#39;version&#39; : &#39;5.0&#39;,
     },

  # In a chain of messages, the header from the parent is copied so that
  # clients can track where messages come from.
  &#39;parent_header&#39; : dict,

  # Any metadata associated with the message.
  &#39;metadata&#39; : dict,

  # The actual content of the message must be a dict, whose structure
  # depends on the message type.
  &#39;content&#39; : dict,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;12. Making kernels for IPython&lt;/h2&gt;

&lt;p&gt;A ‘kernel’ is a program that runs and introspects the user’s code. IPython includes a kernel for Python code, and people have written kernels for several other languages.&lt;/p&gt;

&lt;p&gt;When IPython starts a kernel, it passes it a connection file. This specifies how to set up communications with the frontend.&lt;/p&gt;

&lt;p&gt;There are two options for writing a kernel:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You can reuse the IPython kernel machinery to handle the communications, and just describe how to execute your code. This is much simpler if the target language can be driven from Python. See Making simple Python wrapper kernels for details.&lt;/li&gt;
&lt;li&gt;You can implement the kernel machinery in your target language. This is more work initially, but the people using your kernel might be more likely to contribute to it if it’s in the language they know.&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;. 学习资源&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ipython.org/&quot;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ipython/ipython/wiki?path=Cookbook&quot;&gt;IPython Cookbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-10-ipython-learning.md.jpg&quot; alt=&quot;2015-03-10-ipython-learning.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>book-3. 设计模式总结</title>
     <link href="/design-pattern"/>
     <updated>2015-03-09T00:00:00+08:00</updated>
     <id>/design-pattern</id>
     <content type="html">&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 设计模式概念&lt;/h2&gt;

&lt;p&gt;　　设计模式这个术语是由Erich Gamma等人在1990年代从建筑设计领域引入到计算机科学的。它是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。 &lt;br/&gt;
　　设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。 &lt;br/&gt;
　　并非所有的软件模式都是设计模式，设计模式特指软件“设计”层次上的问题。还有其它非设计模式的模式，如架构模式。同时，算法不能算是一种设计模式，因为算法主要是用来解决计算上的问题，而非设计上的问题。&lt;/p&gt;

&lt;h2&gt;2. 模式分类&lt;/h2&gt;

&lt;p&gt;　　《设计模式》一书把设计模式分为创建型、结构性、行为型三大模式。把它们通过授权，聚合，诊断的概念来描述。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建型模式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;抽象工厂：为一个产品族提供了统一的创建接口，当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。&lt;/li&gt;
&lt;li&gt;工厂方法：定义一个接口用于创建对象，但是让子类觉得初始化那个类。工厂方法把一个类的初始化下方到子类。&lt;/li&gt;
&lt;li&gt;生成器：讲一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/li&gt;
&lt;li&gt;惰性初始：推迟对象的创建，数据的计算等需要耗费较多资源的操作，只有在第一次访问的时候才执行。&lt;/li&gt;
&lt;li&gt;对象池：通过回收利用对象避免获取和释放资源所需的昂贵成本。&lt;/li&gt;
&lt;li&gt;原型：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/li&gt;
&lt;li&gt;单例：确保一个类只有一个实例，并提供对该实例的全局访问。&lt;/li&gt;
&lt;li&gt;多例：确保一个类只有命名的实例，并提供对这些实例的全局访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结构型模式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;适配器：将某个类的接口转化为客户端期望的另一个接口表示，适配器模式可以消除由于接口不匹配所造成的类兼容性问题。&lt;/li&gt;
&lt;li&gt;桥接：将一个抽象与实现解耦，以便两者可以独立地变化。&lt;/li&gt;
&lt;li&gt;组合：把多个对象组成树状结构来表示局部与整体，这样用户可以一样地对待单个对象和对象的组合。&lt;/li&gt;
&lt;li&gt;修饰：向某个对象动态地添加更多的功能，修饰模式是除类继承之外另一种扩展功能的方法。&lt;/li&gt;
&lt;li&gt;外观模式：为子系统的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/li&gt;
&lt;li&gt;享元：通过共享以便有效地支持大量小颗粒对象。&lt;/li&gt;
&lt;li&gt;代理：为其他对象提供一个代理以控制这个对象的访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;行为型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;责任链：为接触请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。&lt;/li&gt;
&lt;li&gt;命令：将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化，对请求排队或者记录请求日志，以及支持可取消的操作。&lt;/li&gt;
&lt;li&gt;解释器：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。&lt;/li&gt;
&lt;li&gt;迭代器：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/li&gt;
&lt;li&gt;备忘录：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象，备忘录模式的用意是在不破坏封装的条件下，讲一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。&lt;/li&gt;
&lt;li&gt;观察者：在对象间定义一个一对多的联系性，由此当一个对象改变了状态，所有其他相关的对象会被通知并且自动更新。&lt;/li&gt;
&lt;li&gt;策略：定义一个算法的系列，将其各个分装，并且使他们有交互性，策略模式使得算法在用户使用的时候能独立地改变。&lt;/li&gt;
&lt;li&gt;模板方法：模板方法模式准备一个抽象类，将部分逻辑以具体的方法及具体构造子类的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先构建一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。&lt;/li&gt;
&lt;li&gt;访问者：封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结果和作用于结构上的操作之间的耦合解开，使得操作集合可以相对自由的演化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. 2/8原则&lt;/h2&gt;

&lt;p&gt;　　本着2/8原则的指导，准备先仔细了解学习以下几种最常用的模式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建型模式：抽象工厂，工厂方法，单例模式；&lt;/li&gt;
&lt;li&gt;结构性模式：适配器，桥接，组合，修饰，外观；&lt;/li&gt;
&lt;li&gt;行为型模式：迭代器，观察者，模板，策略；&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;扫一扫&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../images/share/2015-03-09-design-pattern.md.jpg&quot; alt=&quot;2015-03-09-design-pattern.md&quot; /&gt;&lt;/p&gt;
</content>
   </entry>
   

</feed>


</body>
</html>
