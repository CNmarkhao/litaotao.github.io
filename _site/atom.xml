<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

   <title>Taotao's Zone</title>
   <link href="http://litaotao.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://litaotao.github.io" rel="alternate" type="text/html" />
   <updated>2014-11-05T00:00:38+08:00</updated>
   <id>http://litaotao.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>解读 Erlang lists 源码</title>
     <link href="/erlang-lists-source-code"/>
     <updated>2014-10-31T00:00:00+08:00</updated>
     <id>/erlang-lists-source-code</id>
     <content type="html">&lt;h2&gt;捡下面这些重点的说&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;1. 属性说明&lt;/strong&gt;  &lt;br/&gt;
&lt;strong&gt;2. keyfind/3&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;3. suffix/2&lt;/strong&gt;   &lt;br/&gt;
&lt;strong&gt;4. seq/2, seq/3&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;5. sort/1&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;&lt;/h2&gt;

&lt;h2&gt;1. 属性说明&lt;/h2&gt;

&lt;p&gt;　　源文件里注明了 &lt;code&gt;-compile({no_auto_import, [max/2]}).&lt;/code&gt;，这是一个预定义的模块属性【预定义的模块属性有以下四种：&lt;code&gt;module，import，export，compile，vsn&lt;/code&gt;】。其中&lt;code&gt;-compile(Options)&lt;/code&gt;是将Options添加到编译器选项表中，Options可以是单个原子，也可以是一个列表。这里的&lt;code&gt;no_auto_import&lt;/code&gt;是说函数max/2不要自动从erlang模块里导出了，这是为了解决内置函数冲突。没听明白吧，ok，下面详细讲讲这个。至于模块属性，详见《Erlang程序设计》第二版，8.4节；有关compile选项，请移步&lt;a href=&quot;http://erlang.org/doc/man/compile.html&quot;&gt;http://erlang.org/doc/man/compile.html&lt;/a&gt;。&lt;br/&gt;
　　首先，什么叫自动导出：easy，自动导出就是你不加模块前缀就可以运行的函数。平常使用模块函数不都是模块名:函数名的吗。比如说我们要使用erlang模块里的max函数，一般都是erlang:max这样使用。so，顾名思义，如果max函数在erlang里是自动导出的，那我猜想我们可以直接在console里运行max函数了，而且注意，在console里不加模块名直接运行的max函数一定是定义在erlang这个模块里面的。猜想一下，如果含有其他模块【假定为erl】也定义了一个max函数，并且也自动导出了，那当你直接运行max函数时，erlang虚拟机是该运行erl里的max呢还是erlang里的max呢。&lt;br/&gt;
　　好的，简单测试下，直接看代码得了:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop/erlcode# erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; erlang:max(1,2).
2
2&amp;gt; max(1,2).
2
3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　现在，这个问题解决了，那我们来看看，为什么在lists模块里要阻止max/2自动导入呢。just think it，就和我上面说的一样，防止自动导出的核心是什么？不就是为了防止函数冲突吗？so，我猜想我们lists.erl模块里也有一个max/2函数，而且这个max/2函数的实现必须是和erlang模块里的实现是不同的。CTRL+F查找，果然不出所料：　　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%% max(L) -&amp;gt; returns the maximum element of the list L

-spec max(List) -&amp;gt; Max when
      List :: [T,...],
      Max :: T,
      T :: term().

max([H|T]) -&amp;gt; max(T, H).

max([H|T], Max) when H &amp;gt; Max -&amp;gt; max(T, H);
max([_|T], Max)              -&amp;gt; max(T, Max);
max([],    Max)              -&amp;gt; Max.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　好了，到这里关于模块预定义属性就差不多了，以后遇到了再慢慢补上。&lt;/p&gt;

&lt;h2&gt;2. keyfind/3&lt;/h2&gt;

&lt;p&gt; 　　lists里的&lt;code&gt;keyfind/3, keymember/3, keysearch/3, member/2, reverse/2&lt;/code&gt;都是通过内置函数实现的，源码都在erl_bif_types.erl这个文件里面。在keyfind/3的定义中，看到了pos_integer()这样一个变量类型，看来基础还是不行啊，没办法，大家有空都来这里补补基础吧。&lt;a href=&quot;http://www.erlang.org/doc/reference_manual/typespec.html&quot;&gt;7 Types and Function Specifications&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3. suffix/2&lt;/h2&gt;

&lt;p&gt;　　之所以要介绍suffix，是想借suffix来简单介绍一下Erlang里的布尔表达式和所谓的短路布尔表达式。函数定义和实现如下，检查Suffix是否是List的后缀。实现就用了两行，真是精湛啊，突然发现其实很多操作不用循环也能很清楚的表达了。&lt;br/&gt;
　　这里的 andalso 叫做短路布尔表达式，其含义是指 &lt;code&gt;Expr1 andalso Expr2&lt;/code&gt; 这样一个表达式只有在Expr1为真的情况下才会执行Expr2。同样可以理解一下orelse这个短路布尔表达式。而普通的布尔表达式和其他语言里一样的，not, and, or, xor。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;&quot;&gt;%% suffix(Suffix, List) -&amp;gt; (true | false)

-spec suffix(List1, List2) -&amp;gt; boolean() when
      List1 :: [T],
      List2 :: [T],
      T :: term().

suffix(Suffix, List) -&amp;gt;
    Delta = length(List) - length(Suffix),
    Delta &amp;gt;= 0 andalso nthtail(Delta, List) =:= Suffix.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. seq/2&lt;/h2&gt;

&lt;p&gt;　　seq/2是一个高级接口，调用了一个三参数的接口&lt;code&gt;seq_loop(N, X, L)&lt;/code&gt;，如下，其中N=Last-First+1，是需要生成的长度，X=Last，是最后一个元素的值，L是一个空列表[]，将结果保存到第三个参数L中，最后再返回它。而生成这个列表的方法确实很高效，要么一次生成4个数，要么一次生成2个数，要么生成一个数或者直接返回结果。而实际应用中，大多数情况应该都是一次生成4个数，然后可能会调用1到2次一次生成2个数，最后要么直接返回结果，要么就再生成1个数后再返回结果。极为高效！我又想起了Python里相似的range函数，过两天看看Python里是怎么实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec seq(From, To) -&amp;gt; Seq when
      From :: integer(),
      To :: integer(),
      Seq :: [integer()].

seq(First, Last)
    when is_integer(First), is_integer(Last), First-1 =&amp;lt; Last -&amp;gt;
    seq_loop(Last-First+1, Last, []).

seq_loop(N, X, L) when N &amp;gt;= 4 -&amp;gt;
     seq_loop(N-4, X-4, [X-3,X-2,X-1,X|L]);
seq_loop(N, X, L) when N &amp;gt;= 2 -&amp;gt;
     seq_loop(N-2, X-2, [X-1,X|L]);
seq_loop(1, X, L) -&amp;gt;
     [X|L];
seq_loop(0, _, L) -&amp;gt;
     L.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. sort/1&lt;/h2&gt;

&lt;p&gt;　　sort函数是必须要学习学习的拉，第一次看到sort的源码确实是lists里挺长的了，好了，来分析分析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec sort(List1) -&amp;gt; List2 when
      List1 :: [T],
      List2 :: [T],
      T :: term().

sort([X, Y | L] = L0) when X =&amp;lt; Y -&amp;gt;
    case L of
  [] -&amp;gt; 
      L0;
  [Z] when Y =&amp;lt; Z -&amp;gt;
      L0;
  [Z] when X =&amp;lt; Z -&amp;gt;
      [X, Z, Y];
  [Z] -&amp;gt;
      [Z, X, Y];
  _ when X == Y -&amp;gt;
      sort_1(Y, L, [X]);
  _ -&amp;gt;
      split_1(X, Y, L, [], [])
    end;
sort([X, Y | L]) -&amp;gt;
    case L of
  [] -&amp;gt;
      [Y, X];
  [Z] when X =&amp;lt; Z -&amp;gt;
      [Y, X | L];
  [Z] when Y =&amp;lt; Z -&amp;gt;
      [Y, Z, X];
  [Z] -&amp;gt;
      [Z, Y, X];
  _ -&amp;gt;
      split_2(X, Y, L, [], [])
    end;
sort([_] = L) -&amp;gt;
    L;
sort([] = L) -&amp;gt;
    L.

sort_1(X, [Y | L], R) when X == Y -&amp;gt;
    sort_1(Y, L, [X | R]);
sort_1(X, [Y | L], R) when X &amp;lt; Y -&amp;gt;
    split_1(X, Y, L, R, []);
sort_1(X, [Y | L], R) -&amp;gt;
    split_2(X, Y, L, R, []);
sort_1(X, [], R) -&amp;gt;
    lists:reverse(R, [X]).

%% sort/1

%% Ascending.
split_1(X, Y, [Z | L], R, Rs) when Z &amp;gt;= Y -&amp;gt;
    split_1(Y, Z, L, [X | R], Rs);
split_1(X, Y, [Z | L], R, Rs) when Z &amp;gt;= X -&amp;gt;
    split_1(Z, Y, L, [X | R], Rs);
split_1(X, Y, [Z | L], [], Rs) -&amp;gt;
    split_1(X, Y, L, [Z], Rs);
split_1(X, Y, [Z | L], R, Rs) -&amp;gt;
    split_1_1(X, Y, L, R, Rs, Z);
split_1(X, Y, [], R, Rs) -&amp;gt;
    rmergel([[Y, X | R] | Rs], []).

split_1_1(X, Y, [Z | L], R, Rs, S) when Z &amp;gt;= Y -&amp;gt;
    split_1_1(Y, Z, L, [X | R], Rs, S);
split_1_1(X, Y, [Z | L], R, Rs, S) when Z &amp;gt;= X -&amp;gt;
    split_1_1(Z, Y, L, [X | R], Rs, S);
split_1_1(X, Y, [Z | L], R, Rs, S) when S =&amp;lt; Z -&amp;gt;
    split_1(S, Z, L, [], [[Y, X | R] | Rs]);
split_1_1(X, Y, [Z | L], R, Rs, S) -&amp;gt;
    split_1(Z, S, L, [], [[Y, X | R] | Rs]);
split_1_1(X, Y, [], R, Rs, S) -&amp;gt;
    rmergel([[S], [Y, X | R] | Rs], []).

%% Descending.
split_2(X, Y, [Z | L], R, Rs) when Z =&amp;lt; Y -&amp;gt;
    split_2(Y, Z, L, [X | R], Rs);
split_2(X, Y, [Z | L], R, Rs) when Z =&amp;lt; X -&amp;gt;
    split_2(Z, Y, L, [X | R], Rs);
split_2(X, Y, [Z | L], [], Rs) -&amp;gt;
    split_2(X, Y, L, [Z], Rs);
split_2(X, Y, [Z | L], R, Rs) -&amp;gt;
    split_2_1(X, Y, L, R, Rs, Z);
split_2(X, Y, [], R, Rs) -&amp;gt;
    mergel([[Y, X | R] | Rs], []).

split_2_1(X, Y, [Z | L], R, Rs, S) when Z =&amp;lt; Y -&amp;gt;
    split_2_1(Y, Z, L, [X | R], Rs, S);
split_2_1(X, Y, [Z | L], R, Rs, S) when Z =&amp;lt; X -&amp;gt;
    split_2_1(Z, Y, L, [X | R], Rs, S);
split_2_1(X, Y, [Z | L], R, Rs, S) when S &amp;gt; Z -&amp;gt;
    split_2(S, Z, L, [], [[Y, X | R] | Rs]);
split_2_1(X, Y, [Z | L], R, Rs, S) -&amp;gt;
    split_2(Z, S, L, [], [[Y, X | R] | Rs]);
split_2_1(X, Y, [], R, Rs, S) -&amp;gt;
    mergel([[S], [Y, X | R] | Rs], []).  
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>深度分析 Erlang Application 行为</title>
     <link href="/deep-into-erlang-application"/>
     <updated>2014-10-21T00:00:00+08:00</updated>
     <id>/deep-into-erlang-application</id>
     <content type="html">&lt;h2&gt;1. 从我在Erlang and OTP in Action中第六章中的错误说起&lt;/h2&gt;

&lt;p&gt;　　前两天看EOIA这本书，觉得终于可以用Erlang来搞点东西玩了，于是决定按照书中流程来实践一下所谓的缓存系统。
谨慎起见，我还是半抄半写把simple_cache的源码写好了，当前目录结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chenshan@mac007 6-EOIA$tree
.
├── ebin
│   ├── prim_consult.beam
│   ├── sc_app.beam
│   ├── sc_element.beam
│   ├── sc_store.beam
│   ├── sc_sup.beam
│   ├── simple_cache.app
│   └── simple_cache.beam
└── src
    ├── prim_consult.beam
    ├── prim_consult.erl
    ├── sc_app.erl
    ├── sc_element.erl
    ├── sc_store.erl
    ├── sc_sup.erl
    └── simple_cache.erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;小提示：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1、要把src目录下的erl源文件编译，并把编译后的beam文件放到ebin下有一个快捷的方法，在当前目录下执行：erlc -o ebin/ src/*.erl；&lt;br/&gt;
2、上面出现的prim_consult.erl和prim_consult.beam不用管，后面会提到的，这是我阅读application源码时提取出来的；&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;　　然后进入ebin目录，打开erlang执行环境，用application:start(simple_cache).启动我们的缓存系统，opps，这个时候就出错了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chenshan@mac007 6-EOIA$cd ebin/
chenshan@mac007 ebin$erl
Erlang/OTP 17 [erts-6.1] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.1  (abort with ^G)
1&amp;gt; application:start(simple_cache).  
{error,
    {bad_return,
        {
        {sc_app,start,[normal,[]]},
         {&#39;EXIT&#39;,
             {undef,
                 [{sr_store,init,[],[]},
                  {sc_app,start,2,[{file,&quot;../src/sc_app.erl&quot;},{line,6}]},
                  {application_master,start_supervisor,3,
                      [{file,&quot;application_master.erl&quot;},{line,326}]},
                  {application_master,start_the_app,5,
                      [{file,&quot;application_master.erl&quot;},{line,308}]},
                  {application_master,start_it_new,7,
                      [{file,&quot;application_master.erl&quot;},{line,294}]}]}}}}}

=INFO REPORT==== 22-Oct-2014::23:47:18 ===
    application: simple_cache
    exited: {bad_return,
                {
                {sc_app,start,[normal,[]]},
                 {&#39;EXIT&#39;,
                     {undef,
                         [{sr_store,init,[],[]},
                          {sc_app,start,2,
                              [{file,&quot;../src/sc_app.erl&quot;},{line,6}]},
                          {application_master,start_supervisor,3,
                              [{file,&quot;application_master.erl&quot;},{line,326}]},
                          {application_master,start_the_app,5,
                              [{file,&quot;application_master.erl&quot;},{line,308}]},
                          {application_master,start_it_new,7,
                              [{file,&quot;application_master.erl&quot;},
                               {line,294}]}]}}}}
    type: temporary
2&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 看看application行为在启动一个otp应用的简单流程&lt;/h2&gt;

&lt;p&gt;　　首先，在erlang环境下执行code:which(application)查看application编译后的文件路径：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Eshell V6.1  (abort with ^G)
1&amp;gt; code:which(application).
&quot;/usr/local/lib/erlang/lib/kernel-3.0.1/ebin/application.beam&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　然后，找到application的源文件，熟悉OTP项目目录结构的同志应该很清楚这里应该怎么做了吧，回顾一下OTP项目目录结构：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;doc  存放文档；&lt;/li&gt;
&lt;li&gt;ebin  存放编译后的代码以及应用包含应用原子数据的app文件；&lt;/li&gt;
&lt;li&gt;include  存放公共头文件；&lt;/li&gt;
&lt;li&gt;priv  存放各种需要随应用一起发布的其他内容，如模板文件，共享文件对象以及DLL等；&lt;/li&gt;
&lt;li&gt;src  存放应用源代码；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　所以简单就能找到application的源文件了，在/usr/local/lib/erlang/lib/kernel-3.0.1/src/下面，这个目录里面还有其他源文件，安全、简单的方法是拷贝到临时目录里来看，看下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@kali:~/Desktop/erl/6-EOIA/ebin# mkdir ~/Desktop/temp
root@kali:~/Desktop/erl/6-EOIA/ebin# cp /usr/local/lib/erlang/lib/kernel-3.0.1/src/application*.erl ~/Desktop/ temp/
root@kali:~/Desktop/erl/6-EOIA/ebin# ls ~/Desktop/te
temp/ test/
root@kali:~/Desktop/erl/6-EOIA/ebin# ls ~/Desktop/temp/
application_controller.erl  application.erl  application_master.erl  application_starter.erl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　Ok, 一切就绪，开干了！先在application.erl里找到start这个函数，如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-spec start(Application) -&amp;gt; &#39;ok&#39; | {&#39;error&#39;, Reason} when
      Application :: atom(),
      Reason :: term().

start(Application) -&amp;gt;
    start(Application, temporary).

-spec start(Application, Type) -&amp;gt; &#39;ok&#39; | {&#39;error&#39;, Reason} when
      Application :: atom(),
      Type :: restart_type(),
      Reason :: term().

start(Application, RestartType) -&amp;gt;
    case load(Application) of
  ok -&amp;gt;
      Name = get_appl_name(Application),
      application_controller:start_application(Name, RestartType);
  {error, {already_loaded, Name}} -&amp;gt;
      application_controller:start_application(Name, RestartType);
  Error -&amp;gt;
      Error
    end.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　可以发现，start已经是一个很高层的封装了，源代码注释里也说了，application.erl只是对application_master.erl和application_controller.erl的一个封装。这里我们是调用了start/1，即以temporary为重启方式来启动我们的simple_cache。start过程从宏观上分为两大步：load和start。其中首先load，然后start，load的结果有三种：&lt;/p&gt;

&lt;blockquote&gt;&lt;ul&gt;
&lt;li&gt;ok：加入start流程；&lt;/li&gt;
&lt;li&gt;{error, {already_loaded, Name}}：失败，原因是这个应用已经load过了，可以直接加入start流程；&lt;/li&gt;
&lt;li&gt;Error：错误，且错误原因不详，需要看console里的输出分析；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　Ok, 思路清晰了，我们就split it into two seperate but sequential procedures，一步一步来，争取最后不靠调试就解决我们上面遇到的问题吧， here we go！&lt;/p&gt;

&lt;h2&gt;3. load应用的过程分析&lt;/h2&gt;

&lt;p&gt;　　根据application.erl 里第97行知道，load过程是调用application_controller.erl里的函数的，所以这里我们就先去分析application_controller.erl里的load调用了。先上一张图来简单看看load的整个过程。
&lt;img src=&quot;../../images/erlang-application-load.jpg&quot; alt=&quot;load 流程图分析&quot; /&gt;
　　上面的图可能画得稍显复杂，没办法，刚开始看源码，还是仔细一点好。仔细了解后，我发现load过程其中重点就只有下面四条：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;检查这个应用是否已经load过；&lt;/li&gt;
&lt;li&gt;解析应用描述文件appname.app里的内容；&lt;/li&gt;
&lt;li&gt;根据应用描述文件的描述，把应用的一些原子信息存到一张本地的ets表中；&lt;/li&gt;
&lt;li&gt;给应用的PID发送一条&lt;code&gt;{ac_load_application_req, AppName}&lt;/code&gt;的消息；&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;3.1 load过程中容易发生错误的地方&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;do_load_application 过程, 解析应用描述文件appname.app出错，相关源码如下。make_appl是一个解析appname.app文件的封装。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;do_load_application(Application, S) -&amp;gt;
    case get_loaded(Application) of
        {true, _} -&amp;gt;
            throw({error, {already_loaded, Application}});
        false -&amp;gt;
            case make_appl(Application) of
                {ok, Appl} -&amp;gt; load(S, Appl);
                Error -&amp;gt; Error
            end
    end.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在cntrl(A, S, {ac_load_application_req, A})时发生错误，相关源码如下。但这里既是出错的话，返回的信息也是容易辨别的，即&lt;code&gt;{reply, ok, NewS}&lt;/code&gt;，和上面我的那个出错不一样。看来程序在load的过程中没有出错，好吧，那我们就来看看在start的过程中出上面错了。&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;handle_call({load_application, Application}, From, S) -&amp;gt;
    case catch do_load_application(Application, S) of
        {ok, NewS} -&amp;gt;
            AppName = get_appl_name(Application),
            case cntrl(AppName, S, {ac_load_application_req, AppName}) of
                true -&amp;gt;
                    {noreply, S#state{loading = [{AppName, From} |
                                                 S#state.loading]}};
                false -&amp;gt;
                    {reply, ok, NewS}
            end;
        {error, _} = Error -&amp;gt;
            {reply, Error, S};
        {&#39;EXIT&#39;, R} -&amp;gt;
            {reply, {error, R}, S}
    end;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　PS: 因为这篇博文应该是26号发布的，到现在还么有通过分析源码的方式来找bug，所以为了让本文早点面世，我提前从出错信息里找错误了。事实证明，远远没有我想象的这样复杂，关键是这句&lt;code&gt;[{file,&quot;../src/sc_app.erl&quot;},{line,6}]},&lt;/code&gt;， 我在sc_app.erl的第六行写错了一个字母，so...，不过后续我还会继续分析start过程，看看程序是怎么down的，也来看看怎么解读这个错误。&lt;/p&gt;

&lt;h2&gt;4. start应用的过程分析&lt;/h2&gt;
</content>
   </entry>
   

</feed>
